head	1.17;
access;
symbols;
locks; strict;
comment	@ * @;


1.17
date	98.07.02.01.14.39;	author granat;	state Exp;
branches;
next	1.16;

1.16
date	98.06.29.22.10.13;	author granat;	state Exp;
branches;
next	1.15;

1.15
date	97.10.21.14.53.11;	author granat;	state Exp;
branches;
next	1.14;

1.14
date	97.06.20.22.11.22;	author granat;	state Exp;
branches;
next	1.13;

1.13
date	97.06.05.18.56.51;	author granat;	state Exp;
branches;
next	1.12;

1.12
date	97.06.02.15.53.55;	author granat;	state Exp;
branches;
next	1.11;

1.11
date	97.01.30.02.19.50;	author agray;	state Exp;
branches;
next	1.10;

1.10
date	97.01.29.22.01.53;	author agray;	state Exp;
branches;
next	1.9;

1.9
date	97.01.29.21.49.28;	author agray;	state Exp;
branches;
next	1.8;

1.8
date	97.01.29.21.11.15;	author agray;	state Exp;
branches;
next	1.7;

1.7
date	96.10.31.02.19.54;	author agray;	state Exp;
branches;
next	1.6;

1.6
date	96.09.13.01.14.56;	author agray;	state Exp;
branches;
next	1.5;

1.5
date	96.09.13.00.57.33;	author agray;	state Exp;
branches;
next	1.4;

1.4
date	96.08.28.20.17.52;	author agray;	state Exp;
branches;
next	1.3;

1.3
date	96.07.19.17.57.30;	author agray;	state Exp;
branches;
next	1.2;

1.2
date	96.07.11.18.00.18;	author agray;	state Exp;
branches;
next	1.1;

1.1
date	96.05.06.23.21.57;	author agray;	state Exp;
branches;
next	;


desc
@Module containing general distance concepts.
@


1.17
log
@added median filtering
@
text
@/*******************************************************************************
MODULE NAME
da_signal

ONE-LINE SYNOPSIS
General functions related to signal processing.

SCOPE OF THIS MODULE
Any functions relating directly to other signal processing concepts which have 
representative modules in this library should go in the appropriate module.  
Functions that apply more generally are intended to go here.

SEE ALSO
Because the definition of this module is quite broad, there is some potential
overlap with several other modules in this library.

REFERENCE(S)
-

PROGRAM EXAMPLE(S)
1. /proj/cooltools/qf, RG.

NOTES
-

AG
*******************************************************************************/
#ifndef lint
static char rcsid[] = "$Id: da_signal.c,v 1.16 1998/06/29 22:10:13 granat Exp $";
#endif
/* This string variable allows the RCS identification info to be printed. */

/* 
 * $Log: da_signal.c,v $
 * Revision 1.16  1998/06/29 22:10:13  granat
 * added functions to calculate energies
 * revised functions to perform convolution via the FFT
 *
 * Revision 1.15  1997/10/21 14:53:11  granat
 * fixed corr/conv bug
 * made improvements to speed up corr/conv functions
 *
 * Revision 1.14  1997/06/20 22:11:22  granat
 * filled out conv/corr functions, cosmetic changes
 *
 * Revision 1.13  1997/06/05 18:56:51  granat
 * added slow_full_conv_vector
 *
 * Revision 1.12  1997/06/02 15:53:55  granat
 * changed to use new NR naming convention
 *
 * Revision 1.11  1997/01/30 02:19:50  agray
 * fixed bugs in range_normalize/unnormalize_cols().
 *
 * Revision 1.10  1997/01/29 22:01:53  agray
 * reordered functions.
 *
 * Revision 1.9  1997/01/29 21:49:28  agray
 * added range_of_cols(), changed range_normalize_cols().
 *
 * Revision 1.8  1997/01/29 21:11:15  agray
 * lots of source code formatting changes, some hacks to
 * range_normalize_cols(), changed ut lib. interface.
 *
 * Revision 1.7  1996/10/31 02:19:54  agray
 * renamed from "da_dist" to "da_signal";
 * changed .h and .c formats throughout library;
 * some reorganizing between modules;
 * added some functions from HMM project.
 * 
 * Revision 1.6  1996/09/13 01:14:56  agray
 * change name and comments for normalize_data().
 * 
 * Revision 1.5  1996/09/13 00:57:33  agray
 * cosmetic; reduced arguments of print_unnorm_cov_matrix().
 * 
 * Revision 1.4  1996/08/28 20:17:52  agray
 * cosmetic.
 * 
 * Revision 1.3  1996/07/19 17:57:30  agray
 * cosmetic, minor efficiency hack
 * 
 * Revision 1.2  1996/07/11 18:00:18  agray
 * added print_unnorm_matrix(), print_unnorm_cov_matrix(), print_unnorm_row(),
 * print_unnorm_col().
 * 
 * Revision 1.1  1996/05/06 23:21:57  agray
 * Initial revision
 * 
 * */

/* C library */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>

/* UT library */
#include "ut_error.h"
#include "ut_output.h"
#include "ut_string.h"
#include "ut_types.h"

/* NR library */
#include "nr.h"

/* DA library */
#include "da.h"

/* this module's header */
#include "da_signal.h"


/*******************************************************************************
ENERGY_VEC
Return the total energy in a vector of floats.
RG
*******************************************************************************/
float energy_vec(float *v, int n)
{
  float *p;
  float *p_end;
  float energy = 0.0;
 
  /* assign pointer to last element */
  p_end = &v[n];
 
  /* calculate energy */
  for (p = &v[1]; p <= p_end; p++)
    energy += NR_sqr(*p);
 
  return (energy);
}


/*******************************************************************************
ENERGY_DVEC
Return the total energy in a vector of doubles.
RG
*******************************************************************************/
double energy_dvec(double *v, int n)
{
  double *p;
  double *p_end;
  double energy = 0.0;
 
  /* assign pointer to last element */
  p_end = &v[n];
 
  /* calculate energy */
  for (p = &v[1]; p <= p_end; p++)
    energy += NR_sqr(*p);
 
  return (energy);
}
 

/*******************************************************************************
NORMALIZE_ENERGY_VEC
Normalize a vector (signal) so that it has energy 1, and return the energy
in that vector before normalization.
RG
*******************************************************************************/
float normalize_energy_vec(float *v, int n)
{
  float energy;
  
  energy = energy_vec(v, n);
  scalar_div_vec(v, n, sqrt((double) energy));
  
  return (energy);
}


/*******************************************************************************
NORMALIZE_ENERGY_DVEC
Normalize a vector (signal) of doubles so that it has energy 1, and return the 
energy in that vector before normalization.
RG
*******************************************************************************/
double normalize_energy_dvec(double *v, int n)
{
  double energy;
  
  energy = energy_dvec(v, n);
  scalar_div_dvec(v, n, sqrt(energy));
  
  return (energy);
}


/*******************************************************************************
REAL_FFT_2D
Calculate the fast fourier transform of a matrix, or the inverse fast fourier
transform of a matrix in transform space.  Hacked from NR function nrlft3.
RG
*******************************************************************************/
int real_fft_2D(float **data, float *speq, int nn2, int nn3, int isign)
{
unsigned long i2,i3,j1,j2,j3,nn[4],ii3;
double theta,wi,wpi,wpr,wr,wtemp;
float c1,c2,h1r,h1i,h2r,h2i;

if (1+&data[nn2][nn3]-&data[1][1] != nn2*nn3)
  NR_error("rlft3: problem with dimensions or contiguity of data array\n");
  c1=0.5;
  c2 = -0.5*isign;
  theta=isign*(6.28318530717959/nn3);
  wtemp=sin(0.5*theta);
  wpr = -2.0*wtemp*wtemp;
  wpi=sin(theta);
  nn[1]=nn2;
  nn[2]=nn3 >> 1;
  if (isign == 1) {
    NR_fourn(&data[1][1]-1,nn,2,isign);
    for (i2=1,j2=0;i2<=nn2;i2++) {
      speq[++j2]=data[i2][1];
      speq[++j2]=data[i2][2];
    }
  }
  j1=1;
  wr=1.0;
  wi=0.0;
  for (ii3=1,i3=1;i3<=(nn3>>2)+1;i3++,ii3+=2) {
    for (i2=1;i2<=nn2;i2++) {
      if (i3 == 1) {
        j2=(i2 != 1 ? ((nn2-i2)<<1)+3 : 1);
        h1r=c1*(data[i2][1]+speq[j2]);
        h1i=c1*(data[i2][2]-speq[j2+1]);
        h2i=c2*(data[i2][1]-speq[j2]);
        h2r= -c2*(data[i2][2]+speq[j2+1]);
        data[i2][1]=h1r+h2r;
        data[i2][2]=h1i+h2i;
        speq[j2]=h1r-h2r;
        speq[j2+1]=h2i-h1i;
      } else {
        j2=(i2 != 1 ? nn2-i2+2 : 1);
        j3=nn3+3-(i3<<1);
        h1r=c1*(data[i2][ii3]+data[j2][j3]);
        h1i=c1*(data[i2][ii3+1]-data[j2][j3+1]);
        h2i=c2*(data[i2][ii3]-data[j2][j3]);
        h2r= -c2*(data[i2][ii3+1]+data[j2][j3+1]);
        data[i2][ii3]=h1r+wr*h2r-wi*h2i;
        data[i2][ii3+1]=h1i+wr*h2i+wi*h2r;
        data[j2][j3]=h1r-wr*h2r+wi*h2i;
        data[j2][j3+1]= -h1i+wr*h2i+wi*h2r;
      }
    }
    wr=(wtemp=wr)*wpr-wi*wpi+wr;
    wi=wi*wpr+wtemp*wpi+wi;
  }
  if (isign == -1)
    NR_fourn(&data[1][1]-1,nn,2,isign);

  return (UT_OK);
}

/*******************************************************************************
FFT_CONV_MATRIX
Convolve two matrices using the fft.  The two input matrices may be of 
arbitrary size, but the function requires two workspace matrices and two 
workspace vectors be supplied.

If the input matrices are of dimension (M x N) and (U x V), the workspace
matrices must have minimum dimensions of the nearest powers of two greater
than or equal to (M + U - 1) x (N + V - 1).  The workspace vectors must
be of length equal to twice the number of rows of the workspace matrices.

The output matrix should be no larger than (M + U - 1) x (N + V - 1).
RG
*******************************************************************************/
int fft_conv_matrix(float **a, int nr_a, int nc_a, float **b, int nr_b,
                    int nc_b, float **c, int nr_c, int nc_c, float **data1,
		    float **data2, float *speq1, float *speq2)
{
  int    i;
  int    nr_radix2, nc_radix2;
  int    row_start, col_start;
  int    max_index;
  float  real, imag;
  float  scale;
  float *p1_real, *p1_imag;
  float *p2_real, *p2_imag;

  /* recalculate rows and columns of the temporary matrices */
  nr_radix2 = ((nr_a + nr_b - 1) >> 1) << 1;
  nc_radix2 = ((nc_a + nc_b - 1) >> 1) << 1;
  
  /* initialize the temporary matrices */
  fast_zero_mat(data1, nr_radix2, nc_radix2);
  fast_zero_mat(data2, nr_radix2, nc_radix2);

  /* transfer values of matrix a to temporary array with zero-padding */
  row_start = ((nr_radix2 - nr_a) >> 1) + 1;
  col_start = ((nc_radix2 - nc_a) >> 1) + 1;
  copy_mat_section(a, data1, 1, 1, row_start, col_start, nr_a, nc_a);

  /* transfer values of matrix b to temporary array with zero-padding */
  row_start = ((nr_radix2 - nr_b) >> 1) + 1;
  col_start = ((nc_radix2 - nc_b) >> 1) + 1;
  copy_mat_section(b, data2, 1, 1, row_start, col_start, nr_b, nc_b);
  
  /* perform the fft of the two data matrices */
  real_fft_2D(data1, speq1, nr_radix2, nc_radix2, 1);
  real_fft_2D(data2, speq2, nr_radix2, nc_radix2, 1);
  
  /* multiply in the frequency domain */
  max_index = nr_radix2 * nc_radix2 >> 1;
  scale = 2.0 / (nr_radix2 * nc_radix2);
  
  p1_real = &data1[1][1];
  p1_imag = &data1[1][2];

  p2_real = &data2[1][1];
  p2_imag = &data2[1][2];

  for (i = 1; i <= max_index; i++) {
    real = (*p1_real) * (*p2_real) - (*p1_imag) * (*p2_imag);
    imag = (*p1_real) * (*p2_imag) + (*p1_imag) * (*p2_real);
    *p1_real = scale * real;
    *p1_imag = scale * imag;
    p1_real += 2;
    p1_imag += 2;
    p2_real += 2;
    p2_imag += 2;
  }
  
  p1_real = &speq1[1];
  p1_imag = &speq1[2];

  p2_real = &speq2[1];
  p2_imag = &speq2[2];
  
  for (i = 1; i <= nr_radix2; i++) {
    real = (*p1_real) * (*p2_real) - (*p1_imag) * (*p2_imag);
    imag = (*p1_real) * (*p2_imag) + (*p1_imag) * (*p2_real);
    *p1_real = scale * real;
    *p1_imag = scale * imag;
    p1_real += 2;
    p1_imag += 2;
    p2_real += 2;
    p2_imag += 2;
  }
  
  /* perform the reverse transform */
  real_fft_2D(data1, speq1, nr_radix2, nc_radix2, 1);
  
  /* copy the data from the temporary matrix to the output matrix */
  row_start = ((nr_radix2 - nr_c) >> 1) + 1;
  col_start = ((nc_radix2 - nc_c) >> 1) + 1;
  copy_mat_section(data1, c, row_start, col_start, 1, 1, nr_c, nc_c);

  return (UT_OK);
}

/*******************************************************************************
FFT_CONV_ALLOC_MATRIX
Convolve two matrices using the fft.  This routine simply allocates workspace
and calls fft_conv_matrix().

See fft_conv_matrix().
*******************************************************************************/
int fft_conv_alloc_matrix(float **a, int nr_a, int nc_a, float **b, int nr_b,
                          int nc_b, float **c, int nr_c, int nc_c)
{
  int     nr_radix2, nc_radix2;
  float **data1, **data2;
  float  *speq1, *speq2;
  
  /* calculate the rows and columns of the temporary matrices */
  nr_radix2 = ((nr_a + nr_b - 1) >> 1) << 1;
  nc_radix2 = ((nc_a + nc_b - 1) >> 1) << 1;
  
  /* allocate the temporary matrices and vectors */
  data1 = NR_matrix(1, nr_radix2, 1, nc_radix2);
  data2 = NR_matrix(1, nr_radix2, 1, nc_radix2);
  
  speq1 = NR_vector(1, 2 * nr_radix2);
  speq2 = NR_vector(1, 2 * nr_radix2);
  
  /* perform the convolution */
  fft_conv_matrix(a, nr_a, nc_a, b, nr_b, nc_b, c, nr_c, nc_c, data1, data2,
                  speq1, speq2);
  
  /* free the workspace */
  NR_free_matrix(data1, 1, nr_radix2, 1, nc_radix2);
  NR_free_matrix(data2, 1, nr_radix2, 1, nc_radix2);
  
  NR_free_vector(speq1, 1, 2 * nr_radix2);
  NR_free_vector(speq2, 1, 2 * nr_radix2);
  
  return (UT_OK);
}

/*******************************************************************************
SLOW_FULL_CONV_VECTOR
Perform a 1D convolution of two vectors of length N and M, and return the 
result in a vector of size (N+M-1).  There are no approximations made to speed 
up the computation, but elements of the first vector are checked to make sure 
they are non-zero before operations are performed.  Therefore, the vector with 
the greater number of non-zero elements should be input as the first vector.
*******************************************************************************/
int slow_full_conv_vector(float *a, int n_a, float *b, int n_b, float *c, 
                          int n_c)
{
  int    i, j;
  float  *p_a, *p_b, *p_c;

  fast_zero_vec(c, n_c);

  p_a = &a[1];
  for (i = 1; i <= n_a; i++) {
    if (*p_a != 0.0) {
      p_b = &b[1];
      p_c = &c[i];
      for (j = 1; j <= n_b; j++) {
        *p_c += (*p_a) * (*p_b);
        p_b++;
        p_c++;
      }
    }
    p_a++;
  }

  return (UT_OK);
}


/*******************************************************************************
SLOW_CROP_CONV_VECTOR
Perform a 1D convolution of two vectors with dimensions N and U, and return
the result in a vector of length T, where T <= (N + U - 1).  See
slow_full_conv_vector.
RG
*******************************************************************************/
int slow_crop_conv_vector( float *a, int n_a, float *b, int n_b, float *c,
                           int n_c )
{
  int i, j, k;
  int n_full;
  int n_diff;
  int start;
 
  n_full = n_a + n_b - 1;
 
  n_diff = n_full - n_c;
 
  start = (n_diff >> 1) + 1;
 
  fast_zero_vec( c, n_c );
 
  for (i = 1; i <= n_a; i++)
    if (a[i] != 0.0)
      for (j = 1; j <= n_b; j++) {
        k = i + j - start;
        if ((k >= 1) && (k <= n_c))
          c[k] += a[i] * b[j];
      }
 
  return( UT_OK );
}

/*******************************************************************************
SLOW_FULL_CONV_MATRIX
Perform a 2D convolution of two matrices with dimensions NxM and UxV, and
return the result in a matrix of size (N+U-1)x(M+V-1).  There are no
approximations made to speed up the computation, but elements of the first
matrix are checked to make sure they are non-zero before operations are
performed.  Therefore, the matrix with the greater number of non-zero elements
should be input as the first matrix.
*******************************************************************************/
int slow_full_conv_matrix(float **a, int nr_a, int nc_a, float **b, int nr_b, 
                          int nc_b, float **c, int nr_c, int nc_c) 
{ 
  int    i, j, k, l;
  float  *p_a, *p_b, *p_c;

  fast_zero_mat(c, nr_c, nc_c);

  p_a = &a[1][1];
  for (i = 1; i <= nr_a; i++)
    for (j = 1; j <= nc_a; j++) {
      if (*p_a != 0.0) {
        p_b = &b[1][1];
        for (k = 1; k <= nr_b; k++) {
          p_c = &c[i+k-1][j];
          for (l = 1; l <= nc_b; l++) {
            *p_c += (*p_a) * (*p_b);
            p_b++;
            p_c++;
          }
        }
      }
      p_a++;
    }

  return (UT_OK);
}

/*******************************************************************************
SLOW_FULL_NORM_CONV_MATRIX
Perform a 2D convolution of two matrices with dimensions NxM and UxV, and
return the normalized result in a matrix of size (N+U-1)x(M+V-1).  See 
slow_full_conv_matrix().
*******************************************************************************/
int slow_full_norm_conv_matrix(float **a, int nr_a, int nc_a, float **b, 
                               int nr_b, int nc_b, float **c, int nr_c, 
                               int nc_c)
{
  int    i, j, k, l;
  float  *p_a, *p_b, *p_c;
  float  mean_a, mean_b;
  float  var_a, var_b;
  float  norm;
 
  /* calculate statistics of a and b */

  mean_a = mean_mat(a, nr_a, nc_a);
  mean_b = mean_mat(b, nr_b, nc_b);

  var_a = var_mat(a, nr_a, nc_a, mean_a);
  var_b = var_mat(b, nr_b, nc_b, mean_b);

  norm = (float) (sqrt((double) var_a) * sqrt((double) var_b));

  /* subtract off the mean to save operations in the inner loop */

  scalar_subtract_mat(a, nr_a, nc_a, mean_a);
  scalar_subtract_mat(b, nr_b, nc_b, mean_b);

  /* zero out the new matrix */

  fast_zero_mat(c, nr_c, nc_c);

  p_a = &a[1][1];
  for (i = 1; i <= nr_a; i++)
    for (j = 1; j <= nc_a; j++) {
      if (*p_a != 0.0) {
        p_b = &b[1][1];
        for (k = 1; k <= nr_b; k++) {
          p_c = &c[i+k-1][j];
          for (l = 1; l <= nc_b; l++) {
            *p_c += (*p_a) * (*p_b);
            p_b++;
            p_c++;
          }
        }
      }
      p_a++;
    }

  /* normalize the result */

  scalar_div_mat(c, nr_c, nc_c, norm);

  /* restore the input matrices */

  scalar_add_mat(a, mean_a, nr_a, nc_a);
  scalar_add_mat(b, mean_b, nr_b, nc_b);

  return (UT_OK);
}


/*******************************************************************************
SLOW_CROP_CONV_MATRIX
Perform a 2D convolution of two matrices with dimensions NxM and UxV, and
return the center of the result in a matrix of size T x S, where 
T < (N + U - 1) and S < (M + V - 1).  See slow_full_conv_matrix().
*******************************************************************************/
int slow_crop_conv_matrix(float **a, int nr_a, int nc_a, float **b, int nr_b, 
                          int nc_b, float **c, int nr_c, int nc_c)
{
  int    i, j, k, l;
  int    nr_full, nc_full;
  int    nr_diff, nc_diff;
  int    r_start, c_start;
  int    r_end, c_end;
  int    row, col;
  int    full_row, full_col;
  float  *p_a, *p_b, *p_c;
 
  nr_full = nr_a + nr_b - 1;
  nc_full = nc_a + nc_b - 1;

  nr_diff = nr_full - nr_c;
  nc_diff = nc_full - nc_c;

  r_start = (int) floor(((float) nr_diff) / 2.0) + 1;
  c_start = (int) floor(((float) nc_diff) / 2.0) + 1;

  r_end = nr_full - (int) ceil(((float) nr_diff) / 2.0);
  c_end = nr_full - (int) ceil(((float) nc_diff) / 2.0);
  
  fast_zero_mat(c, nr_c, nc_c);
 
  for (i = 1; i <= nr_a; i++)
    if (i <= r_end) {
      p_a = &a[i][1];
      for (j = 1; j <= nc_a; j++)
        if (j <= c_end) {
          if (*p_a != 0.0) {
            if (j > c_start)
              col = j - c_start;
            else
              col = 1;
            for (k = 1, row = i - r_start + 1, full_row = i; \
                 full_row <= r_end; k++, row++, full_row++)
              if (row >= 1) {
                p_b = &b[k][1];
                p_c = &c[row][col];
                for (l = 1, full_col = j; full_col <= c_end; l++, full_col++) {
                  if (full_col >= c_start) {
                    *p_c += (*p_a) * (*p_b);
                    p_c++;
                  }
                  p_b++;
                }
              }
          }
          p_a++;
        }
    }

  return (UT_OK);
}

/*******************************************************************************
SLOW_FULL_CORR_VECTOR
Perform a 1D correlation of two vectors of length N and M, and return the 
result in a vector of size (N+M-1).  No tricks are used to make the computation
faster, but there are no approximations made.
*******************************************************************************/
int slow_full_corr_vector(float *a, int n_a, float *b, int n_b, float *c, 
                          int n_c)
{
  flip_vector(a, n_a);

  slow_full_conv_vector(a, n_a, b, n_b, c, n_c);

  flip_vector(a, n_a);
  
  return (UT_OK);
}

/*******************************************************************************
SLOW_FULL_CORR_MATRIX
Perform a 2D correlation of two matrices with dimensions NxM and UxV, and
return the result in a matrix of size (N+U-1)x(M+V-1).  No tricks are used 
to make the computation faster, but there are no approximations made.
*******************************************************************************/
int slow_full_corr_matrix(float **a, int nr_a, int nc_a, float **b, int nr_b,
                          int nc_b, float **c, int nr_c, int nc_c)
{
  flip_top_bottom_matrix(a, nr_a, nc_a);
  flip_left_right_matrix(a, nr_a, nc_a);

  slow_full_conv_matrix(a, nr_a, nc_a, b, nr_b, nc_b, c, nr_c, nc_c);

  flip_left_right_matrix(a, nr_a, nc_a);
  flip_top_bottom_matrix(a, nr_a, nc_a);

  return (UT_OK);
}

/*******************************************************************************
SLOW_CROP_CORR_MATRIX
Perform a 2D correlation of two matrices with dimensions NxM and UxV, and
return the center of the result in a matrix of size T x S, where 
T < (N + U - 1) and S < (M + V - 1).  No tricks are used to make the 
computation faster, but there are no approximations made.
*******************************************************************************/
int slow_crop_corr_matrix(float **a, int nr_a, int nc_a, float **b, int nr_b,
                          int nc_b, float **c, int nr_c, int nc_c)
{
  flip_top_bottom_matrix(a, nr_a, nc_a);
  flip_left_right_matrix(a, nr_a, nc_a);

  slow_crop_conv_matrix(a, nr_a, nc_a, b, nr_b, nc_b, c, nr_c, nc_c);

  flip_left_right_matrix(a, nr_a, nc_a);
  flip_top_bottom_matrix(a, nr_a, nc_a);

  return (UT_OK);
}

/*******************************************************************************
SLOW_FULL_NORM_CORR_MATRIX
Perform a 2D correlation of two matrices with dimensions NxM and UxV, and
return the normalized result in a matrix of size (N+U-1)x(M+V-1).  No tricks
are used to make the computation faster, but there are no approximations made.
*******************************************************************************/
int slow_full_norm_corr_matrix(float **a, int nr_a, int nc_a, float **b,
                               int nr_b, int nc_b, float **c, int nr_c, 
                               int nc_c)
{
  flip_top_bottom_matrix(a, nr_a, nc_a);
  flip_left_right_matrix(a, nr_a, nc_a);
 
  slow_full_norm_conv_matrix(a, nr_a, nc_a, b, nr_b, nc_b, c, nr_c, nc_c);

  flip_left_right_matrix(a, nr_a, nc_a);
  flip_top_bottom_matrix(a, nr_a, nc_a);

  return (UT_OK);
}


/*******************************************************************************
MEDIAN3_FILT_MATRIX
Perform median filtering on a matrix using a 3x3 filter.  Ignores the boundary
elements.  Some gimmicks are here to maximize the computation done per memory
access.
RG
*******************************************************************************/
int median3_filt_matrix(float **A, int nr, int nc, float **B)
{
  register int    i, j;
  register float *baseA0, *baseA1, *baseA2;
  register float  ax00, ax01, ax02;
  register float  ax10, ax11, ax12;
  register float  ax20, ax21, ax22;
  register float  b0, b1, b2, b3, b4;

  if ((nr > 2) && (nc > 2)) {

    /* copy the borders of the matrix */

    memcpy(&B[1][1], &A[1][1], nc * sizeof(float));
    memcpy(&B[nr][1], &A[nr][1], nc * sizeof(float));
    for (i = 2; i < nr; i++) {
      B[i][1] = A[i][1];
      B[i][nc] = A[i][nc];
    }

    /* perform median filtering on the internal region */

    baseA0 = &A[1][1];
    baseA1 = baseA0 + nc;
    baseA2 = baseA1 + nc;
    
    for (i = 2; i < nr; i++) {
      
      /* assign values for the 3x3 window at the start of the row */

      ax00 = baseA0[0];
      ax01 = baseA0[1];
      ax02 = baseA0[2];
      ax10 = baseA1[0];
      ax11 = baseA1[1];
      ax12 = baseA1[2];
      ax20 = baseA2[0];
      ax21 = baseA2[1];
      ax22 = baseA2[2];

      for (j = 2; j < nc; j++) {

	/* sort the elements */

        b0 = ax00;

        if (ax01 >= b0)
          b1 = ax01;
        else {
          b1 = b0;
          b0 = ax00;
        }
    
	if (ax02 >= b1)
	  b2 = ax02;
	else if (ax02 >= b0) {
	  b2 = b1;
	  b1 = ax02;
	}
	else {
	  b2 = b1;
	  b1 = b0;
	  b0 = ax02;
	}

	if (ax10 >= b2)
	  b3 = ax10;
	else if (ax10 >= b1) {
          b3 = b2;
	  b2 = ax10;
	}
        else if (ax10 > b0) {
	  b3 = b2;
	  b2 = b1;
	  b1 = ax10;
        }
        else {
          b3 = b2;
          b2 = b1;
          b1 = b0;
          b0 = ax10;
        }
    
	if (ax11 >= b3) 
	  b4 = ax11;
	else if (ax11 >= b2) {
	  b4 = b3;
	  b3 = ax11;
	}
	else if (ax11 >= b1) {
	  b4 = b3;
	  b3 = b2;
	  b2 = ax11;
    	}
        else if (ax11 >= b0) {
	  b4 = b3;
	  b3 = b2;
	  b2 = b1;
	  b1 = ax11;
        }
        else {
          b4 = b3;
          b3 = b2;
          b2 = b1;
          b1 = b0;
          b0 = ax11;
        }
    
	if (ax12 >= b4);
	else if (ax12 >= b3)
	  b4 = ax12;
	else if (ax12 >= b2) {
	  b4 = b3;
	  b3 = ax12;
	}
	else if (ax12 >= b1) {
	  b4 = b3;
	  b3 = b2;
	  b2 = ax12;
	}
        else if (ax12 >= b0) {
	  b4 = b3;
	  b3 = b2;
	  b2 = b1;
	  b1 = ax12;
        }
        else {
          b4 = b3;
          b3 = b2;
          b2 = b1;
          b1 = b0;
        }
    
	if (ax20 >= b4);
	else if (ax20 >= b3)
	  b4 = ax20;
	else if (ax20 >= b2) {
	  b4 = b3;
	  b3 = ax20;
	}
	else if (ax20 >= b1) {
          b4 = b3;
	  b3 = b2;
	  b2 = ax20;
	}
        else {
	  b4 = b3;
	  b3 = b2;
	  b2 = b1;
        }
    
	if (ax21 >= b4);
	else if (ax21 >= b3)
	  b4 = ax21;
	else if (ax21 >= b2) {
	  b4 = b3;
	  b3 = ax21;
	}
	else if (ax21 >= b1) {
	  b4 = b3;
	  b3 = b2;
        }
    
	/* assign the median element */

	if (ax22 >= b4)
	  B[i][j] = b4;
	else if (ax22 >= b3)
	  B[i][j] = ax22;
	else
	  B[i][j] = b3;
	
	/* assign new values for the shifted 3x3 window */

	if (j < nc - 1) {
	  baseA0++;
	  baseA1++;
	  baseA2++;

	  ax00 = ax01;
	  ax01 = ax02;
	  ax02 = baseA0[2];
	  ax10 = ax11;
	  ax11 = ax12;
	  ax12 = baseA1[2];
	  ax20 = ax21;
	  ax21 = ax22;
	  ax22 = baseA2[2];
	}
      }

      baseA0 += 3;
      baseA1 += 3;
      baseA2 += 3;
    }
  }
  else {
    printf("Matrix too small for median filtering\n");
    return (UT_ERROR);
  }
  
  return (UT_OK);
}


/*******************************************************************************
MEDIAN3_FILT_DMATRIX
Perform median filtering on a matrix of doubles using a 3x3 filter.  Ignores 
the boundary elements.  Some gimmicks are here to maximize the computation 
done per memory access.
RG
*******************************************************************************/
int median3_filt_dmatrix(double **A, int nr, int nc, double **B)
{
  register int     i, j;
  register double *baseA0, *baseA1, *baseA2;
  register double  ax00, ax01, ax02;
  register double  ax10, ax11, ax12;
  register double  ax20, ax21, ax22;
  register double  b0, b1, b2, b3, b4;

  if ((nr > 2) && (nc > 2)) {

    /* copy the borders of the matrix */

    memcpy(&B[1][1], &A[1][1], nc * sizeof(double));
    memcpy(&B[nr][1], &A[nr][1], nc * sizeof(double));
    for (i = 2; i < nr; i++) {
      B[i][1] = A[i][1];
      B[i][nc] = A[i][nc];
    }

    /* perform median filtering on the internal region */

    baseA0 = &A[1][1];
    baseA1 = baseA0 + nc;
    baseA2 = baseA1 + nc;
    
    for (i = 2; i < nr; i++) {
      
      /* assign values for the 3x3 window at the start of the row */

      ax00 = baseA0[0];
      ax01 = baseA0[1];
      ax02 = baseA0[2];
      ax10 = baseA1[0];
      ax11 = baseA1[1];
      ax12 = baseA1[2];
      ax20 = baseA2[0];
      ax21 = baseA2[1];
      ax22 = baseA2[2];

      for (j = 2; j < nc; j++) {

	/* sort the elements */

        b0 = ax00;

        if (ax01 >= b0)
          b1 = ax01;
        else {
          b1 = b0;
          b0 = ax00;
        }
    
	if (ax02 >= b1)
	  b2 = ax02;
	else if (ax02 >= b0) {
	  b2 = b1;
	  b1 = ax02;
	}
	else {
	  b2 = b1;
	  b1 = b0;
	  b0 = ax02;
	}

	if (ax10 >= b2)
	  b3 = ax10;
	else if (ax10 >= b1) {
          b3 = b2;
	  b2 = ax10;
	}
        else if (ax10 > b0) {
	  b3 = b2;
	  b2 = b1;
	  b1 = ax10;
        }
        else {
          b3 = b2;
          b2 = b1;
          b1 = b0;
          b0 = ax10;
        }
    
	if (ax11 >= b3) 
	  b4 = ax11;
	else if (ax11 >= b2) {
	  b4 = b3;
	  b3 = ax11;
	}
	else if (ax11 >= b1) {
	  b4 = b3;
	  b3 = b2;
	  b2 = ax11;
    	}
        else if (ax11 >= b0) {
	  b4 = b3;
	  b3 = b2;
	  b2 = b1;
	  b1 = ax11;
        }
        else {
          b4 = b3;
          b3 = b2;
          b2 = b1;
          b1 = b0;
          b0 = ax11;
        }
    
	if (ax12 >= b4);
	else if (ax12 >= b3)
	  b4 = ax12;
	else if (ax12 >= b2) {
	  b4 = b3;
	  b3 = ax12;
	}
	else if (ax12 >= b1) {
	  b4 = b3;
	  b3 = b2;
	  b2 = ax12;
	}
        else if (ax12 >= b0) {
	  b4 = b3;
	  b3 = b2;
	  b2 = b1;
	  b1 = ax12;
        }
        else {
          b4 = b3;
          b3 = b2;
          b2 = b1;
          b1 = b0;
        }
    
	if (ax20 >= b4);
	else if (ax20 >= b3)
	  b4 = ax20;
	else if (ax20 >= b2) {
	  b4 = b3;
	  b3 = ax20;
	}
	else if (ax20 >= b1) {
          b4 = b3;
	  b3 = b2;
	  b2 = ax20;
	}
        else {
	  b4 = b3;
	  b3 = b2;
	  b2 = b1;
        }
    
	if (ax21 >= b4);
	else if (ax21 >= b3)
	  b4 = ax21;
	else if (ax21 >= b2) {
	  b4 = b3;
	  b3 = ax21;
	}
	else if (ax21 >= b1) {
	  b4 = b3;
	  b3 = b2;
        }
    
	/* assign the median element */

	if (ax22 >= b4)
	  B[i][j] = b4;
	else if (ax22 >= b3)
	  B[i][j] = ax22;
	else
	  B[i][j] = b3;
	
	/* assign new values for the shifted 3x3 window */

	if (j < nc - 1) {
	  baseA0++;
	  baseA1++;
	  baseA2++;

	  ax00 = ax01;
	  ax01 = ax02;
	  ax02 = baseA0[2];
	  ax10 = ax11;
	  ax11 = ax12;
	  ax12 = baseA1[2];
	  ax20 = ax21;
	  ax21 = ax22;
	  ax22 = baseA2[2];
	}
      }

      baseA0 += 3;
      baseA1 += 3;
      baseA2 += 3;
    }
  }
  else {
    printf("Matrix too small for median filtering\n");
    return (UT_ERROR);
  }
  
  return (UT_OK);
}
@


1.16
log
@added functions to calculate energies
revised functions to perform convolution via the FFT
@
text
@d29 1
a29 1
static char rcsid[] = "$Id: da_signal.c,v 1.15 1997/10/21 14:53:11 granat Exp granat $";
d35 4
d199 1
a199 1
unsigned long i1,i2,i3,j1,j2,j3,nn[4],ii3;
a510 1
  float  sum;
d641 2
d704 424
@


1.15
log
@fixed corr/conv bug
made improvements to speed up corr/conv functions
@
text
@d29 1
a29 1
static char rcsid[] = "$Id: da_signal.c,v 1.14 1997/06/20 22:11:22 granat Exp granat $";
d35 4
d110 3
a112 40
RANGE_OF_COLS
For each of k columns in a matrix, find the minimum and maximum values, and
the range (difference between the two).  Pass in a size k vector for each of 
these latter sets of values, and they will be filled in by this function.  
AG
*******************************************************************************/
int range_of_cols(float **mat, float *minval, float *maxval, 
                  float *range, int numrows, int numcols)

{
  int i,j;

  /* for each attribute, find the min and max */
  for (j=1; j<=numcols; j++)
    minval[j] = maxval[j] = mat[1][j];

  for (i=2; i<=numrows; i++)
    for (j=1; j<=numcols; j++)
    {
      if (mat[i][j] < minval[j])
        minval[j] = mat[i][j];
      if (mat[i][j] > maxval[j])
        maxval[j] = mat[i][j];
    }

  /* for each attribute, compute the range */
  for (j=1; j<=numcols; j++)
    range[j] = maxval[j] - minval[j];
  
  return(UT_OK);
}

/*******************************************************************************
RANGE_NORMALIZE_COLS
Takes as input vectors containing the minimum values, and the range of values
(difference between the max and min), for each of the columns of a specified 
matrix.  Modifies the original matrix such that each value in each column is 
normalized by the range specified.  Thus, all entries in the matrix will end up
scaled to [0,1].
AG
d114 1
a114 3
int range_normalize_cols(float **mat, float *minval, float *range, 
                         int numrows, int numcols)

d116 12
a127 30
  int i,j;

  /* translate each attribute value by its minval and scale by its range */
  for (i=1; i<=numrows; i++)
    for (j=1; j<=numcols; j++)
      mat[i][j] = (mat[i][j] - minval[j]) / range[j];

  return (UT_OK);
}

/*******************************************************************************
RANGE_UNNORMALIZE_COLS
Restore a matrix of vectors reflecting data which have been normalized by the 
range of values in each column.
AG
*******************************************************************************/
int range_unnormalize_cols(float **mat, float *minval, float *range, 
                         int numrows, int numcols)

{
  int i,j;

  /* scale each attribute value by its range and translate by its minval */
  for (i=1; i<=numrows; i++)
  {
    for (j=1;j<=numcols;j++)
      mat[i][j] = mat[i][j] * range[j] + minval[j];
  }

  return (UT_OK);
d132 3
a134 4
RANGE_UNNORMALIZE_COV_MATRIX
Restore a covariance matrix derived from data which have been normalized by 
the range of values in each column.
AG
d136 1
a136 3
int range_unnormalize_cov_matrix(float **mat, int nc, float *range)


d138 12
a149 7
  int i,j;

  for (i=1; i<=nc; i++)
    for (j=1;j<=nc;j++)
      mat[i][j] = mat[i][j] * range[i] * range[j];

  return (UT_OK);
d151 1
a151 1

d154 4
a157 4
RANGE_UNNORMALIZE_VECTOR
Restore a vector reflecting data which have been normalized by the range of 
values in each attribute (column, often).
AG
d159 1
a159 2
int range_unnormalize_vector(float *vec, int nc, float *range, float *minval)

d161 6
a166 6
  int i;

  for (i=1; i<=nc; i++)
    vec[i] = vec[i] * range[i] + minval[i];

  return (UT_OK);
d171 6
a176 65
PRINT_UNNORM_MATRIX
Print matrix of vectors which have been normalized by the range of values in
each column, in unnormalized form.
AG
******************************************************************************/
int print_unnorm_matrix(stream, nr, nc, mat, range, minval)

  FILE*  stream;  /* stream to print to, e.g. stdout, file pointer */
  int    nr, nc;  /* number of rows, columns of input matrix */
  float  **mat;   /* matrix to be printed */
  float  *range;  /* range of values for each attribute */
  float  *minval; /* minimum value in each attribute */
{
  int i,j;

  for (i=1; i<=nr; i++)
  {
    for (j=1;j<=nc;j++)
      fprintf(stream, "%g ", mat[i][j] * range[j] + minval[j]);
    fprintf(stream, "\n");
  }

  return (UT_OK);
}


/*******************************************************************************
PRINT_UNNORM_COV_MATRIX
Print covariance matrix which has been normalized by the range of values in
each row/column, in unnormalized form.
AG
*******************************************************************************/
int print_unnorm_cov_matrix(stream, nc, mat, range)

  FILE*  stream;  /* stream to print to, e.g. stdout, file pointer */
  int    nc;      /* number of rows, columns of input matrix - should be same */
  float  **mat;   /* matrix to be printed */
  float  *range;  /* range of values for each attribute */
{
  int i,j;

  for (i=1; i<=nc; i++) {
    for (j=1;j<=nc;j++) {
      fprintf(stream, "%g ", mat[i][j] * range[i] * range[j]);
    }
    fprintf(stream, "\n");
  }

  return (UT_OK);
}


/*******************************************************************************
PRINT_UNNORM_ROW
Print vector which has been normalized by the range of values in each 
column, in unnormalized form.  Prints in row form.
AG
*******************************************************************************/
int print_unnorm_row(stream, nc, v, range, minval)

  FILE*  stream;  /* stream to print to, e.g. stdout, file pointer */
  int    nc;      /* length of the row vector to be printed */
  float  *v;      /* vector to be printed */
  float  *range;  /* range of values for each attribute */
  float  *minval; /* minimum value in each attribute */
d178 6
a183 31
  int     i;

  for (i = 1; i <= nc; i++) {
      fprintf(stream, "%g ", v[i] * range[i] + minval[i]);
  }
  fprintf(stream, "\n");

  return (UT_OK);
}


/*******************************************************************************
PRINT_UNNORM_COL
Print vector which has been normalized by the range of values in each 
row, in unnormalized form.  Prints in column form.
AG
*******************************************************************************/
int print_unnorm_col(stream, nc, v, range, minval)

  FILE*  stream;  /* stream to print to, e.g. stdout, file pointer */
  int    nc;      /* length of the column vector to be printed */
  float  *v;      /* vector to be printed */
  float  *range;  /* range of values for each attribute */
  float  *minval; /* minimum value in each attribute */
{
  int     i;

  for (i = 1; i <= nc; i++)
    fprintf(stream, "%g\n", v[i] * range[i] + minval[i]);

  return (UT_OK);
d250 1
a250 1
  return( UT_OK );
d254 11
a264 6
FFT_CONV_ALLOC_MATRIX
Convolve two matrices using the fft.  If the two matrices are M x N and
U x V respectively, then the output matrix supplied must be of size 
(M + U - 1) x (N + V - 1).  Two temporary storage matrices are allocated 
within this function, each with dimension equal to the next power of two
larger than the respective input matrices.
d267 41
a307 37
int fft_conv_alloc_matrix( float **a, int nr_a, int nc_a, float **b, int nr_b,
                           int nc_b, float **c, int nr_c, int nc_c )
{
  int   nr, nc;
  float **m1, **m2;
  float *speq1, *speq2;
  int   pow2, half_nc, twice_nr;
  int   i, j;

  pow2 = pow( 2, (int) (log(nr_c) / M_LOG2E) );

  if (nr_c > pow2)
    nr = 2*pow2;
  else
    nr = pow2;

  pow2 = pow( 2, (int) (log(nc_c) / M_LOG2E) );

  if (nc_c > pow2)
    nc = 2*pow2;
  else
    nc = pow2;

  m1 = NR_matrix( 1, nr, 1, nc );
  m2 = NR_matrix( 1, nr, 1, nc );

  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++) {
      if ( (i <= nr_a) && (j <= nc_a) )
        m1[i][j] = a[i][j];
      else
        m1[i][j] = 0;
      if ( (i <= nr_b) && (j <= nc_b) )
        m2[i][j] = b[i][j];
      else
        m2[i][j] = 0;
    }
d309 2
a310 1
  twice_nr = 2 * nr;
d312 13
a324 2
  speq1 = NR_vector( 1, twice_nr );
  speq2 = NR_vector( 1, twice_nr ); 
d326 21
a346 2
  real_fft_2D( m1, speq1, nr, nc, 1);
  real_fft_2D( m2, speq2, nr, nc, 1);
d348 2
a349 1
  half_nc = (int) nc / 2;
d351 4
a354 3
  for (i = 1; i <= nr; i++)
    for (j = 1; j <= half_nc; j++)
      m2[i][j] *= m1[i][j];
d356 32
a387 15
  for (i = 1; i <= twice_nr; i++)
    speq2[i] *= speq1[i];

  real_fft_2D( m2, speq2, nr, nc, -1);

  for (i = 1; i <= nr_c; i++)
    for (j = 1; j <= nc_c; j++)
      c[i][j] = m2[i][j];

  NR_free_matrix( m1, 1, nr, 1, nc );
  NR_free_matrix( m2, 1, nr, 1, nc );
  NR_free_vector( speq1, 1, twice_nr );
  NR_free_vector( speq2, 1, twice_nr );

  return( UT_OK );
d398 2
a399 2
int slow_full_conv_vector( float *a, int n_a, float *b, int n_b, float *c, 
                           int n_c )
d404 1
a404 1
  fast_zero_vec( c, n_c );
d420 35
d467 2
a468 2
int slow_full_conv_matrix( float **a, int nr_a, int nc_a, float **b, int nr_b, 
                           int nc_b, float **c, int nr_c, int nc_c ) 
d473 1
a473 1
  fast_zero_mat( c, nr_c, nc_c );
d492 1
a492 1
  return( UT_OK );
d501 3
a503 3
int slow_full_norm_conv_matrix( float **a, int nr_a, int nc_a, float **b, 
                                int nr_b, int nc_b, float **c, int nr_c, 
                                int nc_c )
d514 2
a515 2
  mean_a = mean_mat( a, nr_a, nc_a );
  mean_b = mean_mat( b, nr_b, nc_b );
d517 2
a518 2
  var_a = var_mat( a, nr_a, nc_a, mean_a );
  var_b = var_mat( b, nr_b, nc_b, mean_b );
d520 1
a520 1
  norm = (float) (sqrt( (double) var_a ) * sqrt( (double) var_b ));
d524 2
a525 2
  scalar_subtract_mat( a, nr_a, nc_a, mean_a );
  scalar_subtract_mat( b, nr_b, nc_b, mean_b );
d529 1
a529 1
  fast_zero_mat( c, nr_c, nc_c );
d550 1
a550 1
  scalar_div_mat( c, nr_c, nc_c, norm );
d554 2
a555 2
  scalar_add_mat( a, mean_a, nr_a, nc_a );
  scalar_add_mat( b, mean_b, nr_b, nc_b );
d557 1
a557 1
  return( UT_OK );
d567 2
a568 2
int slow_crop_conv_matrix( float **a, int nr_a, int nc_a, float **b, int nr_b, 
                           int nc_b, float **c, int nr_c, int nc_c )
d585 2
a586 2
  r_start = (int) floor( ((float) nr_diff) / 2.0 ) + 1;
  c_start = (int) floor( ((float) nc_diff) / 2.0 ) + 1;
d588 2
a589 2
  r_end = nr_full - (int) ceil( ((float) nr_diff) / 2.0 );
  c_end = nr_full - (int) ceil( ((float) nc_diff) / 2.0 );
d591 1
a591 1
  fast_zero_mat( c, nr_c, nc_c );
d621 1
a621 1
  return( UT_OK );
d630 2
a631 2
int slow_full_corr_vector( float *a, int n_a, float *b, int n_b, float *c, 
                           int n_c )
d633 1
a633 1
  flip_vector( a, n_a );
d635 1
a635 1
  slow_full_conv_vector( a, n_a, b, n_b, c, n_c );
d637 1
a637 1
  flip_vector( a, n_a );
d646 2
a647 2
int slow_full_corr_matrix( float **a, int nr_a, int nc_a, float **b, int nr_b,
                           int nc_b, float **c, int nr_c, int nc_c )
d649 2
a650 2
  flip_top_bottom_matrix( a, nr_a, nc_a );
  flip_left_right_matrix( a, nr_a, nc_a );
d652 1
a652 1
  slow_full_conv_matrix( a, nr_a, nc_a, b, nr_b, nc_b, c, nr_c, nc_c );
d654 2
a655 2
  flip_left_right_matrix( a, nr_a, nc_a );
  flip_top_bottom_matrix( a, nr_a, nc_a );
d657 1
a657 1
  return( UT_OK );
d667 2
a668 2
int slow_crop_corr_matrix( float **a, int nr_a, int nc_a, float **b, int nr_b,
                           int nc_b, float **c, int nr_c, int nc_c )
d670 2
a671 2
  flip_top_bottom_matrix( a, nr_a, nc_a );
  flip_left_right_matrix( a, nr_a, nc_a );
d673 1
a673 1
  slow_crop_conv_matrix( a, nr_a, nc_a, b, nr_b, nc_b, c, nr_c, nc_c );
d675 2
a676 2
  flip_left_right_matrix( a, nr_a, nc_a );
  flip_top_bottom_matrix( a, nr_a, nc_a );
d678 1
a678 1
  return( UT_OK );
d687 3
a689 3
int slow_full_norm_corr_matrix( float **a, int nr_a, int nc_a, float **b,
                                int nr_b, int nc_b, float **c, int nr_c, 
                                int nc_c )
d691 2
a692 2
  flip_top_bottom_matrix( a, nr_a, nc_a );
  flip_left_right_matrix( a, nr_a, nc_a );
d694 1
a694 1
  slow_full_norm_conv_matrix( a, nr_a, nc_a, b, nr_b, nc_b, c, nr_c, nc_c );
d696 2
a697 2
  flip_left_right_matrix( a, nr_a, nc_a );
  flip_top_bottom_matrix( a, nr_a, nc_a );
d699 1
a699 1
  return( UT_OK );
@


1.14
log
@filled out conv/corr functions, cosmetic changes
@
text
@d29 1
a29 1
static char rcsid[] = "$Id: da_signal.c,v 1.13 1997/06/05 18:56:51 granat Exp granat $";
d35 3
d468 6
a473 4
SLOW_FULL_CORR_VECTOR
Perform a 1D correlation of two vectors of length N and M, and return the 
result in a vector of size (N+M-1).  No tricks are used to make the computation 
faster, but there are no approximations made.
d475 1
a475 1
int slow_full_corr_vector( float *a, int n_a, float *b, int n_b, float *c, 
d485 8
a492 6
    p_b = &b[1];
    p_c = &c[i];
    for (j = 1; j <= n_b; j++) {
      *p_c += (*p_a) * (*p_b);
      p_b++;
      p_c++;
d501 11
a511 8
SLOW_FULL_CORR_MATRIX
Perform a 2D correlation of two matrices with dimensions NxM and UxV, and
return the result in a matrix of size (N+U-1)x(M+V-1).  No tricks are used 
to make the computation faster, but there are no approximations made.
*******************************************************************************/
int slow_full_corr_matrix( float **a, int nr_a, int nc_a, float **b, int nr_b, 
                           int nc_b, float **c, int nr_c, int nc_c )
{
d520 9
a528 7
      p_b = &b[1][1];
      for (k = 1; k <= nr_b; k++) {
        p_c = &c[i+k-1][j];
        for (l = 1; l <= nc_b; l++) {
          *p_c += (*p_a) * (*p_b);
          p_b++;
          p_c++;
d538 4
a541 4
SLOW_FULL_NORM_CORR_MATRIX
Perform a 2D correlation of two matrices with dimensions NxM and UxV, and
return the normalized result in a matrix of size (N+U-1)x(M+V-1).  No tricks 
are used to make the computation faster, but there are no approximations made.
d543 1
a543 1
int slow_full_norm_corr_matrix( float **a, int nr_a, int nc_a, float **b, 
d576 9
a584 7
      p_b = &b[1][1];
      for (k = 1; k <= nr_b; k++) {
        p_c = &c[i+k-1][j];
        for (l = 1; l <= nc_b; l++) {
          *p_c += (*p_a) * (*p_b);
          p_b++;
          p_c++;
d604 2
a605 2
SLOW_CROP_CORR_MATRIX
Perform a 2D correlation of two matrices with dimensions NxM and UxV, and
d607 1
a607 2
T < (N + U - 1) and S < (M + V - 1).  No tricks are used to make the 
computation faster, but there are no approximations made.
d609 1
a609 1
int slow_crop_corr_matrix( float **a, int nr_a, int nc_a, float **b, int nr_b, 
d640 16
a655 13
          if (j > c_start)
            col = j - c_start;
          else
            col = 1;
          for (k = 1, row = i - r_start + 1, full_row = i; \
               full_row <= r_end; k++, row++, full_row++)
            if (row >= 1) {
              p_b = &b[k][1];
              p_c = &c[row][col];
              for (l = 1, full_col = j; full_col <= c_end; l++, full_col++) {
                if (full_col >= c_start) {
                  *p_c += (*p_a) * (*p_b);
                  p_c++;
a656 1
                p_b++;
d658 1
a658 1
            }
d667 1
a667 1
SLOW_FULL_CONV_VECTOR
d672 1
a672 1
int slow_full_conv_vector( float *a, int n_a, float *b, int n_b, float *c, 
d677 1
a677 1
  slow_full_corr_vector( a, n_a, b, n_b, c, n_c );
d683 2
a684 2
SLOW_FULL_CONV_MATRIX
Perform a 2D convolution of two matrices with dimensions NxM and UxV, and
d688 1
a688 1
int slow_full_conv_matrix( float **a, int nr_a, int nc_a, float **b, int nr_b,
d694 1
a694 1
  slow_full_corr_matrix( a, nr_a, nc_a, b, nr_b, nc_b, c, nr_c, nc_c );
d703 1
a703 1
SLOW_CROP_CONV_MATRIX
d709 1
a709 1
int slow_crop_conv_matrix( float **a, int nr_a, int nc_a, float **b, int nr_b,
d715 1
a715 1
  slow_crop_corr_matrix( a, nr_a, nc_a, b, nr_b, nc_b, c, nr_c, nc_c );
d724 2
a725 2
SLOW_FULL_NORM_CONV_MATRIX
Perform a 2D convolution of two matrices with dimensions NxM and UxV, and
d729 1
a729 1
int slow_full_norm_conv_matrix( float **a, int nr_a, int nc_a, float **b,
d736 1
a736 1
  slow_full_norm_corr_matrix( a, nr_a, nc_a, b, nr_b, nc_b, c, nr_c, nc_c );
@


1.13
log
@added slow_full_conv_vector
@
text
@d29 1
a29 1
static char rcsid[] = "$Id: da_signal.c,v 1.12 1997/06/02 15:53:55 granat Exp granat $";
d35 3
d396 1
a396 1
                           int nc_b, float **c )
d398 1
a398 1
  int   nr, nc, nr_c, nc_c;
a403 3
  nr_c = nr_a + nr_b - 1;
  nc_c = nc_a + nc_b - 1;

d470 2
a471 1
int slow_full_corr_vector( float *a, int n_a, float *b, int n_b, float *c )
a473 1
  int    n_c;
d476 1
a476 3
  n_c = n_a + n_b - 1;

  fast_zero_vec( n_c, c );
d500 1
a500 1
                           int nc_b, float **c )
a502 1
  int    nr_c, nc_c;
d505 1
a505 4
  nr_c = nr_a + nr_b - 1;
  nc_c = nc_a + nc_b - 1;

  fast_zero_mat( nr_c, nc_c, c );
d532 2
a533 1
                                int nr_b, int nc_b, float **c )
a535 1
  int    nr_c, nc_c;
a541 3
  nr_c = nr_a + nr_b - 1;
  nc_c = nc_a + nc_b - 1;
 
d559 1
a559 1
  fast_zero_mat( nr_c, nc_c, c );
d620 1
a620 1
  fast_zero_mat( nr_c, nc_c, c );
d657 2
a658 1
int slow_full_conv_vector( float *a, int n_a, float *b, int n_b, float *c )
d662 1
a662 1
  slow_full_corr_vector( a, n_a, b, n_b, c );
d674 1
a674 1
                           int nc_b, float **c )
d679 1
a679 1
  slow_full_corr_matrix( a, nr_a, nc_a, b, nr_b, nc_b, c );
d701 21
@


1.12
log
@changed to use new NR naming convention
@
text
@d29 1
a29 1
static char rcsid[] = "$Id: da_signal.c,v 1.11 1997/01/30 02:19:50 agray Exp granat $";
d35 3
d156 4
a159 3
 RANGE_UNNORMALIZE_COLS
 Restore a matrix of vectors reflecting data which have been normalized by the 
 range of values in each column.
d179 4
a182 3
 RANGE_UNNORMALIZE_COV_MATRIX
 Restore a covariance matrix derived from data which have been normalized by 
 the range of values in each column.
d199 4
a202 3
 RANGE_UNNORMALIZE_VECTOR
 Restore a vector reflecting data which have been normalized by the range of 
 values in each attribute (column, often).
d466 3
a468 3
Perform a 2D correlation of two matrices with dimensions NxM and UxV, and
return the result in a matrix of size (N+U-1)x(M+V-1).  No tricks are used 
to make the computation faster, but there are no approximations made.
d563 2
a564 2
  scalar_subtract_mat( nr_a, nc_a, a, mean_a );
  scalar_subtract_mat( nr_b, nc_b, b, mean_b );
d587 1
a587 1
  scalar_div_mat( nr_c, nc_c, c, norm );
d591 2
a592 2
  scalar_add_mat( nr_a, nc_a, a, mean_a );
  scalar_add_mat( nr_b, nc_b, b, mean_b );
d658 15
@


1.11
log
@fixed bugs in range_normalize/unnormalize_cols().
@
text
@d29 1
a29 1
static char rcsid[] = "$Id: da_signal.c,v 1.10 1997/01/29 22:01:53 agray Exp agray $";
d35 3
a86 1
#include "nrutil.h"
d89 3
d310 384
@


1.10
log
@reordered functions.
@
text
@d29 1
a29 1
static char rcsid[] = "$Id: da_signal.c,v 1.9 1997/01/29 21:49:28 agray Exp agray $";
d35 3
d133 2
a134 2
int range_normalize_cols(float **mat, float *minval, float *maxval, 
                         float *range, int numrows, int numcols)
d139 1
a139 17
  /* for each attribute, find the min and max */
  for (j=1; j<=numcols; j++)
    minval[j] = maxval[j] = mat[1][j];

  for (i=2; i<=numrows; i++)
    for (j=1; j<=numcols; j++)
    {
      if (mat[i][j] < minval[j])
        minval[j] = mat[i][j];
      if (mat[i][j] > maxval[j])
        maxval[j] = mat[i][j];
    }

  /* scale each attribute value by its range and translate by its minval */
  for (j=1; j<=numcols; j++)
    range[j] = maxval[j] - minval[j];
  
d152 2
a153 2
int range_unnormalize_cols(float **mat, int nr, int nc, float *range, 
                           float *minval)
d158 2
a159 1
  for (i=1; i<=nr; i++)
d161 1
a161 1
    for (j=1;j<=nc;j++)
@


1.9
log
@added range_of_cols(), changed range_normalize_cols().
@
text
@d29 1
a29 1
static char rcsid[] = "$Id: da_signal.c,v 1.8 1997/01/29 21:11:15 agray Exp agray $";
d35 3
d161 21
a211 21

  return (UT_OK);
}


/*******************************************************************************
 RANGE_UNNORMALIZE_COLS
 Restore a matrix of vectors reflecting data which have been normalized by the 
 range of values in each column.
*******************************************************************************/
int range_unnormalize_cols(float **mat, int nr, int nc, float *range, 
                           float *minval)

{
  int i,j;

  for (i=1; i<=nr; i++)
  {
    for (j=1;j<=nc;j++)
      mat[i][j] = mat[i][j] * range[j] + minval[j];
  }
@


1.8
log
@lots of source code formatting changes, some hacks to
range_normalize_cols(), changed ut lib. interface.
@
text
@d29 1
a29 1
static char rcsid[] = "$Id: da_signal.c,v 1.7 1996/10/31 02:19:54 agray Exp agray $";
d35 4
d86 1
a86 1
RANGE_NORMALIZE_COLS
d90 35
a124 3
Modifies the original matrix such that each value in each column is normalized
ized by the range of that column.  Thus, all entries in the matrix will end up
scaled from 0-1.
@


1.7
log
@renamed from "da_dist" to "da_signal";
changed .h and .c formats throughout library;
some reorganizing between modules;
added some functions from HMM project.
@
text
@d29 1
a29 1
static char rcsid[] = "$Id: da_signal.c,v 1.6 1996/09/13 01:14:56 agray Exp agray $";
d34 26
a59 20
 *$Log: da_signal.c,v $
 *Revision 1.6  1996/09/13 01:14:56  agray
 *change name and comments for normalize_data().
 *
 *Revision 1.5  1996/09/13 00:57:33  agray
 *cosmetic; reduced arguments of print_unnorm_cov_matrix().
 *
 *Revision 1.4  1996/08/28 20:17:52  agray
 *cosmetic.
 *
 *Revision 1.3  1996/07/19 17:57:30  agray
 *cosmetic, minor efficiency hack
 *
 *Revision 1.2  1996/07/11 18:00:18  agray
 *added print_unnorm_matrix(), print_unnorm_cov_matrix(), print_unnorm_row(),
 *print_unnorm_col().
 *
 *Revision 1.1  1996/05/06 23:21:57  agray
 *Initial revision
 *
d68 3
a71 1
#include "ut_string.h"
d91 3
a93 7
int range_normalize_cols(mat, minval, maxval, range, numrows, numcols)
    float **mat;
    float *minval;
    float *maxval;
    float *range;
    int numrows;
    int numcols;
d95 5
a99 1
    int i,j;
d101 1
a101 1
    /* for each attribute, find the min and max */
d103 12
a114 12
      minval[j] = maxval[j] = mat[1][j];

    for (i=2; i<=numrows; i++)
      for (j=1; j<=numcols; j++)
      {
        if (mat[i][j] < minval[j])
          minval[j] = mat[i][j];
        if (mat[i][j] > maxval[j])
          maxval[j] = mat[i][j];
      }

    /* scale each attribute value by its range and translate by its minval */
d116 1
a116 5
      range[j] = maxval[j] - minval[j];

    for (i=1; i<=numrows; i++)
      for (j=1; j<=numcols; j++)
        mat[i][j] = (mat[i][j] - minval[j]) / range[j];
d118 1
a118 1
    return (UT_OK);
@


1.6
log
@change name and comments for normalize_data().
@
text
@d2 2
d5 2
a6 11
  Title:     da_dist
  Author:    Alexander Gray
  Function:  Data analysis routines, Numerical Recipes style.
             This file contains general distance concepts, which are useful
             for algorithms which compute the nearness of two data vectors.
             For example, evaluation of the multivariate Gaussian requires the 
             computation of the Euclidean distance between the new point x and 
             the mean m of the distribution.
  Reference: -
  How used:  First use - in ~/unsup/kmeans/kmeans.c.
  Notes:     - 
d8 19
d29 1
a29 1
static char rcsid[] = "$Id: da_dist.c,v 1.5 1996/09/13 00:57:33 agray Exp agray $";
d31 2
d34 4
a37 1
 *$Log: da_dist.c,v $
d56 1
d61 1
d65 1
d69 2
a70 1
#include "da_dist.h"
d74 8
a81 28
 EUCLID_DIST
 Compute the Euclidean distance from one vector to another
*******************************************************************************/
float euclid_dist(v1,v2,length)
    float *v1, *v2;
    int length;
{
    int i;
    float dist = 0, diff;

    for (i=1;i<=length;i++)
    {
      diff = v1[i] - v2[i];
      dist += diff * diff;
    }

    return (dist);
}


/*******************************************************************************
 RANGE_NORMALIZE_COLS
 For each of k columns in a matrix, find the minimum and maximum values, and
 the range (difference between the two).  Pass in a size k vector for each of 
 these latter sets of values, and they will be filled in by this function.  
 Modifies the original matrix such that each value in each column is normalized
 ized by the range of that column.  Thus, all entries in the matrix will end up
 scaled from 0-1.
d118 3
a120 3
 PRINT_UNNORM_MATRIX
 Print matrix of vectors which have been normalized by the range of values in
 each column, in unnormalized form.
d122 58
d202 4
a205 3
 PRINT_UNNORM_COV_MATRIX
 Print covariance matrix which has been normalized by the range of values in
 each row/column, in unnormalized form.
d228 4
a231 3
 PRINT_UNNORM_ROW
 Print vector which has been normalized by the range of values in each 
 column, in unnormalized form.  Prints in row form.
d253 4
a256 3
 PRINT_UNNORM_COL
 Print vector which has been normalized by the range of values in each 
 row, in unnormalized form.  Prints in column form.
@


1.5
log
@cosmetic; reduced arguments of print_unnorm_cov_matrix().
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: da_dist.c,v 1.4 1996/08/28 20:17:52 agray Exp agray $";
d21 3
d74 6
a79 6
 NORMALIZE_DATA
 For each of k attributes in a matrix of data, find the minimum and maximum 
 values, and the range (difference between the two).  Pass in a size k vector
 for each of these, and they will be filled in by this function.  Also modifies
 the original data matrix such that each value in the dataset is normalized by
 the range, for each attribute.  Thus, all entries in the data matrix will 
d82 2
a83 2
int normalize_data(data, minval, maxval, range, numrows, numcols)
    float **data;
d94 1
a94 1
      minval[j] = maxval[j] = data[1][j];
d99 4
a102 4
        if (data[i][j] < minval[j])
          minval[j] = data[i][j];
        if (data[i][j] > maxval[j])
          maxval[j] = data[i][j];
d111 1
a111 1
        data[i][j] = (data[i][j] - minval[j]) / range[j];
@


1.4
log
@cosmetic.
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: da_dist.c,v 1.3 1996/07/19 17:57:30 agray Exp agray $";
d21 3
d116 1
a116 1
 each attribute, in unnormalized form.
d128 3
a130 2
  for (i=1; i<=nr; i++) {
    for (j=1;j<=nc;j++) {
a131 1
    }
d142 1
a142 1
 each attribute, in unnormalized form.
d144 1
a144 1
int print_unnorm_cov_matrix(stream, nr, nc, mat, range)
d147 1
a147 1
  int    nr, nc;  /* number of rows, columns of input matrix */
d153 1
a153 1
  for (i=1; i<=nr; i++) {
d167 1
a167 1
 attribute, in unnormalized form.  Prints in row form.
d191 1
a191 1
 attribute, in unnormalized form.  Prints in column form.
d203 2
a204 3
  for (i = 1; i <= nc; i++) {
      fprintf(stream, "%g\n", v[i] * range[i] + minval[i]);
  }
@


1.3
log
@cosmetic, minor efficiency hack
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: da_dist.c,v 1.2 1996/07/11 18:00:18 agray Exp agray $";
d21 3
d36 1
d39 1
d42 1
@


1.2
log
@added print_unnorm_matrix(), print_unnorm_cov_matrix(), print_unnorm_row(),
print_unnorm_col().
@
text
@a12 3

  Compile:   make
  Example:   -
d17 1
a17 1
static char rcsid[] = "$Id: da_dist.c,v 1.1 1996/05/06 23:21:57 agray Exp agray $";
d21 4
d84 1
a84 1
    for (i=1; i<=numrows; i++)
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char rcsid[] = "$Id$";
d23 4
a26 1
 *$Log$
d102 98
@

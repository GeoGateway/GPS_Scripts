head	1.44;
access;
symbols
	Initial:1.1;
locks
	granat:1.44; strict;
comment	@ * @;


1.44
date	2001.01.02.18.45.53;	author granat;	state Exp;
branches;
next	1.43;

1.43
date	2000.04.04.23.40.06;	author granat;	state Exp;
branches;
next	1.42;

1.42
date	98.07.02.01.15.29;	author granat;	state Exp;
branches;
next	1.41;

1.41
date	98.06.29.22.11.24;	author granat;	state Exp;
branches;
next	1.40;

1.40
date	98.05.07.23.56.43;	author granat;	state Exp;
branches;
next	1.39;

1.39
date	98.05.01.17.37.03;	author granat;	state Exp;
branches;
next	1.38;

1.38
date	97.10.21.14.32.23;	author granat;	state Exp;
branches;
next	1.37;

1.37
date	97.09.10.14.50.22;	author granat;	state Exp;
branches;
next	1.36;

1.36
date	97.09.04.20.21.59;	author granat;	state Exp;
branches;
next	1.35;

1.35
date	97.08.11.18.31.19;	author granat;	state Exp;
branches;
next	1.34;

1.34
date	97.06.20.22.09.41;	author granat;	state Exp;
branches;
next	1.33;

1.33
date	97.06.05.18.53.57;	author granat;	state Exp;
branches;
next	1.32;

1.32
date	97.06.02.15.37.02;	author granat;	state Exp;
branches;
next	1.31;

1.31
date	97.05.06.22.23.05;	author agray;	state Exp;
branches;
next	1.30;

1.30
date	97.05.06.19.04.15;	author granat;	state Exp;
branches;
next	1.29;

1.29
date	97.04.05.19.09.34;	author granat;	state Exp;
branches;
next	1.28;

1.28
date	97.04.04.23.09.12;	author granat;	state Exp;
branches;
next	1.27;

1.27
date	97.04.04.19.00.30;	author granat;	state Exp;
branches;
next	1.26;

1.26
date	97.03.27.18.09.48;	author granat;	state Exp;
branches;
next	1.25;

1.25
date	97.03.15.17.50.49;	author granat;	state Exp;
branches;
next	1.24;

1.24
date	97.03.14.19.26.06;	author agray;	state Exp;
branches;
next	1.23;

1.23
date	97.02.18.22.25.15;	author granat;	state Exp;
branches;
next	1.22;

1.22
date	97.02.14.15.00.37;	author granat;	state Exp;
branches;
next	1.21;

1.21
date	97.02.14.00.25.15;	author granat;	state Exp;
branches;
next	1.20;

1.20
date	97.02.14.00.06.59;	author granat;	state Exp;
branches;
next	1.19;

1.19
date	97.02.14.00.01.25;	author granat;	state Exp;
branches;
next	1.18;

1.18
date	97.01.29.21.45.45;	author agray;	state Exp;
branches;
next	1.17;

1.17
date	96.10.31.02.16.35;	author agray;	state Exp;
branches;
next	1.16;

1.16
date	96.09.24.17.54.42;	author agray;	state Exp;
branches;
next	1.15;

1.15
date	96.07.30.23.17.30;	author agray;	state Exp;
branches;
next	1.14;

1.14
date	96.07.17.20.43.37;	author agray;	state Exp;
branches;
next	1.13;

1.13
date	96.07.13.01.07.59;	author agray;	state Exp;
branches;
next	1.12;

1.12
date	96.07.11.18.03.45;	author agray;	state Exp;
branches;
next	1.11;

1.11
date	96.04.09.02.49.36;	author agray;	state Exp;
branches;
next	1.10;

1.10
date	96.03.01.00.22.16;	author agray;	state Exp;
branches;
next	1.9;

1.9
date	96.02.29.02.33.32;	author agray;	state Exp;
branches;
next	1.8;

1.8
date	96.02.29.00.54.12;	author agray;	state Exp;
branches;
next	1.7;

1.7
date	96.02.28.03.57.52;	author agray;	state Exp;
branches;
next	1.6;

1.6
date	96.02.21.05.16.23;	author agray;	state Exp;
branches;
next	1.5;

1.5
date	96.02.21.04.08.46;	author agray;	state Exp;
branches;
next	1.4;

1.4
date	96.02.21.04.02.21;	author agray;	state Exp;
branches;
next	1.3;

1.3
date	96.02.21.03.51.36;	author agray;	state Exp;
branches;
next	1.2;

1.2
date	96.02.21.00.37.20;	author agray;	state Exp;
branches;
next	1.1;

1.1
date	96.02.06.03.27.47;	author agray;	state Exp;
branches;
next	;


desc
@Linear algebra convenience functions.
AG
@


1.44
log
@check-in before major revision transfered from laptop
@
text
@/*******************************************************************************
MODULE NAME
da_linalg

ONE-LINE SYNOPSIS
General functions related to linear algebra.

SCOPE OF THIS MODULE
Any functions relating directly to other linear algebra concepts which have 
representative modules in this library should go in the appropriate module.  
Functions that apply more generally are intended to go here.  For instance,
generating a matrix of random numbers is more directly related to random
numbers than to matrix operations, so it belongs in da_random.

SEE ALSO
Because the definition of this module is quite broad, there is some potential
overlap with several other modules in this library.

REFERENCE(S)
-

PROGRAM EXAMPLE(S)
1. /proj/cooltools/pca, AG.

NOTES
-

AG
*******************************************************************************/
#ifndef lint
static char rcsid[] = "$Id: da_linalg.c,v 1.43 2000/04/04 23:40:06 granat Exp granat $";
#endif
/* This string variable allows the RCS identification info to be printed. */

/* 
 * $Log: da_linalg.c,v $
 * Revision 1.43  2000/04/04 23:40:06  granat
 * added Jacobi preconditioned version of inverse function
 *
 * Revision 1.42  1998/07/02 01:15:29  granat
 * added fast matrix multiply
 *
 * Revision 1.41  1998/06/29 22:11:24  granat
 * added LSQR method of Paige and Saunders
 *
 * Revision 1.40  1998/05/07 23:56:43  granat
 * moved many functions to da_util.c
 *
 * Revision 1.39  1998/05/01 17:37:03  granat
 * added versions of many functions to handle other data types
 * added many new functions
 * changed some function names to match convention
 * some minor reformatting changes
 * edited many functions to make them faster
 *
 * Revision 1.38  1997/10/21 14:32:23  granat
 * fixed some bugs
 * added versions for different data types of some functions
 * changed some argument orders to agree with new standard
 *
 * Revision 1.37  1997/09/10 14:50:22  granat
 * changed many functions to their faster versions, added more comments
 *
 * Revision 1.36  1997/09/04 20:21:59  granat
 * added variants of sum_mat
 * added fast_copy_mat_section and variants
 *
 * Revision 1.35  1997/08/11 18:31:19  granat
 * added set_imat
 *
 * Revision 1.34  1997/06/20 22:09:41  granat
 * fixed transpose memory handling, some penny optimization, some cosmetic changes
 *
 * Revision 1.33  1997/06/05 18:53:57  granat
 * added flip_vector, changed prototypes to match with conventions, some cosmetic changes
 *
 * Revision 1.32  1997/06/02 15:37:02  granat
 * changed to use new NR naming convention
 *
 * Revision 1.31  1997/05/06 22:23:05  agray
 * added some things from dp cooltool.
 *
 * Revision 1.30  1997/05/06 19:04:15  granat
 * added function copy_mat_section
 *
 * Revision 1.29  1997/04/05 19:09:34  granat
 * added sum_mat() and norm_sum_mat()
 * adjusted functions so that they all follow input parameter conventions
 *
 * Revision 1.28  1997/04/04 23:09:12  granat
 * changed many functions so that they use pointer arithmatic
 *
 * Revision 1.27  1997/04/04 19:00:30  granat
 * added comments to transpose_in_situ_ functions and flip_ functions
 *
 * Revision 1.26  1997/03/27 18:09:48  granat
 * added transpose_in_situ_alloc_matrix(), transpose_in_situ_sqr_matrix(),
 * flip_left_right_matrix(), flip_top_bottom_matrix()
 *
 * Revision 1.25  1997/03/15 17:50:49  granat
 * Added flip_left_right_matrix() and flip_top_bottom_matrix()
 *
 * Revision 1.24  1997/03/14 19:26:06  agray
 * fixed minor bug in set_of_sets_of_matrices().
 *
 * Revision 1.23  1997/02/18 22:25:15  granat
 * fixed subtle error in transpose
 *
 * Revision 1.22  1997/02/14 15:00:37  granat
 * fixed mistake in transpose_matrix
 *
 * Revision 1.21  1997/02/14 00:25:15  granat
 * fixed transpose function in pca
 *
 * Revision 1.20  1997/02/14 00:06:59  granat
 * fixed typo
 *
 * Revision 1.19  1997/02/14 00:01:25  granat
 * Changed transpose funtion to transpose_matrix
 * speeded up transpose algorithm
 * added transpose_imatrix to transpose matrices of integers
 *
 * Revision 1.18  1997/01/29 21:45:45  agray
 * new formatting, cleaning up debugging output using ut_output,
 * cleaning up memory allocation with ut_memory.
 *
 * Revision 1.17  1996/10/31 02:16:35  agray
 * changed .h and .c formats throughout library;
 * some reorganizing between modules;
 * added some functions from HMM project.
 *
 * Revision 1.16  1996/09/24 17:54:42  agray
 * changed svdcmp2() to da_svdcmp2().
 *
 * Revision 1.15  1996/07/30 23:17:30  agray
 * changed heuristic for number of iterations in pca().
 *
 * Revision 1.14  1996/07/17 20:43:37  agray
 * cosmetic.
 *
 * Revision 1.13  1996/07/13 01:07:59  agray
 * moved out print/write_row/col/irow/icol() to da_data module
 *
 * Revision 1.12  1996/07/11 18:03:45  agray
 * moved out read_gauss_parms(), write_gauss_parms() to da_prob module;
 * added add_mat(), subtract_mat(), invert_mat_copy(), det_copy(),
 * restrict_illcond_matrix(), scalar_mult/div/add/subtract_mat/vec(), set_mat(),
 * set_vec(), mult/div_vec_elt(), sum_vec(), max/min_vec(), arg_max/min_vec(),
 * copy_vec().
 *
 * Revision 1.11  1996/04/09 02:49:36  agray
 * added print_irow(), print_icol(), write_irow(), write_icol().
 * ag
 *
 * Revision 1.10  1996/03/01  00:22:16  agray
 * moved read_data() and write_data() to da_data module.
 * changed %f to %g in all format strings.
 * ag
 *
 * Revision 1.9  1996/02/29  02:33:32  agray
 * moved write_bin_matrix() and read_bin_matrix() to da_data module
 * ag
 *
 * Revision 1.8  1996/02/29 00:54:12  agray
 * changed pca() to call svdcmp2() instead of svdcmp(); added svdcmp2()
 * to NR lib. to make the number of svd iterations a controllable
 * parameter.
 * ag
 *
 * Revision 1.7  1996/02/28 03:57:52  agray
 * put in checks for all memory allocations
 * AG
 *
 * Revision 1.6  1996/02/21 05:16:23  agray
 * NR_free_matrix() in pca().
 * ag
 *
 * Revision 1.5  1996/02/21  04:08:46  agray
 * added nr.h inclusion
 * ag
 *
 * Revision 1.4  1996/02/21  04:02:21  agray
 * moved some general notes on coding conventions into the file conventions.txt
 * in the /doc directory.
 * ag
 *
 * Revision 1.3  1996/02/21  03:51:36  agray
 * added pca().
 * ag
 *
 * Revision 1.2  1996/02/21  00:37:20  agray
 * added write_bin_matrix() and read_bin_matrix()
 * ag
 *
 * Revision 1.1  1996/02/06  03:27:47  agray
 * Initial revision
 *
 * */

/* C library */
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <float.h>

/* UT library */
#include "ut_error.h"
#include "ut_math.h"
#include "ut_memory.h"
#include "ut_output.h"
#include "ut_string.h"
#include "ut_types.h"

/* NR library */
#include "nr.h"

/* DA library */
#include "da_util.h"
#include "da_nrhacks.h"

/* this module's header */
#include "da_linalg.h"


/*******************************************************************************
NORM_VEC
Returns the norm of a vector.
RG
*******************************************************************************/
float norm_vec(float *v, int n)
{
  float *p;
  float *p_end;
  float result = 0.0;

  /* assign pointer to last element */
  p_end = &v[n];

  /* accumulate square of the vector */
  for (p = &v[1]; p <= p_end; p++)
    result += NR_sqr(*p);

  return (sqrt((double) result));
}


/*******************************************************************************
NORM_DVEC
Returns the norm of a vector of doubles.
RG
*******************************************************************************/
double norm_dvec(double *v, int n)
{
  double *p;
  double *p_end;
  double result = 0.0;

  /* assign pointer to last element */
  p_end = &v[n];

  /* accumulate square of the vector */
  for (p = &v[1]; p <= p_end; p++)
    result += NR_sqr(*p);

  return (sqrt(result));
}


/*******************************************************************************
FROBENIUS_NORM_MAT
Returns the frobenius norm of a matrix.
RG
*******************************************************************************/
float frobenius_norm_mat(float **m, int nr, int nc)
{
  float *p;
  float *p_end;
  float result = 0.0;
  
  /* assign pointer to last element */
  p_end = &m[nr][nc];
  
  /* calculate the frobenius norm */
  for (p = &m[1][1]; p <= p_end; p++)
    result += NR_sqr(*p);
  
  return (sqrt(result));
}


/*******************************************************************************
FROBENIUS_NORM_DMAT
Returns the frobenius norm of a matrix.
RG
*******************************************************************************/
double frobenius_norm_dmat(double **m, int nr, int nc)
{
  double *p;
  double *p_end;
  double result = 0.0;
  
  /* assign pointer to last element */
  p_end = &m[nr][nc];
  
  /* calculate the frobenius norm */
  for (p = &m[1][1]; p <= p_end; p++)
    result += NR_sqr(*p);
  
  return (sqrt(result));
}


/*******************************************************************************
TRANSPOSE_MATRIX
Create the transpose of a matrix of floats in a separate matrix.
RG
*******************************************************************************/
int transpose_matrix(float **a, int nr, int nc, float **a_trans)
{
  float  *p;
  float  *p_trans, *p_end_trans;
  float  *p_col, *p_end_col;

  /* assign pointer to last element of transpose*/
  p_end_trans = &a_trans[nc][nr];
  
  /* assign pointer to last element of first transpose row */
  p_end_col = &a_trans[1][nr];

  /* start pointer at first element */
  p = &a[1][1];

  /* increment pointer to the original matrix element by element, but
     increment pointer to the transpose along each column */
  for (p_col = &a_trans[1][1]; p_col <= p_end_col; p_col++)
    for (p_trans = p_col; p_trans <= p_end_trans; p_trans += nr, p++)
      *p_trans = *p;

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_DMATRIX
Create the transpose of a matrix of doubles in a separate matrix.
RG
*******************************************************************************/
int transpose_dmatrix(double **a, int nr, int nc, double **a_trans)
{
  double  *p;
  double  *p_trans, *p_end_trans;
  double  *p_col, *p_end_col;

  /* assign pointer to last element of transpose*/
  p_end_trans = &a_trans[nc][nr];
  
  /* assign pointer to last element of first transpose row */
  p_end_col = &a_trans[1][nr];

  /* start pointer at first element */
  p = &a[1][1];

  /* increment pointer to the original matrix element by element, but
     increment pointer to the transpose along each column */
  for (p_col = &a_trans[1][1]; p_col <= p_end_col; p_col++)
    for (p_trans = p_col; p_trans <= p_end_trans; p_trans += nr, p++)
      *p_trans = *p;

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IMATRIX
Create the transpose of a matrix of doubles in a separate matrix.
RG
*******************************************************************************/
int transpose_imatrix(int **a, int nr, int nc, int **a_trans)
{
  int     *p;
  int     *p_trans, *p_end_trans;
  int     *p_col, *p_end_col;

  /* assign pointer to last element of transpose*/
  p_end_trans = &a_trans[nc][nr];
  
  /* assign pointer to last element of first transpose row */
  p_end_col = &a_trans[1][nr];

  /* start pointer at first element */
  p = &a[1][1];

  /* increment pointer to the original matrix element by element, but
     increment pointer to the transpose along each column */
  for (p_col = &a_trans[1][1]; p_col <= p_end_col; p_col++)
    for (p_trans = p_col; p_trans <= p_end_trans; p_trans += nr, p++)
      *p_trans = *p;

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_CMATRIX
Create the transpose of a matrix of unsigned chars in a separate matrix.
RG
*******************************************************************************/
int transpose_cmatrix(unsigned char **a, int nr, int nc, unsigned char **a_trans)
{
  unsigned char  *p;
  unsigned char  *p_trans, *p_end_trans;
  unsigned char  *p_col, *p_end_col;

  /* assign pointer to last element of transpose*/
  p_end_trans = &a_trans[nc][nr];
  
  /* assign pointer to last element of first transpose row */
  p_end_col = &a_trans[1][nr];

  /* start pointer at first element */
  p = &a[1][1];

  /* increment pointer to the original matrix element by element, but
     increment pointer to the transpose along each column */
  for (p_col = &a_trans[1][1]; p_col <= p_end_col; p_col++)
    for (p_trans = p_col; p_trans <= p_end_trans; p_trans += nr, p++)
      *p_trans = *p;

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_ALLOC_MATRIX
Create the transpose of a matrix of floats in the same memory space as the
original matrix.  Takes as one of its arguments a vector for temporary
storage space, which must be of length at least equal to the number of rows
in the input matrix.  Allocation and deallocation may be required to maintain
the appropriate matrix data structure.
RG
*******************************************************************************/
int transpose_in_situ_alloc_matrix(float ***a, int nr, int nc, float *temp_vect,
                                   char *mem_choice)
{
  int     i, j, k;   
  float  *p;          /* pointer into the input matrix */
  float  *p_temp;     /* pointer into temporary values */
  float **m;          /* pointer to new vector of pointers to rows */
  int     skip;
  int     nr_less1;
  int     nc_less1;

  /****
   * Algorithm outline:
   * For each row in the transpose, skip through the matrix, picking out
   * the appropriate element of each column, and copy them into temporary
   * storage.  Then compress the remain parts of the untransposed matrix
   * to fill in the gaps, leaving a space in memory.  In the space created 
   * copy the stored elements, thus creating a new row.
   ****/

  p = &(*a)[1][1];

  nr_less1 = nr-1;
  nc_less1 = nc-1;

  skip = nc;

  /* extract columns and compose into rows */

  for (i = 1; i <= nc_less1; i++) {
    p_temp = &temp_vect[1]; /* p_temp points into the temporary storage */

    /* move p along so the it points to every "skip"th element */
    /* (ie, the values in a column) and copy the values into the */
    /* temporary storage */

    for (j = 1; j <= nr; j++) {
      *p_temp = *p;
      p += skip;
      p_temp++;
    }

    /* move the pointer back into the array */

    p -= skip;

    /* account for effective smaller column size now that an element 
       is removed */

    skip--;

    /* pack the remaining untransposed data into the last part of memory */
    /* this leaves space in memory in front of the packed data */

    for (j = 1; j <= nr_less1; j++)
      for (k = 1; k <= skip; k++) {
        *p = *(p-j);
        p--;
      }

    /* set pointer back to the beginning of the new space */

    p -= nr_less1;
    p_temp = &temp_vect[1];

    /* copy the stored elements into the new space */

    for (j = 1; j <= nr; j++) {
      *p = *p_temp;
      p++;
      p_temp++;
    }
  }

  /* make necessary changes to new pointer scheme */

  if (!strcmp(mem_choice, "realloc") && (nr != nc)) {

    /* allocate more memory and reassign pointers */
 
    m=(float **) malloc((size_t) ((nc+NR_END)*sizeof(float*)));
    if (!m)
      NR_error("allocation failure 1 in NR_matrix()");
    m += NR_END;
    m--;

    m[1] = (*a)[1];
    for(i = 2; i <= nc; i++)
      m[i] = m[i-1]+nr;

    free(*a);

    *a = m;
  }
  else
    if (nr > nc) { 

      /* reassign pointers and free excess memory */

      for (i = 2; i <= nc; i++)
        (*a)[i] = (*a)[i-1]+nr;
      free(&(*a)[i]);
    }
    else if (nc > nr) { 

      /* allocate more memory and reassign pointers */

      m=(float **) malloc((size_t) ((nc+NR_END)*sizeof(float*)));
      if (!m) 
        NR_error("allocation failure 1 in NR_matrix()");
      m += NR_END;
      m--;

      m[1] = (*a)[1];
      for(i = 2; i <= nc; i++)
        m[i] = m[i-1]+nr;

      free(*a);

      *a = m;
    }

  /* nothing needs to be done if nr = nc */

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_ALLOC_DMATRIX
Create the transpose of a matrix of doubles in the same memory space as the
original matrix.  Takes as one of its arguments a vector for temporary
storage space, which must be of length at least equal to the number of rows
in the input matrix.  Allocation and deallocation may be required to maintain
the appropriate matrix data structure.
RG
*******************************************************************************/
int transpose_in_situ_alloc_dmatrix(double ***a, int nr, int nc, 
		                    double *temp_vect, char *mem_choice)
{
  int      i, j, k;   
  double  *p;          /* pointer into the input matrix */
  double  *p_temp;     /* pointer into temporary values */
  double **m;          /* pointer to new vector of pointers to rows */
  int      skip;
  int      nr_less1;
  int      nc_less1;

  /****
   * Algorithm outline:
   * For each row in the transpose, skip through the matrix, picking out
   * the appropriate element of each column, and copy them into temporary
   * storage.  Then compress the remain parts of the untransposed matrix
   * to fill in the gaps, leaving a space in memory.  In the space created 
   * copy the stored elements, thus creating a new row.
   ****/

  p = &(*a)[1][1];

  nr_less1 = nr-1;
  nc_less1 = nc-1;

  skip = nc;

  /* extract columns and compose into rows */

  for (i = 1; i <= nc_less1; i++) {
    p_temp = &temp_vect[1]; /* p_temp points into the temporary storage */

    /* move p along so the it points to every "skip"th element */
    /* (ie, the values in a column) and copy the values into the */
    /* temporary storage */

    for (j = 1; j <= nr; j++) {
      *p_temp = *p;
      p += skip;
      p_temp++;
    }

    /* move the pointer back into the array */

    p -= skip;

    /* account for effective smaller column size now that an element 
       is removed */

    skip--;

    /* pack the remaining untransposed data into the last part of memory */
    /* this leaves space in memory in front of the packed data */

    for (j = 1; j <= nr_less1; j++)
      for (k = 1; k <= skip; k++) {
        *p = *(p-j);
        p--;
      }

    /* set pointer back to the beginning of the new space */

    p -= nr_less1;
    p_temp = &temp_vect[1];

    /* copy the stored elements into the new space */

    for (j = 1; j <= nr; j++) {
      *p = *p_temp;
      p++;
      p_temp++;
    }
  }

  /* make necessary changes to new pointer scheme */

  if (!strcmp(mem_choice, "realloc") && (nr != nc)) {

    /* allocate more memory and reassign pointers */
 
    m=(double **) malloc((size_t) ((nc+NR_END)*sizeof(double*)));
    if (!m)
      NR_error("allocation failure 1 in NR_matrix()");
    m += NR_END;
    m--;

    m[1] = (*a)[1];
    for(i = 2; i <= nc; i++)
      m[i] = m[i-1]+nr;

    free(*a);

    *a = m;
  }
  else
    if (nr > nc) { 

      /* reassign pointers and free excess memory */

      for (i = 2; i <= nc; i++)
        (*a)[i] = (*a)[i-1]+nr;
      free(&(*a)[i]);
    }
    else if (nc > nr) { 

      /* allocate more memory and reassign pointers */

      m=(double **) malloc((size_t) ((nc+NR_END)*sizeof(double*)));
      if (!m) 
        NR_error("allocation failure 1 in NR_matrix()");
      m += NR_END;
      m--;

      m[1] = (*a)[1];
      for(i = 2; i <= nc; i++)
        m[i] = m[i-1]+nr;

      free(*a);

      *a = m;
    }

  /* nothing needs to be done if nr = nc */

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_ALLOC_IMATRIX
Create the transpose of a matrix of integers in the same memory space as the
original matrix.  Takes as one of its arguments a vector for temporary
storage space, which must be of length at least equal to the number of rows
in the input matrix.  Allocation and deallocation may be required to maintain
the appropriate matrix data structure.
RG
*******************************************************************************/
int transpose_in_situ_alloc_imatrix(int ***a, int nr, int nc, int *temp_vect, 
                                    char *mem_choice)
{
  int   i, j, k;   
  int  *p;          /* pointer into the input matrix */
  int  *p_temp;     /* pointer into temporary values */
  int **m;          /* pointer to new vector of pointers to rows */
  int   skip;
  int   nr_less1;
  int   nc_less1;

  /****
   * Algorithm outline:
   * For each row in the transpose, skip through the matrix, picking out
   * the appropriate element of each column, and copy them into temporary
   * storage.  Then compress the remain parts of the untransposed matrix
   * to fill in the gaps, leaving a space in memory.  In the space created 
   * copy the stored elements, thus creating a new row.
   ****/

  p = &(*a)[1][1];

  nr_less1 = nr-1;
  nc_less1 = nc-1;

  skip = nc;

  /* extract columns and compose into rows */

  for (i = 1; i <= nc_less1; i++) {
    p_temp = &temp_vect[1]; /* p_temp points into the temporary storage */

    /* move p along so the it points to every "skip"th element */
    /* (ie, the values in a column) and copy the values into the */
    /* temporary storage */

    for (j = 1; j <= nr; j++) {
      *p_temp = *p;
      p += skip;
      p_temp++;
    }

    /* move the pointer back into the array */

    p -= skip;

    /* account for effective smaller column size now that an element 
       is removed */

    skip--;

    /* pack the remaining untransposed data into the last part of memory */
    /* this leaves space in memory in front of the packed data */

    for (j = 1; j <= nr_less1; j++)
      for (k = 1; k <= skip; k++) {
        *p = *(p-j);
        p--;
      }

    /* set pointer back to the beginning of the new space */

    p -= nr_less1;
    p_temp = &temp_vect[1];

    /* copy the stored elements into the new space */

    for (j = 1; j <= nr; j++) {
      *p = *p_temp;
      p++;
      p_temp++;
    }
  }

  /* make necessary changes to new pointer scheme */

  if (!strcmp(mem_choice, "realloc") && (nr != nc)) {

    /* allocate more memory and reassign pointers */
 
    m=(int **) malloc((size_t) ((nc+NR_END)*sizeof(int*)));
    if (!m)
      NR_error("allocation failure 1 in NR_matrix()");
    m += NR_END;
    m--;

    m[1] = (*a)[1];
    for(i = 2; i <= nc; i++)
      m[i] = m[i-1]+nr;

    free(*a);

    *a = m;
  }
  else
    if (nr > nc) { 

      /* reassign pointers and free excess memory */

      for (i = 2; i <= nc; i++)
        (*a)[i] = (*a)[i-1]+nr;
      free(&(*a)[i]);
    }
    else if (nc > nr) { 

      /* allocate more memory and reassign pointers */

      m=(int **) malloc((size_t) ((nc+NR_END)*sizeof(int*)));
      if (!m) 
        NR_error("allocation failure 1 in NR_matrix()");
      m += NR_END;
      m--;

      m[1] = (*a)[1];
      for(i = 2; i <= nc; i++)
        m[i] = m[i-1]+nr;

      free(*a);

      *a = m;
    }

  /* nothing needs to be done if nr = nc */

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_ALLOC_CMATRIX
Create the transpose of a matrix of unsigned chars in the same memory space as 
the original matrix.  Takes as one of its arguments a vector for temporary
storage space, which must be of length at least equal to the number of rows
in the input matrix.  Allocation and deallocation may be required to maintain
the appropriate matrix data structure.
RG
*******************************************************************************/
int transpose_in_situ_alloc_cmatrix(unsigned char ***a, int nr, int nc, 
		                    unsigned char *temp_vect, char *mem_choice)
{
  int             i, j, k;   
  unsigned char  *p;          /* pointer into the input matrix */
  unsigned char  *p_temp;     /* pointer into temporary values */
  unsigned char **m;          /* pointer to new vector of pointers to rows */
  int             skip;
  int             nr_less1;
  int             nc_less1;

  /****
   * Algorithm outline:
   * For each row in the transpose, skip through the matrix, picking out
   * the appropriate element of each column, and copy them into temporary
   * storage.  Then compress the remain parts of the untransposed matrix
   * to fill in the gaps, leaving a space in memory.  In the space created 
   * copy the stored elements, thus creating a new row.
   ****/

  p = &(*a)[1][1];

  nr_less1 = nr-1;
  nc_less1 = nc-1;

  skip = nc;

  /* extract columns and compose into rows */

  for (i = 1; i <= nc_less1; i++) {
    p_temp = &temp_vect[1]; /* p_temp points into the temporary storage */

    /* move p along so the it points to every "skip"th element */
    /* (ie, the values in a column) and copy the values into the */
    /* temporary storage */

    for (j = 1; j <= nr; j++) {
      *p_temp = *p;
      p += skip;
      p_temp++;
    }

    /* move the pointer back into the array */

    p -= skip;

    /* account for effective smaller column size now that an element 
       is removed */

    skip--;

    /* pack the remaining untransposed data into the last part of memory */
    /* this leaves space in memory in front of the packed data */

    for (j = 1; j <= nr_less1; j++)
      for (k = 1; k <= skip; k++) {
        *p = *(p-j);
        p--;
      }

    /* set pointer back to the beginning of the new space */

    p -= nr_less1;
    p_temp = &temp_vect[1];

    /* copy the stored elements into the new space */

    for (j = 1; j <= nr; j++) {
      *p = *p_temp;
      p++;
      p_temp++;
    }
  }

  /* make necessary changes to new pointer scheme */

  if (!strcmp(mem_choice, "realloc") && (nr != nc)) {

    /* allocate more memory and reassign pointers */
 
    m=(unsigned char **) malloc((size_t) ((nc+NR_END)*sizeof(unsigned char*)));
    if (!m)
      NR_error("allocation failure 1 in NR_matrix()");
    m += NR_END;
    m--;

    m[1] = (*a)[1];
    for(i = 2; i <= nc; i++)
      m[i] = m[i-1]+nr;

    free(*a);

    *a = m;
  }
  else
    if (nr > nc) { 

      /* reassign pointers and free excess memory */

      for (i = 2; i <= nc; i++)
        (*a)[i] = (*a)[i-1]+nr;
      free(&(*a)[i]);
    }
    else if (nc > nr) { 

      /* allocate more memory and reassign pointers */

      m=(unsigned char **) malloc((size_t) ((nc+NR_END)*sizeof(unsigned char*)));
      if (!m) 
        NR_error("allocation failure 1 in NR_matrix()");
      m += NR_END;
      m--;

      m[1] = (*a)[1];
      for(i = 2; i <= nc; i++)
        m[i] = m[i-1]+nr;

      free(*a);

      *a = m;
    }

  /* nothing needs to be done if nr = nc */

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_SQR_MATRIX
Create the transpose of a matrix of floats in the same memory space as the
original matrix.
RG
*******************************************************************************/
int transpose_in_situ_sqr_matrix(float **a, int n)
{
  int    i, j;
  float  *p_by_row, *p_by_col, *col_start, *row_start;
  float  temp;
 
  row_start = &a[1][1];
  col_start = &a[1][1];
 
  for (i = 1; i <= n; i++) {

    /* assign index pointers to the row and column being transposed */

    p_by_row = row_start;
    p_by_col = col_start;

    /* go through the row and column exchanging elements up to the diagonal */

    for (j = 1; j < i; j++) {

      /* switch the elements */

      temp = *p_by_row;
      *p_by_row = *p_by_col;
      *p_by_col = temp;

      p_by_row++; /* move to next element in the row */
      p_by_col += n; /* move to the next element in the column */
    }

    /* move pointers to the next row and column */

    row_start += n; /* move to the next row */
    col_start++; /* move to the next column */
  }
 
  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_SQR_DMATRIX
Create the transpose of a matrix of doubles in the same memory space as the
original matrix.
RG
*******************************************************************************/
int transpose_in_situ_sqr_dmatrix(double **a, int n)
{
  int      i, j;
  double  *p_by_row, *p_by_col, *col_start, *row_start;
  double   temp;
 
  row_start = &a[1][1];
  col_start = &a[1][1];
 
  for (i = 1; i <= n; i++) {

    /* assign index pointers to the row and column being transposed */

    p_by_row = row_start;
    p_by_col = col_start;

    /* go through the row and column exchanging elements up to the diagonal */

    for (j = 1; j < i; j++) {

      /* switch the elements */

      temp = *p_by_row;
      *p_by_row = *p_by_col;
      *p_by_col = temp;

      p_by_row++; /* move to next element in the row */
      p_by_col += n; /* move to the next element in the column */
    }

    /* move pointers to the next row and column */

    row_start += n; /* move to the next row */
    col_start++; /* move to the next column */
  }
 
  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_SQR_IMATRIX
Create the transpose of a matrix of integers in the same memory space as the
original matrix.
RG
*******************************************************************************/
int transpose_in_situ_sqr_imatrix(int **a, int n)
{
  int   i, j;
  int  *p_by_row, *p_by_col, *col_start, *row_start;
  int   temp;
 
  row_start = &a[1][1];
  col_start = &a[1][1];
 
  for (i = 1; i <= n; i++) {

    /* assign index pointers to the row and column being transposed */

    p_by_row = row_start;
    p_by_col = col_start;

    /* go through the row and column exchanging elements up to the diagonal */

    for (j = 1; j < i; j++) {

      /* switch the elements */

      temp = *p_by_row;
      *p_by_row = *p_by_col;
      *p_by_col = temp;

      p_by_row++; /* move to next element in the row */
      p_by_col += n; /* move to the next element in the column */
    }

    /* move pointers to the next row and column */

    row_start += n; /* move to the next row */
    col_start++; /* move to the next column */
  }
 
  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_SQR_CMATRIX
Create the transpose of a matrix of unsigned chars in the same memory space as 
the original matrix.
RG
*******************************************************************************/
int transpose_in_situ_sqr_cmatrix(unsigned char **a, int n)
{
  int             i, j;
  unsigned char  *p_by_row, *p_by_col, *col_start, *row_start;
  unsigned char   temp;
 
  row_start = &a[1][1];
  col_start = &a[1][1];
 
  for (i = 1; i <= n; i++) {

    /* assign index pointers to the row and column being transposed */

    p_by_row = row_start;
    p_by_col = col_start;

    /* go through the row and column exchanging elements up to the diagonal */

    for (j = 1; j < i; j++) {

      /* switch the elements */

      temp = *p_by_row;
      *p_by_row = *p_by_col;
      *p_by_col = temp;

      p_by_row++; /* move to next element in the row */
      p_by_col += n; /* move to the next element in the column */
    }

    /* move pointers to the next row and column */

    row_start += n; /* move to the next row */
    col_start++; /* move to the next column */
  }
 
  return (UT_OK);
}


/*******************************************************************************
INVERT_ALLOC_MAT
Invert a matrix.  
Destroys the original.  
Allocates some memory for use in the calculation.

Ref: Numerical Recipes 2e, p. 48.
AG
*******************************************************************************/
int invert_alloc_mat(float **mat, int n, float **inv)
{
  int i, j, *index;
  float d, *col;

  /* first check for singleton matrix case */
  if (n == 1) {
    inv[1][1] = 1.0/mat[1][1];
    return (UT_OK);
  }

  /* allocate temporary storage */
  col = NR_vector(1,n);
  if (col == (float*)NULL) {
    err_printf();
    log_printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }
  index = NR_ivector(1,n);
  if (index == (int*)NULL) {
    err_printf();
    log_printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }
  
  /* invert, using LU decomposition followed by backsubstitution */
  NR_ludcmp(mat,n,index,&d);
  for(j=1; j<=n; j++) {
    for (i=1; i<=n; i++)
      col[i] = 0.0;
    col[j] = 1.0;
    NR_lubksb(mat,n,index,col);
    for (i=1; i<=n; i++)
      inv[i][j] = col[i];
  }
  
  /* delete temporary storage */
  NR_free_vector(col, 1, n);
  NR_free_ivector(index, 1, n);
  
  return (UT_OK);
}


/*******************************************************************************
INVERT_ALLOC_DMAT
Invert a matrix.  
Destroys the original.  
Allocates some memory for use in the calculation.

Ref: Numerical Recipes 2e, p. 48.
AG
*******************************************************************************/
int invert_alloc_dmat(double **mat, int n, double **inv)
{
  int i, j, *index;
  double d, *col;

  /* first check for singleton matrix case */
  if (n == 1) {
    inv[1][1] = 1.0/mat[1][1];
    return (UT_OK);
  }

  /* allocate temporary storage */
  col = NR_dvector(1,n);
  if (col == (double*)NULL) {
    err_printf();
    log_printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }
  index = NR_ivector(1,n);
  if (index == (int*)NULL) {
    err_printf();
    log_printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }
  
  /* invert, using LU decomposition followed by backsubstitution */
  NR_dludcmp(mat,n,index,&d);
  for(j=1; j<=n; j++) {
    for (i=1; i<=n; i++)
      col[i] = 0.0;
    col[j] = 1.0;
    NR_dlubksb(mat,n,index,col);
    for (i=1; i<=n; i++)
      inv[i][j] = col[i];
  }
  
  /* delete temporary storage */
  NR_free_dvector(col, 1, n);
  NR_free_ivector(index, 1, n);
  
  return (UT_OK);
}


/*******************************************************************************
INVERT_COPY_ALLOC_MAT
Invert matrix copy.  
Like invert_mat(), but does not destroy the original; makes a copy first.
Allocates memory to hold a copy of the matrix.
AG
*******************************************************************************/
int invert_copy_alloc_mat(float **mat, int n, float **inv)
{
  float **mat_copy;

  /* make copy of matrix to be inverted */
  mat_copy = NR_matrix(1,n,1,n);
  copy_mat(mat, mat_copy, n, n);

  /* invert */
  invert_alloc_mat(mat_copy,n,inv);

  /* free the garbled matrix */
  NR_free_matrix(mat_copy,1,n,1,n);

  return (UT_OK);
}


/*******************************************************************************
INVERT_COPY_ALLOC_DMAT
Invert matrix copy.  
Like invert_mat(), but does not destroy the original; makes a copy first.
Allocates memory to hold a copy of the matrix.
AG
*******************************************************************************/
int invert_copy_alloc_dmat(double **mat, int n, double **inv)
{
  double **mat_copy;

  /* make copy of matrix to be inverted */
  mat_copy = NR_dmatrix(1,n,1,n);
  copy_dmat(mat, mat_copy, n, n);

  /* invert */
  invert_alloc_dmat(mat_copy,n,inv);

  /* free the garbled matrix */
  NR_free_dmatrix(mat_copy,1,n,1,n);

  return (UT_OK);
}


/*******************************************************************************
JACOBI_INVERT_COPY_ALLOC_DMAT
Invert matrix copy, using Jacobi preconditioning.  
Like invert_mat(), but does not destroy the original; makes a copy first.
Allocates memory to hold a copy of the matrix and store the preconditioner
values.
RG
*******************************************************************************/
int jacobi_invert_copy_alloc_dmat(double **mat, int n, double **inv)
{
  int    i, j;
  double *m;
  double **mat_copy;

  /* allocate storage for the preconditioner matrix */
  m = NR_dvector(1,n);

  /* make copy of matrix to be inverted */
  mat_copy = NR_dmatrix(1,n,1,n);
  copy_dmat(mat, mat_copy, n, n);

  /* precondition */
  for (i = 1; i <= n; i++) {
    m[i] = mat_copy[i][i];
    for (j = 1; j <= n; j++)
      mat_copy[i][j] /= m[i];
  }

  /* invert preconditioned matrix */
  invert_alloc_dmat(mat_copy,n,inv);

  /* recover the inverse */
  for (i = 1; i <= n; i++)
    for (j = 1; j <= n; j++)
      inv[i][j] /= m[j];

  /* free the garbled matrix */
  NR_free_dmatrix(mat_copy,1,n,1,n);

  /* free the preconditioner */
  NR_free_dvector(m, 1, n);

  return (UT_OK);
}


/*******************************************************************************
DET_ALLOC_MAT
Determinant of a matrix.
Destroys the original.  
Allocates memory for use in the computation.
Ref: Numerical Recipes 2e, p. 49.
AG
*******************************************************************************/
float det_alloc_mat(float **mat, int n)
{
  int   j;
  int  *index;
  float d;

  /* allocate temporary storage */
  index = NR_ivector(1,n);
  if (index == (int*)NULL) {
    err_printf();
    log_printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }
  
  /* use a side-effect of LU decomposition, which returns d as +1 or -1 */
  NR_ludcmp(mat,n,index,&d);

  /* the determinant of an LU decomposed matrix is the product of the diagonal
     elements */
  for (j=1; j<=n; j++)
    d *= mat[j][j];
  
  /* free temporary storage */
  NR_free_ivector(index, 1, n);

  return (d);
}


/*******************************************************************************
DET_ALLOC_DMAT
Determinant of a matrix.
Destroys the original.  
Allocates memory for use in the computation.
Ref: Numerical Recipes 2e, p. 49.
AG
*******************************************************************************/
double det_alloc_dmat(double **mat, int n)
{
  int   j;
  int  *index;
  double d;

  /* allocate temporary storage */
  index = NR_ivector(1,n);
  if (index == (int*)NULL) {
    err_printf();
    log_printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }
  
  /* use a side-effect of LU decomposition, which returns d as +1 or -1 */
  NR_dludcmp(mat,n,index,&d);

  /* the determinant of an LU decomposed matrix is the product of the diagonal
     elements */
  for (j=1; j<=n; j++)
    d *= mat[j][j];
  
  /* free temporary storage */
  NR_free_ivector(index, 1, n);

  return (d);
}


/*******************************************************************************
DET_COPY_ALLOC_MAT
Determinant of matrix copy.
Like det(), but does not destroy the original; makes a copy first.
Allocates memory to hold the copy.
AG
*******************************************************************************/
float det_copy_alloc_mat(float **mat, int n)
{
  float **mat_copy, d;
  
  /* make copy of matrix */
  mat_copy = NR_matrix(1,n,1,n);
  copy_mat(mat, mat_copy, n, n);

  /* find determinant */
  d = det_alloc_mat(mat_copy,n);

  /* free the garbled matrix */
  NR_free_matrix(mat_copy,1,n,1,n);

  return (d);
}


/*******************************************************************************
DET_COPY_ALLOC_DMAT
Determinant of matrix copy.
Like det(), but does not destroy the original; makes a copy first.
Allocates memory to hold the copy.
AG
*******************************************************************************/
double det_copy_alloc_dmat(double **mat, int n)
{
  double **mat_copy, d;
  
  /* make copy of matrix */
  mat_copy = NR_dmatrix(1,n,1,n);
  copy_dmat(mat, mat_copy, n, n);

  /* find determinant */
  d = det_alloc_dmat(mat_copy,n);

  /* free the garbled matrix */
  NR_free_dmatrix(mat_copy,1,n,1,n);

  return (d);
}


/*******************************************************************************
RESTRICT_ILLCOND_MATRIX
A hack procedure to restrict an ill-conditioned matrix such that it stays 
out of the realm of ill-conditioned matrices (hopefully), by ensuring that
the diagonal elements are above some small specified value.

mat is the input matrix.
dim is the size of the square matrix.
min_diag is the minimum value for a diagonal element of the matrix.
AG
*******************************************************************************/
int restrict_illcond_matrix(float **mat, int dim, float min_diag)
{
  int     i;

  /* NOTE: this should ideally compute the condition number of the matrix,
     and only do this if the condition number is less than some value */

  /* check each element of the diagonal */
  for (i = 1; i <= dim; i++) {
    if (mat[i][i] <= min_diag)
      mat[i][i] = min_diag;
  }

  return (UT_OK);
}


/*******************************************************************************
RESTRICT_ILLCOND_DMATRIX
A hack procedure to restrict an ill-conditioned matrix such that it stays 
out of the realm of ill-conditioned matrices (hopefully), by ensuring that
the diagonal elements are above some small specified value.

mat is the input matrix.
dim is the size of the square matrix.
min_diag is the minimum value for a diagonal element of the matrix.
AG
*******************************************************************************/
int restrict_illcond_dmatrix(double **mat, int dim, double min_diag)
{
  int     i;

  /* NOTE: this should ideally compute the condition number of the matrix,
     and only do this if the condition number is less than some value */

  /* check each element of the diagonal */
  for (i = 1; i <= dim; i++) {
    if (mat[i][i] <= min_diag)
      mat[i][i] = min_diag;
  }

  return (UT_OK);
}


/*******************************************************************************
EUCLID_DIST_VEC
Compute the Euclidean distance from one vector to another
RG
*******************************************************************************/
float euclid_dist_vec(float *v1, float *v2, int n)
{
  float *p1;
  float *p2;
  float *p1_end;
  float dist = 0.0;

  /* assign pointer to last element */
  p1_end = &v1[n];

  for (p1 = &v1[1], p2 = &v2[1]; p1 <= p1_end; p1++, p2++)
    dist += NR_sqr(*p1 - *p2);

  return (dist);
}


/*******************************************************************************
EUCLID_DIST_DVEC
Compute the Euclidean distance from one vector of doubles to another
RG
*******************************************************************************/
double euclid_dist_dvec(double *v1, double *v2, int n)
{
  double *p1;
  double *p2;
  double *p1_end;
  double dist = 0.0;

  /* assign pointer to last element */
  p1_end = &v1[n];

  for (p1 = &v1[1], p2 = &v2[1]; p1 <= p1_end; p1++, p2++)
    dist += NR_sqr(*p1 - *p2);

  return (dist);
}


/*******************************************************************************
RIGHT_MULT_MATRIX
Multiply a matrix by a vector on the right.
RG
*******************************************************************************/
int right_mult_matrix(float **m, int nr, int nc, float *v, float *result)
{
  float *p_m;
  float *p_v;
  float *p_result;
  float *p_end_v;
  float *p_end_result;
  
  /* initialize the result vector */
  fast_zero_vec(result, nr);
  
  /* assign pointers to last elements of u, result */
  p_end_v = &v[nc];
  p_end_result = &result[nr];
  
  /* assign pointer to first element of matrix */
  p_m = &m[1][1];
  
  /* perform the calculation */
  for (p_result = &result[1]; p_result <= p_end_result; p_result++)
    for (p_v = &v[1]; p_v <= p_end_v; p_v++) {
      *p_result += (*p_m) * (*p_v);
      p_m++;
    }

  return (UT_OK);
}


/*******************************************************************************
RIGHT_MULT_DMATRIX
Multiply a matrix of doubles by a vector of doubles on the right.
RG
*******************************************************************************/
int right_mult_dmatrix(double **m, int nr, int nc, double *v, double *result)
{
  double *p_m;
  double *p_v;
  double *p_result;
  double *p_end_v;
  double *p_end_result;
  
  /* initialize the result vector */
  fast_zero_dvec(result, nr);
  
  /* assign pointers to last elements of u, result */
  p_end_v = &v[nc];
  p_end_result = &result[nr];
  
  /* assign pointer to first element of matrix */
  p_m = &m[1][1];
  
  /* perform the calculation */
  for (p_result = &result[1]; p_result <= p_end_result; p_result++)
    for (p_v = &v[1]; p_v <= p_end_v; p_v++) {
      *p_result += (*p_m) * (*p_v);
      p_m++;
    }

  return (UT_OK);
}


/*******************************************************************************
LEFT_MULT_MATRIX
Multiply a matrix by a vector on the left.
RG
*******************************************************************************/
int left_mult_matrix(float **m, int nr, int nc, float *v, float *result)
{
  float *p_m;
  float *p_v;
  float *p_result;
  float *p_end_v;
  float *p_end_result;
  
  /* initialize the result vector */
  fast_zero_vec(result, nc);
  
  /* assign pointers to last elements of u, result */
  p_end_v = &v[nr];
  p_end_result = &result[nc];
  
  /* assign pointer to first element of matrix */
  p_m = &m[1][1];
  
  /* perform the calculation */
  for (p_v = &v[1]; p_v <= p_end_v; p_v++)
    for (p_result = &result[1]; p_result <= p_end_result; p_result++) {
      *p_result += (*p_m) * (*p_v);
      p_m++;
    }

  return (UT_OK);
}


/*******************************************************************************
LEFT_MULT_DMATRIX
Multiply a matrix of doubles by a vector of doubles on the left.
RG
*******************************************************************************/
int left_mult_dmatrix(double **m, int nr, int nc, double *v, double *result)
{
  double *p_m;
  double *p_v;
  double *p_result;
  double *p_end_v;
  double *p_end_result;
  
  /* initialize the result vector */
  fast_zero_dvec(result, nc);
  
  /* assign pointers to last elements of u, result */
  p_end_v = &v[nr];
  p_end_result = &result[nc];
  
  /* assign pointer to first element of matrix */
  p_m = &m[1][1];
  
  /* perform the calculation */
  for (p_v = &v[1]; p_v <= p_end_v; p_v++)
    for (p_result = &result[1]; p_result <= p_end_result; p_result++) {
      *p_result += (*p_m) * (*p_v);
      p_m++;
    }

  return (UT_OK);
}


/*******************************************************************************
MAT_MULT
Multiply two matrices.
AG
*******************************************************************************/
int mat_mult(float **a, int nra, int nca, float **b, int nrb, int ncb, 
             float **c)
{
  int    i, j, k;
  int    nrc, ncc;
  float *p_a;
  float *p_b;
  float *p_c;

  /* check for compatible dimensions */
  if (nca != nrb) {
    err_printf();
    log_printf("Matrix dimensions are incompatible\n");
    return (UT_ERROR);
  }

  nrc = nra;
  ncc = ncb;
 
  fast_zero_mat(c, nrc, ncc);

  p_c = &c[1][1];

  /* accumulate results */
  for (i = 1; i <= nrc; i++) {
    for (j = 1; j <= ncc; j++) {
      p_a = &a[i][1];
      p_b = &b[1][j];
      for (k = 1; k <= nca; k++) {
        *p_c += (*p_a) * (*p_b);
        p_a++;
        p_b += ncb;
      }
      p_c++;
    }
  }

  return (UT_OK);
}


/*******************************************************************************
DMAT_MULT
Multiply two matrices of doubles.
AG
*******************************************************************************/
int dmat_mult(double **a, int nra, int nca, double **b, int nrb, int ncb, 
              double **c)
{
  int    i, j, k;
  int    nrc, ncc;
  double *p_a;
  double *p_b;
  double *p_c;

  /* check for compatible dimensions */
  if (nca != nrb) {
    err_printf();
    log_printf("Matrix dimensions are incompatible\n");
    return (UT_ERROR);
  }

  nrc = nra;
  ncc = ncb;
 
  fast_zero_dmat(c, nrc, ncc);

  p_c = &c[1][1];

  /* accumulate results */
  for (i = 1; i <= nrc; i++) {
    for (j = 1; j <= ncc; j++) {
      p_a = &a[i][1];
      p_b = &b[1][j];
      for (k = 1; k <= nca; k++) {
        *p_c += (*p_a) * (*p_b);
        p_a++;
        p_b += ncb;
      }
      p_c++;
    }
  }

  return (UT_OK);
}


/*******************************************************************************
FAST_MAT_MULT
A more efficient routine for performing matrix multiplies.  Based off of code
originally written by Edward Keyes at M.I.T.  The general idea is to minimize
memory access by using the register variables as much as possible.  The
routine calculates a 4x4 block of answers each pass.  Note that the boundary
cases are not treated differently; answers are calculated with dummy values,
but just never stored (this leaves room for improvement).
RG
*******************************************************************************/
int fast_mat_mult(float **A, int nra, int nca, float **B, int nrb, int ncb, 
                  float **C)
{
  register float c00, c01, c02, c03;
  register float c10, c11, c12, c13;
  register float c20, c21, c22, c23;
  register float c30, c31, c32, c33;
  register float ax0, ax1, ax2, ax3;
  register float bx0, bx1, bx2, bx3;

  register float *baseC, *baseA, *baseB;
  register int   numr, numc, numi;
  register int   i, j, k;
  register int   border1, border2;
  register int   s1, s2, s3;
  register int   mod1, mod2, mod3;

  /* initialize the output array */
  fast_zero_mat(C, nra, ncb);

  /* round to next highest multiple of 4 */
  numr = (nra + 3) / 4;   
  numc = (ncb + 3) / 4;
  mod1 = nra % 4;
  mod2 = nca % 2;
  mod3 = ncb % 4;
  if (mod1 == 0) 
    mod1 = 4;
  if (mod3 == 0) 
    mod3 = 4;
  numi = nca / 2;
  s1 = nra; 
  s2 = nca; 
  s3 = ncb;
  i = 0;
  while (i < numr) { /*  loop over rows of C  */
    if (i == numr - 1)
      border1 = 1;
    else 
      border1 = 0;
    border2 = 0;
    j = 0;
    baseC = &C[1][1] + i * s3 * 4;
    while (j < numc) { /*  loop over columns of C  */
      if (j == numc - 1)
        border2 = 1;
      k = 0;
      baseA = &A[1][1] + i  *  4  *  s2;
      baseB = &B[1][1] + j  *  4;
       
      /*  increment early for the pipeline  */
      j++; 

      /*  copy registers */
      c00 = baseC[0];
      c01 = baseC[1];
      c02 = baseC[2];
      c03 = baseC[3];
      baseC += s3;
      c10 = baseC[0];
      c11 = baseC[1];
      c12 = baseC[2];
      c13 = baseC[3];
      baseC += s3;
      c20 = baseC[0];
      c21 = baseC[1];
      c22 = baseC[2];
      c23 = baseC[3];
      baseC += s3;
      c30 = baseC[0];
      c31 = baseC[1];
      c32 = baseC[2];
      c33 = baseC[3];
      while (k < numi) { /*  do the calculations  */
        k++;
        ax0 = baseA[0];
        ax1 = baseA[s2];
        ax2 = baseA[s2 + s2];
        ax3 = baseA[s2 + s2 + s2];
        bx0 = baseB[0];
        bx1 = baseB[1];
        bx2 = baseB[2];
        bx3 = baseB[3];
        baseA += 1;
        baseB += s3;
        c00 += ax0 * bx0;
        c01 += ax0 * bx1;
        c02 += ax0 * bx2;
        c03 += ax0 * bx3;
        c10 += ax1 * bx0;
        c11 += ax1 * bx1;
        c12 += ax1 * bx2;
        c13 += ax1 * bx3;
        c20 += ax2 * bx0;
        c21 += ax2 * bx1;
        c22 += ax2 * bx2;
        c23 += ax2 * bx3;
        c30 += ax3 * bx0;
        c31 += ax3 * bx1;
        c32 += ax3 * bx2;
        c33 += ax3 * bx3;
        ax0 = baseA[0];
        ax1 = baseA[s2];
        ax2 = baseA[s2+s2];
        ax3 = baseA[s2+s2+s2];
        bx0 = baseB[0];
        bx1 = baseB[1];
        bx2 = baseB[2];
        bx3 = baseB[3];
        baseA += 1;
        baseB += s3;
        c00 += ax0 * bx0;
        c01 += ax0 * bx1;
        c02 += ax0 * bx2;
        c03 += ax0 * bx3;
        c10 += ax1 * bx0;
        c11 += ax1 * bx1;
        c12 += ax1 * bx2;
        c13 += ax1 * bx3;
        c20 += ax2 * bx0;
        c21 += ax2 * bx1;
        c22 += ax2 * bx2;
        c23 += ax2 * bx3;
        c30 += ax3 * bx0;
        c31 += ax3 * bx1;
        c32 += ax3 * bx2;
        c33 += ax3 * bx3;
      }
      if (mod2 == 1) {
        ax0 = baseA[0];
        ax1 = baseA[s2];
        ax2 = baseA[s2 + s2];
        ax3 = baseA[s2 + s2+ s2];
        bx0 = baseB[0];
        bx1 = baseB[1];
        bx2 = baseB[2];
        bx3 = baseB[3];
        baseA += 1;
        baseB += s3;
        c00 += ax0 * bx0;
        c01 += ax0 * bx1;
        c02 += ax0 * bx2;
        c03 += ax0 * bx3;
        c10 += ax1 * bx0;
        c11 += ax1 * bx1;
        c12 += ax1 * bx2;
        c13 += ax1 * bx3;
        c20 += ax2 * bx0;
        c21 += ax2 * bx1;
        c22 += ax2 * bx2;
        c23 += ax2 * bx3;
        c30 += ax3 * bx0;
        c31 += ax3 * bx1;
        c32 += ax3 * bx2;
        c33 += ax3 * bx3;
      }
      if ((!(border1 + border2)) || (mod1 + mod3 == 8)) {
        baseC[0] = c30;
        baseC[1] = c31;
        baseC[2] = c32;
        baseC[3] = c33;
        baseC -= s3;
        baseC[0] = c20;
        baseC[1] = c21;
        baseC[2] = c22;
        baseC[3] = c23;
        baseC -= s3;
        baseC[0] = c10;
        baseC[1] = c11;
        baseC[2] = c12;
        baseC[3] = c13;
        baseC -= s3;
        baseC[0] = c00;
        baseC[1] = c01;
        baseC[2] = c02;
        baseC[3] = c03;
      }
      else if (border1 - border2 == 1) {
        if (mod1 > 3) {
          baseC[0] = c30;
          baseC[1] = c31;
          baseC[2] = c32;
          baseC[3] = c33;
        }
        baseC -= s3;
        if (mod1 > 2) {
          baseC[0] = c20;
          baseC[1] = c21;
          baseC[2] = c22;
          baseC[3] = c23;
        }
        baseC -= s3;
        if (mod1 > 1) {
          baseC[0] = c10;
          baseC[1] = c11;
          baseC[2] = c12;
          baseC[3] = c13;
        }
        baseC -= s3;
        baseC[0] = c00;
        baseC[1] = c01;
        baseC[2] = c02;
        baseC[3] = c03;
      }
      else if (border2 - border1 == 1) {
        baseC[0] = c30;
        if (mod3 > 1) 
	  baseC[1] = c31;
        if (mod3 > 2) 
	  baseC[2] = c32;
        if (mod3 > 3) 
	  baseC[3] = c33;
        baseC -= s3;
        baseC[0] = c20;
        if (mod3 > 1) 
	  baseC[1] = c21;
        if (mod3 > 2) 
	  baseC[2] = c22;
        if (mod3 > 3) 
	  baseC[3] = c23;
        baseC -= s3;
        baseC[0] = c10;
        if (mod3 > 1) 
	  baseC[1] = c11;
        if (mod3 > 2) 
	  baseC[2] = c12;
        if (mod3 > 3) 
	  baseC[3] = c13;
        baseC -= s3;
        baseC[0] = c00;
        if (mod3 > 1) 
	  baseC[1] = c01;
        if (mod3 > 2) 
          baseC[2] = c02;
        if (mod3 > 3) 
          baseC[3] = c03;
      }
      else if (border1 + border2 == 2) {
        if (mod1 > 3) {
          baseC[0] = c30;
          if (mod3 > 1) 
	    baseC[1] = c31;
          if (mod3 > 2) 
	    baseC[2] = c32;
          if (mod3 > 3) 
	    baseC[3] = c33;
        }
        baseC -= s3;
        if (mod1 > 2) {
          baseC[0] = c20;
          if (mod3 > 1) 
	    baseC[1] = c21;
          if (mod3 > 2) 
	    baseC[2] = c22;
          if (mod3 > 3) 
	    baseC[3] = c23;
        }
        baseC -= s3;
        if (mod1 > 1) {
          baseC[0] = c10;
          if (mod3 > 1) 
	    baseC[1] = c11;
          if (mod3 > 2) 
	    baseC[2] = c12;
          if (mod3 > 3) 
	    baseC[3] = c13;
        }
        baseC -= s3;
        baseC[0] = c00;
        if (mod3 > 1) 
	  baseC[1] = c01;
        if (mod3 > 2) 
	  baseC[2] = c02;
        if (mod3 > 3) 
	  baseC[3] = c03;
      }
      baseC += 4; /*  next group of results  */
    }
    i++;
  }
  
  return (UT_OK);
}


/*******************************************************************************
FAST_DMAT_MULT
A more efficient routine for performing matrix multiplies.  Based off of code
originally written by Edward Keyes at M.I.T.  The general idea is to minimize
memory access by using the register variables as much as possible.  The
routine calculates a 4x4 block of answers each pass.  Note that the boundary
cases are not treated differently; answers are calculated with dummy values,
but just never stored (this leaves room for improvement).
RG
*******************************************************************************/
int fast_dmat_mult(double **A, int nra, int nca, double **B, int nrb, int ncb, 
                   double **C)
{
  register double c00, c01, c02, c03;
  register double c10, c11, c12, c13;
  register double c20, c21, c22, c23;
  register double c30, c31, c32, c33;
  register double ax0, ax1, ax2, ax3;
  register double bx0, bx1, bx2, bx3;

  register double *baseC, *baseA, *baseB;
  register int   numr, numc, numi;
  register int   i, j, k;
  register int   border1, border2;
  register int   s1, s2, s3;
  register int   mod1, mod2, mod3;

  /* initialize the output array */
  fast_zero_dmat(C, nra, ncb);

  /* round to next highest multiple of 4 */
  numr = (nra + 3) / 4;   
  numc = (ncb + 3) / 4;
  mod1 = nra % 4;
  mod2 = nca % 2;
  mod3 = ncb % 4;
  if (mod1 == 0) 
    mod1 = 4;
  if (mod3 == 0) 
    mod3 = 4;
  numi = nca / 2;
  s1 = nra; 
  s2 = nca; 
  s3 = ncb;
  i = 0;
  while (i < numr) { /*  loop over rows of C  */
    if (i == numr - 1)
      border1 = 1;
    else 
      border1 = 0;
    border2 = 0;
    j = 0;
    baseC = &C[1][1] + i * s3 * 4;
    while (j < numc) { /*  loop over columns of C  */
      if (j == numc - 1)
        border2 = 1;
      k = 0;
      baseA = &A[1][1] + i  *  4  *  s2;
      baseB = &B[1][1] + j  *  4;
       
      /*  increment early for the pipeline  */
      j++; 

      /*  copy registers */
      c00 = baseC[0];
      c01 = baseC[1];
      c02 = baseC[2];
      c03 = baseC[3];
      baseC += s3;
      c10 = baseC[0];
      c11 = baseC[1];
      c12 = baseC[2];
      c13 = baseC[3];
      baseC += s3;
      c20 = baseC[0];
      c21 = baseC[1];
      c22 = baseC[2];
      c23 = baseC[3];
      baseC += s3;
      c30 = baseC[0];
      c31 = baseC[1];
      c32 = baseC[2];
      c33 = baseC[3];
      while (k < numi) { /*  do the calculations  */
        k++;
        ax0 = baseA[0];
        ax1 = baseA[s2];
        ax2 = baseA[s2 + s2];
        ax3 = baseA[s2 + s2 + s2];
        bx0 = baseB[0];
        bx1 = baseB[1];
        bx2 = baseB[2];
        bx3 = baseB[3];
        baseA += 1;
        baseB += s3;
        c00 += ax0 * bx0;
        c01 += ax0 * bx1;
        c02 += ax0 * bx2;
        c03 += ax0 * bx3;
        c10 += ax1 * bx0;
        c11 += ax1 * bx1;
        c12 += ax1 * bx2;
        c13 += ax1 * bx3;
        c20 += ax2 * bx0;
        c21 += ax2 * bx1;
        c22 += ax2 * bx2;
        c23 += ax2 * bx3;
        c30 += ax3 * bx0;
        c31 += ax3 * bx1;
        c32 += ax3 * bx2;
        c33 += ax3 * bx3;
        ax0 = baseA[0];
        ax1 = baseA[s2];
        ax2 = baseA[s2+s2];
        ax3 = baseA[s2+s2+s2];
        bx0 = baseB[0];
        bx1 = baseB[1];
        bx2 = baseB[2];
        bx3 = baseB[3];
        baseA += 1;
        baseB += s3;
        c00 += ax0 * bx0;
        c01 += ax0 * bx1;
        c02 += ax0 * bx2;
        c03 += ax0 * bx3;
        c10 += ax1 * bx0;
        c11 += ax1 * bx1;
        c12 += ax1 * bx2;
        c13 += ax1 * bx3;
        c20 += ax2 * bx0;
        c21 += ax2 * bx1;
        c22 += ax2 * bx2;
        c23 += ax2 * bx3;
        c30 += ax3 * bx0;
        c31 += ax3 * bx1;
        c32 += ax3 * bx2;
        c33 += ax3 * bx3;
      }
      if (mod2 == 1) {
        ax0 = baseA[0];
        ax1 = baseA[s2];
        ax2 = baseA[s2 + s2];
        ax3 = baseA[s2 + s2+ s2];
        bx0 = baseB[0];
        bx1 = baseB[1];
        bx2 = baseB[2];
        bx3 = baseB[3];
        baseA += 1;
        baseB += s3;
        c00 += ax0 * bx0;
        c01 += ax0 * bx1;
        c02 += ax0 * bx2;
        c03 += ax0 * bx3;
        c10 += ax1 * bx0;
        c11 += ax1 * bx1;
        c12 += ax1 * bx2;
        c13 += ax1 * bx3;
        c20 += ax2 * bx0;
        c21 += ax2 * bx1;
        c22 += ax2 * bx2;
        c23 += ax2 * bx3;
        c30 += ax3 * bx0;
        c31 += ax3 * bx1;
        c32 += ax3 * bx2;
        c33 += ax3 * bx3;
      }
      if ((!(border1 + border2)) || (mod1 + mod3 == 8)) {
        baseC[0] = c30;
        baseC[1] = c31;
        baseC[2] = c32;
        baseC[3] = c33;
        baseC -= s3;
        baseC[0] = c20;
        baseC[1] = c21;
        baseC[2] = c22;
        baseC[3] = c23;
        baseC -= s3;
        baseC[0] = c10;
        baseC[1] = c11;
        baseC[2] = c12;
        baseC[3] = c13;
        baseC -= s3;
        baseC[0] = c00;
        baseC[1] = c01;
        baseC[2] = c02;
        baseC[3] = c03;
      }
      else if (border1 - border2 == 1) {
        if (mod1 > 3) {
          baseC[0] = c30;
          baseC[1] = c31;
          baseC[2] = c32;
          baseC[3] = c33;
        }
        baseC -= s3;
        if (mod1 > 2) {
          baseC[0] = c20;
          baseC[1] = c21;
          baseC[2] = c22;
          baseC[3] = c23;
        }
        baseC -= s3;
        if (mod1 > 1) {
          baseC[0] = c10;
          baseC[1] = c11;
          baseC[2] = c12;
          baseC[3] = c13;
        }
        baseC -= s3;
        baseC[0] = c00;
        baseC[1] = c01;
        baseC[2] = c02;
        baseC[3] = c03;
      }
      else if (border2 - border1 == 1) {
        baseC[0] = c30;
        if (mod3 > 1) 
	  baseC[1] = c31;
        if (mod3 > 2) 
	  baseC[2] = c32;
        if (mod3 > 3) 
	  baseC[3] = c33;
        baseC -= s3;
        baseC[0] = c20;
        if (mod3 > 1) 
	  baseC[1] = c21;
        if (mod3 > 2) 
	  baseC[2] = c22;
        if (mod3 > 3) 
	  baseC[3] = c23;
        baseC -= s3;
        baseC[0] = c10;
        if (mod3 > 1) 
	  baseC[1] = c11;
        if (mod3 > 2) 
	  baseC[2] = c12;
        if (mod3 > 3) 
	  baseC[3] = c13;
        baseC -= s3;
        baseC[0] = c00;
        if (mod3 > 1) 
	  baseC[1] = c01;
        if (mod3 > 2) 
          baseC[2] = c02;
        if (mod3 > 3) 
          baseC[3] = c03;
      }
      else if (border1 + border2 == 2) {
        if (mod1 > 3) {
          baseC[0] = c30;
          if (mod3 > 1) 
	    baseC[1] = c31;
          if (mod3 > 2) 
	    baseC[2] = c32;
          if (mod3 > 3) 
	    baseC[3] = c33;
        }
        baseC -= s3;
        if (mod1 > 2) {
          baseC[0] = c20;
          if (mod3 > 1) 
	    baseC[1] = c21;
          if (mod3 > 2) 
	    baseC[2] = c22;
          if (mod3 > 3) 
	    baseC[3] = c23;
        }
        baseC -= s3;
        if (mod1 > 1) {
          baseC[0] = c10;
          if (mod3 > 1) 
	    baseC[1] = c11;
          if (mod3 > 2) 
	    baseC[2] = c12;
          if (mod3 > 3) 
	    baseC[3] = c13;
        }
        baseC -= s3;
        baseC[0] = c00;
        if (mod3 > 1) 
	  baseC[1] = c01;
        if (mod3 > 2) 
	  baseC[2] = c02;
        if (mod3 > 3) 
	  baseC[3] = c03;
      }
      baseC += 4; /*  next group of results  */
    }
    i++;
  }
  
  return (UT_OK);
}


/*******************************************************************************
ADD_MAT
Add one matrix element-wise to another.
RG
*******************************************************************************/
int add_mat(float **m1, float **m2, float **m3, int nr, int nc)
{
  float  *p1;
  float  *p2;
  float  *p3;
  float  *p3_end;
 
  p1 = &m1[1][1];
  p2 = &m2[1][1];

  /* assign pointer to last element of output vector */
  p3_end = &m3[nr][nc];

  for (p3 = &m3[1][1]; p3 <= p3_end; p3++) {
    *p3 = *p1 + *p2;
    p1++;
    p2++;
  }

  return (UT_OK);
}

/*******************************************************************************
ADD_DMAT
Add one matrix of doubles element-wise to another.
RG
*******************************************************************************/
int add_dmat(double **m1, double **m2, double **m3, int nr, int nc)
{
  int  i, j;

  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++) 
      m3[i][j] = m1[i][j] + m2[i][j];

  return (UT_OK);
}

/*******************************************************************************
SUBTRACT_MAT
Subtract one matrix element-wise from another.  The second matrix is
subtracted from the first matrix.
RG
*******************************************************************************/
int subtract_mat(float **m1, float **m2, float **m3, int nr, int nc)
{
  float  *p1;
  float  *p2;
  float  *p3;
  float  *p3_end;
 
  p1 = &m1[1][1];
  p2 = &m2[1][1];

  /* assign pointer to last element of output vector */
  p3_end = &m3[nr][nc];

  for (p3 = &m3[1][1]; p3 <= p3_end; p3++) {
    *p3 = *p1 - *p2;
    p1++;
    p2++;
  }

  return (UT_OK);
}


/*******************************************************************************
SUBTRACT_DMAT
Subtract one matrix of doubles element-wise from another.  The second matrix is
subtracted from the first matrix.
RG
*******************************************************************************/
int subtract_dmat(double **m1, double **m2, double **m3, int nr, int nc)
{
  double  *p1;
  double  *p2;
  double  *p3;
  double  *p3_end;
 
  p1 = &m1[1][1];
  p2 = &m2[1][1];

  /* assign pointer to last element of output vector */
  p3_end = &m3[nr][nc];

  for (p3 = &m3[1][1]; p3 <= p3_end; p3++) {
    *p3 = *p1 - *p2;
    p1++;
    p2++;
  }

  return (UT_OK);
}

/*******************************************************************************
ADD_VEC
Add one vector element-wise to another.
RG
*******************************************************************************/
int add_vec(float *v1, float *v2, float *v3, int n)
{
  float  *p1;
  float  *p2;
  float  *p3;
  float  *p3_end;
 
  /* assign pointer to last element of output vector */
  p3_end = &v3[n];

  for (p1 = &v1[1], p2 = &v2[1], p3 = &v3[1]; p3 <= p3_end; p1++, p2++, p3++)
    *p3 = *p1 + *p2;

  return (UT_OK);
}

/*******************************************************************************
ADD_DVEC
Add one vector of doubles element-wise to another.
RG
*******************************************************************************/
int add_dvec(double *v1, double *v2, double *v3, int n)
{
  double  *p1;
  double  *p2;
  double  *p3;
  double  *p3_end;
 
  /* assign pointer to last element of output vector */
  p3_end = &v3[n];

  for (p1 = &v1[1], p2 = &v2[1], p3 = &v3[1]; p3 <= p3_end; p1++, p2++, p3++)
    *p3 = *p1 + *p2;

  return (UT_OK);
}

/*******************************************************************************
SUBTRACT_VEC
Subtract one vector element-wise from another.  The second vector is 
subtracted from the first vector.
RG
*******************************************************************************/
int subtract_vec(float *v1, float *v2, float *v3, int n)
{
  float  *p1;
  float  *p2;
  float  *p3;
  float  *p3_end;
 
  /* assign pointer to last element of output vector */
  p3_end = &v3[n];

  for (p1 = &v1[1], p2 = &v2[1], p3 = &v3[1]; p3 <= p3_end; p1++, p2++, p3++)
    *p3 = *p1 - *p2;  

  return (UT_OK);
}

/*******************************************************************************
SUBTRACT_DVEC
Subtract one vector of doubles element-wise from another.  The second
vector is subtracted from the first vector.
RG
*******************************************************************************/
int subtract_dvec(double *v1, double *v2, double *v3, int n)
{
  double  *p1;
  double  *p2;
  double  *p3;
  double  *p3_end;
 
  /* assign pointer to last element of output vector */
  p3_end = &v3[n];

  for (p1 = &v1[1], p2 = &v2[1], p3 = &v3[1]; p3 <= p3_end; p1++, p2++, p3++)
    *p3 = *p1 - *p2;

  return (UT_OK);
}

/*******************************************************************************
DOT_PRODUCT_VEC
Compute the dot product of two vectors.
RG
*******************************************************************************/
float dot_product_vec(float *x, float *y, int n)
{
  float *p_x;
  float *p_y;
  float *p_end_x;
  float  result = 0.0;

  /* assign pointer to last element of x */
  p_end_x = &x[n];

  /* compute dot product */
  for (p_x = &x[1], p_y = &y[1]; p_x <= p_end_x; p_x++, p_y++)
    result += (*p_x) * (*p_y);

  return (result);
}

/*******************************************************************************
DOT_PRODUCT_DVEC
Compute the dot product of two vectors of doubles.
RG
*******************************************************************************/
double dot_product_dvec(double *x, double *y, int n)
{
  double *p_x;
  double *p_y;
  double *p_end_x;
  double  result = 0.0;

  /* assign pointer to last element of x */
  p_end_x = &x[n];

  /* compute dot product */
  for (p_x = &x[1], p_y = &y[1]; p_x <= p_end_x; p_x++, p_y++)
    result += (*p_x) * (*p_y);

  return (result);
}

/*******************************************************************************
OUTER_PRODUCT_VEC
Compute the outer product of two vectors.
RG
*******************************************************************************/
int outer_product_vec(float *x, float *y, int n, float **prod)
{
  float *p_x;
  float *p_y;
  float *p_end_x;
  float *p_end_y;
  float *p_prod;

  /* assign pointers to last elements of x and y */
  p_end_x = &x[n];
  p_end_y = &y[n];

  /* assign pointer to first element of outer product matrix */
  p_prod = &prod[1][1];

  /* calculate the outer product */
  for (p_x = &x[1]; p_x <= p_end_x; p_x++)
    for (p_y = &y[1]; p_y <= p_end_y; p_y++) {
      *p_prod = (*p_x) * (*p_y);
      p_prod++;
    }

  return (UT_OK);
}  

/*******************************************************************************
OUTER_PRODUCT_DVEC
Compute the outer product of two vectors of doubles.
RG
*******************************************************************************/
int outer_product_dvec(double *x, double *y, int n, double **prod)
{
  double *p_x;
  double *p_y;
  double *p_end_x;
  double *p_end_y;
  double *p_prod;

  /* assign pointers to last elements of x and y */
  p_end_x = &x[n];
  p_end_y = &y[n];

  /* assign pointer to first element of outer product matrix */
  p_prod = &prod[1][1];

  /* calculate the outer product */
  for (p_x = &x[1]; p_x <= p_end_x; p_x++)
    for (p_y = &y[1]; p_y <= p_end_y; p_y++) {
      *p_prod = (*p_x) * (*p_y);
      p_prod++;
    }

  return (UT_OK);
}

/*******************************************************************************
SCALAR_MULT_VEC
Scales a vector by a specified multiplicand.

n is the length of the vector.
v is the input vector.
constant is the multiplicand to scale the vector by.
RG,AG
*******************************************************************************/
int scalar_mult_vec(float *v, int n,  float constant)
{
  float  *p;
  float  *p_end;

  /* assign pointer to last element */
  p_end = &v[n];

  /* change each element of the vector */
  for (p = &v[1]; p <= p_end; p++)
    *p *= constant;

  return (UT_OK);
}

/*******************************************************************************
SCALAR_MULT_DVEC
Scales a vector of doubles by a specified multiplicand.

n is the length of the vector.
v is the input vector.
constant is the multiplicand to scale the vector by.
RG
*******************************************************************************/
int scalar_mult_dvec(double *v, int n, double constant)
{
  double  *p;
  double  *p_end;

  /* assign pointer to last element */
  p_end = &v[n];

  /* change each element of the vector */
  for (p = &v[1]; p <= p_end; p++)
    *p *= constant;

  return (UT_OK);
}

/*******************************************************************************
SCALAR_DIV_VEC
Scales a vector by a specified dividend.

n is the length of the vector.
v is the input vector.
constant is the dividend to scale the vector by.
RG
*******************************************************************************/
int scalar_div_vec(float *v, int n, float constant)
{
  float  *p;
  float  *p_end;
  float  inv_constant;

  /* assign pointer to last element */
  p_end = &v[n];

  /* calculate the inverse of the constant to save on divides */
  if (constant == 0.0)
    inv_constant = FLT_MAX;
  else
    inv_constant = 1.0 / constant;

  /* change each element of the vector */
  for (p = &v[1]; p <= p_end; p++)
    *p *= inv_constant;

  return (UT_OK);
}

/*******************************************************************************
SCALAR_DIV_DVEC
Scales a vector of doubles by a specified dividend.

n is the length of the vector.
v is the input vector.
constant is the dividend to scale the vector by.
RG
*******************************************************************************/
int scalar_div_dvec(double *v, int n, double constant)
{
  double  *p;
  double  *p_end;
  double  inv_constant;

  /* assign pointer to last element */
  p_end = &v[n];

  /* calculate the inverse of the constant to save on divides */
  if (constant == 0.0)
    inv_constant = DBL_MAX;
  else
    inv_constant = 1.0 / constant;

  /* change each element of the vector */
  for (p = &v[1]; p <= p_end; p++)
    *p *= inv_constant;

  return (UT_OK);
}

/*******************************************************************************
SCALAR_ADD_VEC
Translates a vector by a specified addend.

nc is the length of the vector.
v is the input vector.
constant is the addend to translate the vector by.
RG
*******************************************************************************/
int scalar_add_vec(float *v, int n, float constant)
{
  float  *p;
  float  *p_end;

  /* assign pointer to last element */
  p_end = &v[n];

  /* change each element of the vector */
  for (p = &v[1]; p <= p_end; p++)
    *p += constant;

  return (UT_OK);
}


/*******************************************************************************
SCALAR_ADD_DVEC
Translates a vector of doubles by a specified addend.

nc is the length of the vector.
v is the input vector.
constant is the addend to translate the vector by.
RG
*******************************************************************************/
int scalar_add_dvec(double *v, int n, double constant)
{
  double  *p;
  double  *p_end;

  /* assign pointer to last element */
  p_end = &v[n];

  /* change each element of the vector */
  for (p = &v[1]; p <= p_end; p++)
    *p += constant;

  return (UT_OK);
}


/*******************************************************************************
SCALAR_SUBTRACT_VEC
Translates a vector by a specified subtrahend.

nc is the length of the vector.
v is the input vector.
constant is the subtrahend to translate the vector by.
RG
*******************************************************************************/
int scalar_subtract_vec(float *v, int n, float constant)
{
  float  *p;
  float  *p_end;

  /* assign pointer to last element */
  p_end = &v[n];

  /* change each element of the vector */
  for (p = &v[1]; p <= p_end; p++)
    *p -= constant;

  return (UT_OK);
}

/*******************************************************************************
SCALAR_SUBTRACT_DVEC
Translates a vector of doubles by a specified subtrahend.

nc is the length of the vector.
v is the input vector.
constant is the subtrahend to translate the vector by.
RG
*******************************************************************************/
int scalar_subtract_dvec(double *v, int n, double constant)
{
  double  *p;
  double  *p_end;

  /* assign pointer to last element */
  p_end = &v[n];

  /* change each element of the vector */
  for (p = &v[1]; p <= p_end; p++)
    *p -= constant;

  return (UT_OK);
}


/*******************************************************************************
SCALAR_MULT_MAT
Scales a matrix by a specified multiplicand.

nr and nc are the dimensions of the matrix (num. rows and num. cols).
m is the input matrix.
constant is the multiplicand to scale the matrix by.
RG
*******************************************************************************/
int scalar_mult_mat(float **m, int nr, int nc, float constant)
{
  float  *p;
  float  *p_end;

  /* assign pointer to last element */
  p_end = &m[nr][nc];

  /* change each element of the matrix */
  for (p = &m[1][1]; p <= p_end; p++)
    *p *= constant;

  return (UT_OK);
}


/*******************************************************************************
SCALAR_MULT_DMAT
Scales a matrix of doubles by a specified multiplicand.

nr and nc are the dimensions of the matrix (num. rows and num. cols).
m is the input matrix.
constant is the multiplicand to scale the matrix by.
RG
*******************************************************************************/
int scalar_mult_dmat(double **m, int nr, int nc, double constant)
{
  double  *p;
  double  *p_end;

  /* assign pointer to last element */
  p_end = &m[nr][nc];

  /* change each element of the matrix */
  for (p = &m[1][1]; p <= p_end; p++)
    *p *= constant;

  return (UT_OK);
}


/*******************************************************************************
SCALAR_DIV_MAT
Scales a matrix by a specified dividend.

nr and nc are the dimensions of the matrix (num. rows and num. cols).
m is the input matrix.
constant is the dividend to scale the matrix by.
RG
*******************************************************************************/
int scalar_div_mat(float **m, int nr, int nc, float constant)
{
  float  *p;
  float  *p_end;
  float  inv_constant;

  /* assign pointer to last element */
  p_end = &m[nr][nc];

  /* calculate the inverse of the constant to save on divides */
  if (constant == 0.0)
    inv_constant = FLT_MAX;
  else
    inv_constant = 1.0 / constant;

  /* change each element of the matrix */
  for (p = &m[1][1]; p <= p_end; p++)
    *p *= inv_constant;

  return (UT_OK);
}


/*******************************************************************************
SCALAR_DIV_DMAT
Scales a matrix of doubles by a specified dividend.

nr and nc are the dimensions of the matrix (num. rows and num. cols).
m is the input matrix.
constant is the dividend to scale the matrix by.
RG
*******************************************************************************/
int scalar_div_dmat(double **m, int nr, int nc, double constant)
{
  int     i, j;
  double  inv_constant;

  /* calculate the inverse of the constant to save on divides */
  if (constant == 0.0)
    inv_constant = DBL_MAX;
  else
    inv_constant = 1.0 / constant;

  /* change each element of the matrix */
  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++)
      m[i][j] *= inv_constant;

  return (UT_OK);
}


/*******************************************************************************
SCALAR_ADD_MAT
Translates a matrix by a specified addend.

nr and nc are the dimensions of the matrix (num. rows and num. cols).
m is the input matrix.
constant is the addend to translate the matrix by.
RG
*******************************************************************************/
int scalar_add_mat(float **m, int nr, int nc, float constant)

{
  float  *p;
  float  *p_end;

  /* assign pointer to last element */
  p_end = &m[nr][nc];

  /* change each element of the matrix */
  for (p = &m[1][1]; p <= p_end; p++)
    *p += constant;

  return (UT_OK);
}


/*******************************************************************************
SCALAR_ADD_DMAT
Translates a matrix of doubles by a specified addend.

nr and nc are the dimensions of the matrix (num. rows and num. cols).
m is the input matrix.
constant is the addend to translate the matrix by.
RG
*******************************************************************************/
int scalar_add_dmat(double **m, int nr, int nc, double constant)

{
  double  *p;
  double  *p_end;

  /* assign pointer to last element */
  p_end = &m[nr][nc];

  /* change each element of the matrix */
  for (p = &m[1][1]; p <= p_end; p++)
    *p += constant;

  return (UT_OK);
}


/*******************************************************************************
SCALAR_SUBTRACT_MAT
Translates a matrix by a specified subtrahend.

nr and nc are the dimensions of the matrix (num. rows and num. cols).
m is the input matrix.
constant is the subtrahend to translate the matrix by.
RG
*******************************************************************************/
int scalar_subtract_mat(float **m, int nr, int nc, float constant)
{
  float  *p;
  float  *p_end;

  /* assign pointer to last element */
  p_end = &m[nr][nc];

  /* change each element of the matrix */
  for (p = &m[1][1]; p <= p_end; p++)
    *p -= constant;

  return (UT_OK);
}


/*******************************************************************************
SCALAR_SUBTRACT_DMAT
Translates a matrix of doubles by a specified subtrahend.

nr and nc are the dimensions of the matrix (num. rows and num. cols).
m is the input matrix.
constant is the subtrahend to translate the matrix by.
RG
*******************************************************************************/
int scalar_subtract_dmat(double **m, int nr, int nc, double constant)
{
  double  *p;
  double  *p_end;

  /* assign pointer to last element */
  p_end = &m[nr][nc];

  /* change each element of the matrix */
  for (p = &m[1][1]; p <= p_end; p++)
    *p -= constant;

  return (UT_OK);
}


/*******************************************************************************
MULT_VEC_ELT
Multiply one vector element-wise by another.
RG
*******************************************************************************/
int mult_vec_elt(float *v1, float *v2, float *v3, int n)
{
  float  *p1;
  float  *p2;
  float  *p3;
  float  *p3_end;

  /* assign pointer to last element of output vector */
  p3_end = &v3[n];

  for (p1 = &v1[1], p2 = &v2[1], p3 = &v3[1]; p3 <= p3_end; p1++, p2++, p3++)
    *p3 = (*p1) * (*p2);

  return (UT_OK);
}


/*******************************************************************************
MULT_DVEC_ELT
Multiply one vector of doubles element-wise by another.
RG
*******************************************************************************/
int mult_dvec_elt(double *v1, double *v2, double *v3, int n)
{
  double  *p1;
  double  *p2;
  double  *p3;
  double  *p3_end;

  /* assign pointer to last element of output vector */
  p3_end = &v3[n];

  for (p1 = &v1[1], p2 = &v2[1], p3 = &v3[1]; p3 <= p3_end; p1++, p2++, p3++);
    *p3 = (*p1) * (*p2);

  return (UT_OK);
}


/*******************************************************************************
DIV_VEC_ELT
Divide one vector element-wise by another.
RG
*******************************************************************************/
int div_vec_elt(float *v1, float *v2, float *v3, int n)
{
  float  *p1;
  float  *p2;
  float  *p3;
  float  *p3_end;

  /* assign pointer to last element of output vector */
  p3_end = &v3[n];

  for (p1 = &v1[1], p2 = &v2[1], p3 = &v3[1]; p3 <= p3_end; p1++, p2++, p3++)
    *p3 = (*p1) / (*p2);

  return (UT_OK);
}


/*******************************************************************************
DIV_DVEC_ELT
Divide one vector element-wise by another.
RG
*******************************************************************************/
int div_dvec_elt(double *v1, double *v2, double *v3, int n)
{
  double  *p1;
  double  *p2;
  double  *p3;
  double  *p3_end;

  /* assign pointer to last element of output vector */
  p3_end = &v3[n];

  for (p1 = &v1[1], p2 = &v2[1], p3 = &v3[1]; p3 <= p3_end; p1++, p2++, p3++)
    *p3 = (*p1) / (*p2);

  return (UT_OK);
}


/*******************************************************************************
MULT_MAT_ELT
Multiply one matrix element-wise by another.
RG
*******************************************************************************/
int mult_mat_elt(float **m1, float **m2, float **m3, int nr, int nc)
{
  float  *p1;
  float  *p2;
  float  *p3;
  float  *p3_end;

  p1 = &m1[1][1];
  p2 = &m2[1][1];
  
  /* assign pointer to last element of output vector */
  p3_end = &m3[nr][nc];

  for (p3 = &m3[1][1]; p3 <= p3_end; p3++) {
    *p3 = (*p1) * (*p2);
    p1++;
    p2++;
  }

  return (UT_OK);
}


/*******************************************************************************
MULT_DMAT_ELT
Multiply one matrix of doubles element-wise by another.
RG
*******************************************************************************/
int mult_dmat_elt(double **m1, double **m2, double **m3, int nr, int nc)
{
  double  *p1;
  double  *p2;
  double  *p3;
  double  *p3_end;

  p1 = &m1[1][1];
  p2 = &m2[1][1];
  
  /* assign pointer to last element of output vector */
  p3_end = &m3[nr][nc];

  for (p3 = &m3[1][1]; p3 <= p3_end; p3++) {
    *p3 = (*p1) * (*p2);
    p1++;
    p2++;
  }

  return (UT_OK);
}


/*******************************************************************************
DIV_MAT_ELT
Divide one matrix element-wise by another.
RG
*******************************************************************************/
int div_mat_elt(float **m1, float **m2, float **m3, int nr, int nc)
{
  float  *p1;
  float  *p2;
  float  *p3;
  float  *p3_end;

  p1 = &m1[1][1];
  p2 = &m2[1][1];
  
  /* assign pointer to last element of output vector */
  p3_end = &m3[nr][nc];

  for (p3 = &m3[1][1]; p3 <= p3_end; p3++) {
    *p3 = (*p1) / (*p2);
    p1++;
    p2++;
  }

  return (UT_OK);
}


/*******************************************************************************
DIV_DMAT_ELT
Divide one matrix of doubles element-wise by another.
RG
*******************************************************************************/
int div_dmat_elt(double **m1, double **m2, double **m3, int nr, int nc)
{
  double  *p1;
  double  *p2;
  double  *p3;
  double  *p3_end;

  p1 = &m1[1][1];
  p2 = &m2[1][1];
  
  /* assign pointer to last element of output vector */
  p3_end = &m3[nr][nc];

  for (p3 = &m3[1][1]; p3 <= p3_end; p3++) {
    *p3 = (*p1) / (*p2);
    p1++;
    p2++;
  }

  return (UT_OK);
}


/*******************************************************************************
PCA_MAT
Perform principal components analysis (PCA) on a matrix.  The output is three 
matrices, one containing the principal components for the data, one containing
the associated eigenvalues, and one containing the other orthogonal matrix in 
the decomposition.  These correspond to U, W, and V^T respectively in the 
decomposition of the input matrix A = U * W * V^T.

Done using singular value decomposition (SVD).

Notes: A is overwritten by U.  nr and nc are the dimensions of A (and thus U).
Use the vector w instead of the matrix W to hold the eigenvalues, of size nc.
VT has dimensions nc x nc.
AG, RG
*******************************************************************************/
int pca_mat(float **A, int nr, int nc, float *w, float **VT)
{
  int maxiter;

  /* heuristic to set the number of svd iterations */
  maxiter = NR_imax(30, (int) (nr * nc / 10000));

  /* compute the svd; A will be overwritten by U */
  DA_svdcmp(A, nr, nc, w, VT, maxiter);

  /* this returns V rather than the transpose V^T */
  transpose_in_situ_sqr_matrix(VT, nc);

  return (UT_OK);
}


/*******************************************************************************
PCA_ALLOC_MAT
Perform principal components analysis (PCA) on a matrix.  The output is three 
matrices, one containing the principal components for the data, one containing
the associated eigenvalues, and one containing the other orthogonal matrix in 
the decomposition.  These correspond to U, W, and V^T respectively in the 
decomposition of the input matrix A = U * W * V^T.

Done using singular value decomposition (SVD).

Notes: A is overwritten by U.  nr and nc are the dimensions of A (and thus U).
Use the vector w instead of the matrix W to hold the eigenvalues, of size nc.
VT has dimensions nc x nc.
AG
*******************************************************************************/
int pca_alloc_mat(float **A, int nr, int nc, float *w, float **VT)
{
  float **V;
  int maxiter;

  /* allocate the transpose of VT, V */
  V = NR_matrix(1, nc, 1, nc);
  if (V == (float**)NULL) {
    err_printf();
    log_printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }

  /* heuristic to set the number of svd iterations */
  maxiter = NR_imax(30, (int) (nr * nc / 10000));

  /* compute the svd; A will be overwritten by U */
  DA_svdcmp(A, nr, nc, w, V, maxiter);

  /* this returns V rather than the transpose V^T */
  transpose_matrix(V, nc, nc, VT);

  NR_free_matrix(V, 1, nc, 1, nc);
  return (UT_OK);
}


/*******************************************************************************
LSQR_MAT
An iterative method for solving least-squares/minimum norm problems of the
form Ax = b.  It requires three workspace vectors u, v and w of length nr, nc,
and nc respectively, where nr and nc are the dimensions of A.  The stopping
conditions are set by three input parameters, atol, btol, and conlim.  
Recommended values for these parameters depend on the machine value EPSILON:

atol = EPSILON
btol = EPSILON
conlim = (1.0 / (10 * sqrt(EPSILON).

Using floating point numbers may result in poorer convergence properties;
use the double-precision version of this function for better convergence 
properties.
 
Reference: CC Paige, MA Saunders.  "LSQR: An Algorithm for Sparse Linear
Equations and Sparse Least Squares."  ACM Trans Math Soft, Vol 8, No 1,
March 1982, pp43-71.
 
Most of the notation used in this function is derived from this paper.
RG
*******************************************************************************/
int lsqr_mat(float **A, int nr, int nc, float *b, float *x, float *u,
             float *v, float *w, float atol, float btol, float conlim)
{
  int   i, j;
  float alpha;
  float beta;
  float norm_A;
  float norm_b;
  float norm_B;
  float norm_D;
  float norm_Ar;
  float norm_r;
  float norm_x;
  float norm_xx;
  float norm_d;
  float cond_A;
  float phi, phi_bar;
  float rho, rho_bar;
  float gamma, gamma_bar;
  float z, z_bar;
  float delta;
  float c;
  float s;
  float theta;
  float sn;
  float cs;
  float rhs;
  int   iters;
  int   stop1, stop2, stop3;
 
  /* initialize */

  copy_vec(b, u, nr);
 
  beta = norm_vec(u, nr);
  scalar_div_vec(u, nr, beta);

  left_mult_matrix(A, nr, nc, u, v);
  alpha = norm_vec(v, nc);
  scalar_div_vec(v, nc, alpha);

  copy_vec(v, w, nc);;
  
  fast_zero_vec(x, nc);
  
  phi_bar = beta;
  rho_bar = alpha;
 
  /* quantities needed for stopping conditions */
 
  norm_A = frobenius_norm_mat(A, nr, nc);
  norm_b = norm_vec(b, nr);

  cond_A = 0.0;
  norm_B = 0.0;
  norm_D = 0.0;
  norm_x = 0.0;
  norm_Ar = 0.0;

  /* quantities used for estimating the norm of x */

  cs = -1.0;
  sn = 0.0;
  z = 0.0;
  norm_xx = 0.0;

  /* now perform the iterations */
 
  iters = 0;
  stop1 = 0;
  stop2 = 0;
  stop3 = 0;
 
  do {
    iters++;
 
    /* bidiagonalization */
 
    for (i = 1; i <= nr; i++) {
      u[i] *= -alpha;
      for (j = 1; j <= nc; j++)
        u[i] += A[i][j] * v[j];
    }
 
    beta = norm_vec(u, nr);
    scalar_div_vec(u, nr, beta);
 
    /* before we overwrite alpha(k) with alpha(k+1) */
 
    norm_B = norm_B + NR_sqr(alpha) + NR_sqr(beta);
 
    /* continue with bidiagonalization */
 
    for (j = 1; j <= nc; j++) {
      v[j] *= -beta;
      for (i = 1; i <= nr; i++)
        v[j] += A[i][j] * u[i];
    }
 
    alpha = norm_vec(v, nc);
    scalar_div_vec(v, nc, alpha);
 
    /* orthogonal transformation */
 
    rho = sqrt(NR_sqr(rho_bar) + NR_sqr(beta));
    c = rho_bar / rho;
    s = beta / rho;
    theta = s * alpha;
    rho_bar = -c * alpha;
    phi = c * phi_bar;
    phi_bar *= s;
 
    /* update x, w */
 
    for (i = 1; i <= nc; i++) {
      x[i] += phi * w[i] / rho;
      w[i] = v[i] - theta * w[i] / rho;
    }
 
    /* stopping criteria */
 
    norm_r = phi_bar;
 
    norm_Ar = phi_bar * alpha * fabs(c);
 
    delta = sn * rho;
    gamma_bar = -cs * rho;
    rhs = phi - delta * z;
    z_bar = rhs / gamma_bar;
    norm_x = sqrt(norm_xx + NR_sqr(z_bar));
    gamma = sqrt(NR_sqr(gamma_bar) + NR_sqr(theta));
    cs = gamma_bar / gamma;
    sn = theta / gamma;
    z = rhs / gamma;
    norm_xx += NR_sqr(z);
 
    norm_d = norm_vec(w, nc) / rho;
    norm_D = norm_D + norm_d;
    cond_A = norm_d * norm_D;
 
    if (norm_r <= btol * norm_b + atol * norm_A * norm_x)
      stop1 = 1;
 
    if (norm_Ar / (norm_A * norm_r) <= atol)
      stop2 = 1;
 
    if (cond_A >= conlim)
      stop3 = 1;
 
  } while (!stop1 && !stop2 && !stop3);

  return (UT_OK);
}


/*******************************************************************************
LSQR_DMAT
An iterative method for solving least-squares/minimum norm problems of the
form Ax = b.  It requires three workspace vectors u, v and w of length nr, nc,
and nc respectively, where nr and nc are the dimensions of A.  The stopping
conditions are set by three input parameters, atol, btol, and conlim.  
Recommended values for these parameters depend on the machine value
DBL_EPSILON:

atol = DBL_EPSILON
btol = DBL_EPSILON
conlim = (1.0 / (10 * sqrt(DBL_EPSILON).

For better convergence properties, LSQR takes its inputs in double precision.
 
Reference: CC Paige, MA Saunders.  "LSQR: An Algorithm for Sparse Linear
Equations and Sparse Least Squares."  ACM Trans Math Soft, Vol 8, No 1,
March 1982, pp43-71.
 
Most of the notation used in this function is derived from this paper.
RG
*******************************************************************************/
int lsqr_dmat(double **A, int nr, int nc, double *b, double *x, double *u,
              double *v, double *w, double atol, double btol, double conlim)
{
  int    i, j;
  double alpha;
  double beta;
  double norm_A;
  double norm_b;
  double norm_B;
  double norm_D;
  double norm_Ar;
  double norm_r;
  double norm_x;
  double norm_xx;
  double norm_d;
  double cond_A;
  double phi, phi_bar;
  double rho, rho_bar;
  double gamma, gamma_bar;
  double z, z_bar;
  double delta;
  double c;
  double s;
  double theta;
  double sn;
  double cs;
  double rhs;
  int    iters;
  int    stop1, stop2, stop3;
 
  /* initialize */

  copy_dvec(b, u, nr);
 
  beta = norm_dvec(u, nr);
  scalar_div_dvec(u, nr, beta);

  left_mult_dmatrix(A, nr, nc, u, v);
  alpha = norm_dvec(v, nc);
  scalar_div_dvec(v, nc, alpha);

  copy_dvec(v, w, nc);;
  
  fast_zero_dvec(x, nc);
  
  phi_bar = beta;
  rho_bar = alpha;
 
  /* quantities needed for stopping conditions */
 
  norm_A = frobenius_norm_dmat(A, nr, nc);
  norm_b = norm_dvec(b, nr);

  cond_A = 0.0;
  norm_B = 0.0;
  norm_D = 0.0;
  norm_x = 0.0;
  norm_Ar = 0.0;

  /* quantities used for estimating the norm of x */

  cs = -1.0;
  sn = 0.0;
  z = 0.0;
  norm_xx = 0.0;

  /* now perform the iterations */
 
  iters = 0;
  stop1 = 0;
  stop2 = 0;
  stop3 = 0;
 
  do {
    iters++;
 
    /* bidiagonalization */
 
    for (i = 1; i <= nr; i++) {
      u[i] *= -alpha;
      for (j = 1; j <= nc; j++)
        u[i] += A[i][j] * v[j];
    }
 
    beta = norm_dvec(u, nr);
    scalar_div_dvec(u, nr, beta);
 
    /* before we overwrite alpha(k) with alpha(k+1) */
 
    norm_B = norm_B + NR_sqr(alpha) + NR_sqr(beta);
 
    /* continue with bidiagonalization */
 
    for (j = 1; j <= nc; j++) {
      v[j] *= -beta;
      for (i = 1; i <= nr; i++)
        v[j] += A[i][j] * u[i];
    }
 
    alpha = norm_dvec(v, nc);
    scalar_div_dvec(v, nc, alpha);
 
    /* orthogonal transformation */
 
    rho = sqrt(NR_sqr(rho_bar) + NR_sqr(beta));
    c = rho_bar / rho;
    s = beta / rho;
    theta = s * alpha;
    rho_bar = -c * alpha;
    phi = c * phi_bar;
    phi_bar *= s;
 
    /* update x, w */
 
    for (i = 1; i <= nc; i++) {
      x[i] += phi * w[i] / rho;
      w[i] = v[i] - theta * w[i] / rho;
    }
 
    /* stopping criteria */
 
    norm_r = phi_bar;
 
    norm_Ar = phi_bar * alpha * fabs(c);
 
    delta = sn * rho;
    gamma_bar = -cs * rho;
    rhs = phi - delta * z;
    z_bar = rhs / gamma_bar;
    norm_x = sqrt(norm_xx + NR_sqr(z_bar));
    gamma = sqrt(NR_sqr(gamma_bar) + NR_sqr(theta));
    cs = gamma_bar / gamma;
    sn = theta / gamma;
    z = rhs / gamma;
    norm_xx += NR_sqr(z);
 
    norm_d = norm_dvec(w, nc) / rho;
    norm_D = norm_D + norm_d;
    cond_A = norm_d * norm_D;
 
    if (norm_r <= btol * norm_b + atol * norm_A * norm_x)
      stop1 = 1;
 
    if (norm_Ar / (norm_A * norm_r) <= atol)
      stop2 = 1;
 
    if (cond_A >= conlim)
      stop3 = 1;
 
  } while (!stop1 && !stop2 && !stop3);

  return (UT_OK);
}
@


1.43
log
@added Jacobi preconditioned version of inverse function
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.42 1998/07/02 01:15:29 granat Exp granat $";
d37 3
d205 1
d2444 1
a2444 7
  double  *p1;
  double  *p2;
  double  *p3;
  double  *p3_end;
 
  p1 = &m1[1][1];
  p2 = &m2[1][1];
d2446 3
a2448 2
  /* assign pointer to last element of output vector */
  p3_end = &m3[nr][nc];
a2449 6
  for (p3 = &m3[1][1]; p3 <= p3_end; p3++) {
    *p3 = *p1 + *p2;
    p1++;
    p2++;
  }

d2767 4
a2770 1
  inv_constant = 1.0 / constant;
d2798 4
a2801 1
  inv_constant = 1.0 / constant;
d2978 4
a2981 1
  inv_constant = 1.0 / constant;
d3002 1
a3002 2
  double  *p;
  double  *p_end;
a3004 3
  /* assign pointer to last element */
  p_end = &m[nr][nc];

d3006 4
a3009 1
  inv_constant = 1.0 / constant;
d3012 3
a3014 2
  for (p = &m[1][1]; p <= p_end; p++)
    *p *= inv_constant;
@


1.42
log
@added fast matrix multiply
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.41 1998/06/29 22:11:24 granat Exp $";
d37 3
d1214 1
d1216 53
d1292 1
d1294 71
d1394 3
d1400 1
d1402 37
d1464 25
d1517 28
d2530 1
a2530 1
  p3_end = &p3[n];
d2551 1
a2551 1
  p3_end = &p3[n];
d2573 1
a2573 1
  p3_end = &p3[n];
d2595 1
a2595 1
  p3_end = &p3[n];
d3333 1
a3333 1
AG
d3337 32
d3373 1
a3373 1
  V = NR_matrix(1, nr, 1, nc);
d3415 1
d3592 1
@


1.41
log
@added LSQR method of Paige and Saunders
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.40 1998/05/07 23:56:43 granat Exp granat $";
d37 3
d1589 590
@


1.40
log
@moved many functions to da_util.c
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.39 1998/05/01 17:37:03 granat Exp granat $";
d37 3
d210 1
d311 1
a311 1
  float  *p, *p_end;
d341 1
a341 1
  double  *p, *p_end;
d371 1
a371 1
  int     *p, *p_end;
d401 1
a401 1
  unsigned char  *p, *p_end;
d2505 1
a2505 1
PCA
d2519 1
a2519 1
int pca(float **A, int nr, int nc, float *w, float **VT)
d2542 353
@


1.39
log
@added versions of many functions to handle other data types
added many new functions
changed some function names to match convention
some minor reformatting changes
edited many functions to make them faster
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.38 1997/10/21 14:32:23 granat Exp granat $";
d37 7
d205 3
d301 2
a302 2
SUM_VEC
Sum the values in a vector.
d305 1
a305 1
float sum_vec(float *v, int n)
d307 9
a315 3
  float  *p;
  float  *p_end;
  float   sum = 0.0;;
d317 2
a318 2
  /* assign pointer to last element */
  p_end = &v[n];
d320 5
a324 3
  /* accumulate square of the vector */
  for (p = &v[1]; p <= p_end; p++)
    sum += *p;
d326 1
a326 1
  return (sum);
d331 2
a332 2
SUM_DVEC
Sum the values in a vector of doubles.
d335 1
a335 1
double sum_dvec(double *v, int n)
d337 9
a345 3
  double  *p;
  double  *p_end;
  double   sum = 0.0;;
d347 2
a348 2
  /* assign pointer to last element */
  p_end = &v[n];
d350 5
a354 3
  /* accumulate square of the vector */
  for (p = &v[1]; p <= p_end; p++)
    sum += *p;
d356 1
a356 1
  return (sum);
d361 2
a362 2
SUM_IVEC
Sum the values in a vector of integers, and return the result as a integer.
d365 1
a365 1
int sum_ivec(int *v, int n)
d367 9
a375 3
  int    *p;
  int    *p_end;
  int    sum = 0;
d377 2
a378 2
  /* assign pointer to last element */
  p_end = &v[n];
d380 5
a384 3
  /* accumulate square of the vector */
  for (p = &v[1]; p <= p_end; p++)
    sum += (*p);
d386 1
a386 1
  return (sum);
d391 2
a392 2
SUM_CVEC
Sum the values in a vector of integers, and return the result as a integer.
d395 1
a395 1
int sum_cvec(unsigned char *v, int n)
d397 9
a405 3
  unsigned char  *p;
  unsigned char  *p_end;
  int            sum = 0;
d407 2
a408 2
  /* assign pointer to last element */
  p_end = &v[n];
d410 5
a414 3
  /* accumulate square of the vector */
  for (p = &v[1]; p <= p_end; p++)
    sum += (int) (*p);
d416 1
a416 1
  return (sum);
d421 6
a426 2
SUM_MAT
Sum the values in a matrix.
d429 2
a430 1
float sum_mat(float **m, int nr, int nc)
d432 7
a438 3
  float *p;
  float *p_end;
  float sum = 0.0;
d440 8
a447 2
  /* assign pointer to last element */
  p = &m[nr][nc];
d449 1
a449 2
  /* the memory is one continuous strip, so it can be stepped through */
  /* in a single loop to reduce branching */
d451 2
a452 2
  for (p = &m[1][1]; p <= p_end; p++)
    sum += *p;
d454 1
a454 2
  return (sum);
}
d456 1
d458 2
a459 10
/*******************************************************************************
SUM_DMAT
Sum the values in a matrix of doubles, and return the result as a double.
RG
*******************************************************************************/
double sum_dmat(double **m, int nr, int nc)
{
  double *p;
  double *p_end;
  double sum = 0.0;
d461 3
a463 2
  /* assign pointer to last element */
  p = &m[nr][nc];
d465 5
a469 2
  /* the memory is one continuous strip, so it can be stepped through */
  /* in a single loop to reduce branching */
d471 1
a471 2
  for (p = &m[1][1]; p <= p_end; p++)
    sum += *p;
d473 1
a473 2
  return (sum);
}
d475 2
d478 1
a478 10
/*******************************************************************************
SUM_IMAT
Sum the values in a matrix of integers, and return the result as a integer.
RG
*******************************************************************************/
int sum_imat(int **m, int nr, int nc)
{
  int   *p;
  int   *p_end;
  int   sum = 0;
d480 2
a481 2
  /* assign pointer to last element */
  p = &m[nr][nc];
d483 5
a487 2
  /* the memory is one continuous strip, so it can be stepped through */
  /* in a single loop to reduce branching */
d489 1
a489 2
  for (p = &m[1][1]; p <= p_end; p++)
    sum += (float) (*p);
d491 2
a492 2
  return (sum);
}
d494 1
d496 6
a501 11
/*******************************************************************************
SUM_CMAT
Sum the values in a matrix of unsigned chars, and return the result as a 
integer.
RG
*******************************************************************************/
int sum_cmat(unsigned char **m, int nr, int nc)
{
  unsigned char  *p;
  unsigned char  *p_end;
  int            sum = 0;
d503 1
a503 2
  /* assign pointer to last element */
  p = &m[nr][nc];
d505 1
a505 2
  /* the memory is one continuous strip, so it can be stepped through */
  /* in a single loop to reduce branching */
d507 7
a513 2
  for (p = &m[1][1]; p <= p_end; p++)
    sum += (float) (*p);
d515 3
a517 2
  return (sum);
}
d519 1
d521 1
a521 14
/*******************************************************************************
SUM_MAT_ROWS
Compute the vector which is the sum of the rows of a given matrix.
AG
*******************************************************************************/
int sum_mat_rows(float **m, float *v, int nr, int nc)
{
  int   i;
  float *curr_row;

  for (i = 1; i <= nr; i++)
  {
    curr_row = m[i];
    v[i] = sum_vec(curr_row, nc);
d523 2
d526 1
a526 2
  return (UT_OK);
}
d528 5
d534 1
a534 15
/*******************************************************************************
SUM_DMAT_ROWS
Compute the vector which is the sum of the rows of a given matrix of doubles.
AG, RG
*******************************************************************************/
int sum_dmat_rows(double **m, double *v, int nr, int nc)
{
  int    i;
  double *curr_row;

  for (i = 1; i <= nr; i++)
  {
    curr_row = m[i];
    v[i] = sum_dvec(curr_row, nc);
  }
d536 5
a540 2
  return (UT_OK);
}
d542 3
d546 1
a546 15
/*******************************************************************************
SUM_IMAT_ROWS
Compute the vector which is the sum of the rows of a given matrix of integers.
AG, RG
*******************************************************************************/
int sum_imat_rows(int **m, int *v, int nr, int nc)
{
  int    i;
  int    *curr_row;

  for (i = 1; i <= nr; i++)
  {
    curr_row = m[i];
    v[i] = sum_ivec(curr_row, nc);
  }
d548 2
a549 2
  return (UT_OK);
}
d551 1
a551 17

/*******************************************************************************
SUM_CMAT_ROWS
Compute the vector of integers which is the sum of the rows of a given 
matrix of unsigned chars.
AG, RG
*******************************************************************************/
int sum_cmat_rows(unsigned char **m, int *v, int nr, int nc)
{
  int            i;
  unsigned char  *curr_row;

  for (i = 1; i <= nr; i++)
  {
    curr_row = m[i];
    v[i] = sum_cvec(curr_row, nc);
  }
d558 6
a563 3
NORMALIZE_VEC
Given a vector, return the sum of the members, and divide each element by that
sum.
d566 2
a567 1
float normalize_vec(float *v, int n)
d569 5
a573 1577
  float sum;

  sum = sum_vec(v, n);
  scalar_div_vec(v, n, sum);

  return (sum);
}


/*******************************************************************************
NORMALIZE_DVEC
Given a vector of doubles, return the sum of the members, and divide each 
element by that sum.
RG
*******************************************************************************/
double normalize_dvec(double *v, int n)
{
  double sum;

  sum = sum_dvec(v, n);
  scalar_div_dvec(v, n, sum);

  return (sum);
}


/*******************************************************************************
NORMALIZE_MAT
Given a matrix, return the sum of the members, and divide each element by that
sum.
RG
*******************************************************************************/
float normalize_mat(float **m, int nr, int nc)
{
  float sum;

  sum = sum_mat(m, nr, nc);
  scalar_div_mat(m, nr, nc, sum);

  return (sum);
}


/*******************************************************************************
NORMALIZE_DMAT
Given a matrix of doubles, return the sum of the members, and divide each 
element by that sum.
RG
*******************************************************************************/
double normalize_dmat(double **m, int nr, int nc)
{
  double sum;

  sum = sum_dmat(m, nr, nc);
  scalar_div_dmat(m, nr, nc, sum);

  return (sum);
}


/*******************************************************************************
NORM_SUM_MAT_ROWS
For each row of a given matrix, divide each element by the sum of the elements
in the row.
 
Note:  Could later have norm_sum_mat_rows_and_keep(), which keeps a vector of
the row sums, returning it (analogous to prob_mixture_and_keep()).
AG
*******************************************************************************/
int norm_sum_mat_rows(float **m, int nr, int nc)
{
  int   i;
  float *curr_row;

  for (i = 1; i <= nr; i++)
  {
    curr_row = m[i];
    norm_sum_vec(curr_row, nc);
  }

  return (UT_OK);
}


/*******************************************************************************
NORM_SUM_DMAT_ROWS
For each row of a given matrix of doubles, divide each element by the sum of 
the elements in the row.
 
Note:  Could later have norm_sum_mat_rows_and_keep(), which keeps a vector of
the row sums, returning it (analogous to prob_mixture_and_keep()).
AG
*******************************************************************************/
int norm_sum_dmat_rows(double **m, int nr, int nc)
{
  int   i;
  double *curr_row;

  for (i = 1; i <= nr; i++)
  {
    curr_row = m[i];
    norm_sum_dvec(curr_row, nc);
  }

  return (UT_OK);
}


/*******************************************************************************
SUM_LOG_VEC
Given a vector, return the sum of the log() of each element.
RG
*******************************************************************************/
float sum_log_vec(float *v, int n)
{
  float *p;
  float *p_end;
  float sum = 0.0;

  /* assign pointer to last element */
  p_end = &v[n];

  for (p = &v[1]; p <= p_end; p++)
    sum += log((double) (*p));

  return (sum);
}


/*******************************************************************************
SUM_LOG_DVEC
Given a vector of doubles, return the sum of the log() of each element.
RG
*******************************************************************************/
double sum_log_dvec(double *v, int n)
{
  double *p;
  double *p_end;
  double sum = 0.0;

  /* assign pointer to last element */
  p_end = &v[n];

  for (p = &v[1]; p <= p_end; p++)
    sum += log(*p);

  return (sum);
}


/*******************************************************************************
SUM_LOG_MAT
Given a matrix, return the sum of the log() of each element.
RG
*******************************************************************************/
float sum_log_mat(float **m, int nr, int nc)
{
  float *p;
  float *p_end;
  float sum = 0.0;

  /* assign pointer to last element */
  p_end = &m[nr][nc];

  for (p = &m[1][1]; p <= p_end; p++)
    sum += log((double) (*p));

  return (sum);
}


/*******************************************************************************
SUM_LOG_DMAT
Given a matrix of doubles, return the sum of the log() of each element.
RG
*******************************************************************************/
double sum_log_dmat(double **m, int nr, int nc)
{
  double *p;
  double *p_end;
  double sum = 0.0;

  /* assign pointer to last element */
  p_end = &m[nr][nc];

  for (p = &m[1][1]; p <= p_end; p++)
    sum += log(*p);

  return (sum);
}


/*******************************************************************************
MAX_VEC
Return the maximum value in a vector.
RG
*******************************************************************************/
float max_vec(float *v, int n)
{
  float  *p;
  float  *p_end;
  float   maxval;

  /* use first element as initial maximum */
  maxval = v[1];

  /* assign pointer to last element */
  p_end = &v[n];

  /* search for maximum element */
  for (p = &v[2]; p <= p_end; p++)
    if (*p > maxval)
      maxval = *p;

  return (maxval);
}


/*******************************************************************************
MAX_DVEC
Return the maximum value in a vector of doubles.
RG
*******************************************************************************/
double max_dvec(double *v, int n)
{
  double  *p;
  double  *p_end;
  double   maxval;

  /* use first element as initial maximum */
  maxval = v[1];

  /* assign pointer to last element */
  p_end = &v[n];

  /* search for maximum element */
  for (p = &v[2]; p <= p_end; p++)
    if (*p > maxval)
      maxval = *p;

  return (maxval);
}


/*******************************************************************************
MAX_IVEC
Return the maximum value in a vector of integers.
RG
*******************************************************************************/
int max_ivec(int *v, int n)
{
  int  *p;
  int  *p_end;
  int   maxval;

  /* use first element as initial maximum */
  maxval = v[1];

  /* assign pointer to last element */
  p_end = &v[n];

  /* search for maximum element */
  for (p = &v[2]; p <= p_end; p++)
    if (*p > maxval)
      maxval = *p;

  return (maxval);
}


/*******************************************************************************
MAX_CVEC
Return the maximum value in a vector of unsigned chars.
RG
*******************************************************************************/
unsigned char max_cvec(unsigned char *v, int n)
{
  unsigned char  *p;
  unsigned char  *p_end;
  unsigned char   maxval;

  /* use first element as initial maximum */
  maxval = v[1];

  /* assign pointer to last element */
  p_end = &v[n];

  /* search for maximum element */
  for (p = &v[2]; p <= p_end; p++)
    if (*p > maxval)
      maxval = *p;

  return (maxval);
}


/*******************************************************************************
MIN_VEC
Return the minimum value in a vector.
RG
*******************************************************************************/
float min_vec(float *v, int n)
{
  float  *p;
  float  *p_end;
  float   minval;

  /* use first element as initial maximum */
  minval = v[1];

  /* assign pointer to last element */
  p_end = &v[n];

  /* search for maximum element */
  for (p = &v[2]; p <= p_end; p++)
    if (*p < minval)
      minval = *p;

  return (minval);
}


/*******************************************************************************
MIN_DVEC
Return the minimum value in a vector of doubles.
RG
*******************************************************************************/
double min_dvec(double *v, int n)
{
  double  *p;
  double  *p_end;
  double   minval;

  /* use first element as initial maximum */
  minval = v[1];

  /* assign pointer to last element */
  p_end = &v[n];

  /* search for maximum element */
  for (p = &v[2]; p <= p_end; p++)
    if (*p < minval)
      minval = *p;

  return (minval);
}


/*******************************************************************************
MIN_IVEC
Return the minimum value in a vector of integers.
RG
*******************************************************************************/
int min_ivec(int *v, int n)
{
  int  *p;
  int  *p_end;
  int   minval;

  /* use first element as initial maximum */
  minval = v[1];

  /* assign pointer to last element */
  p_end = &v[n];

  /* search for maximum element */
  for (p = &v[2]; p <= p_end; p++)
    if (*p < minval)
      minval = *p;

  return (minval);
}


/*******************************************************************************
MIN_CVEC
Return the minimum value in a vector of unsigned chars.
RG
*******************************************************************************/
unsigned char min_cvec(unsigned char *v, int n)
{
  unsigned char  *p;
  unsigned char  *p_end;
  unsigned char   minval;

  /* use first element as initial maximum */
  minval = v[1];

  /* assign pointer to last element */
  p_end = &v[n];

  /* search for maximum element */
  for (p = &v[2]; p <= p_end; p++)
    if (*p < minval)
      minval = *p;

  return (minval);
}


/*******************************************************************************
MAX_MAT
Return the maximum value of a matrix.
RG
*******************************************************************************/
float max_mat(float **m, int nr, int nc)
{
  float *p;
  float *p_end;
  float maxval;
 
  /* assign pointer to last element */
  p_end = &m[nr][nc];
 
  maxval = m[1][1];
 
  for (p = &m[1][2]; p <= p_end; p++)
    if (*p > maxval)
      maxval = *p;
 
  return (maxval);
}


/*******************************************************************************
MAX_DMAT
Return the maximum value of a matrix of doubles.
RG
*******************************************************************************/
double max_dmat(double **m, int nr, int nc)
{
  double *p;
  double *p_end;
  double maxval;
 
  /* assign pointer to last element */
  p_end = &m[nr][nc];
 
  maxval = m[1][1];
 
  for (p = &m[1][2]; p <= p_end; p++)
    if (*p > maxval)
      maxval = *p;
 
  return (maxval);
}


/*******************************************************************************
MAX_IMAT
Return the maximum value of a matrix of integers.
RG
*******************************************************************************/
int max_imat(int **m, int nr, int nc)
{
  int *p;
  int *p_end;
  int maxval;
 
  /* assign pointer to last element */
  p_end = &m[nr][nc];
 
  maxval = m[1][1];
 
  for (p = &m[1][2]; p <= p_end; p++)
    if (*p > maxval)
      maxval = *p;
 
  return (maxval);
}


/*******************************************************************************
MAX_CMAT
Return the maximum value of a matrix of unsigned chars.
RG
*******************************************************************************/
unsigned char max_cmat(unsigned char **m, int nr, int nc)
{
  unsigned char *p;
  unsigned char *p_end;
  unsigned char maxval;
 
  /* assign pointer to last element */
  p_end = &m[nr][nc];
 
  maxval = m[1][1];
 
  for (p = &m[1][2]; p <= p_end; p++)
    if (*p > maxval)
      maxval = *p;
 
  return (maxval);
}


/*******************************************************************************
MIN_MAT
Return the minimum value of a matrix.
RG
*******************************************************************************/
float min_mat(float **m, int nr, int nc)
{
  float *p;
  float *p_end;
  float minval;
 
  /* assign pointer to last element */
  p_end = &m[nr][nc];
 
  minval = m[1][1];
 
  for (p = &m[1][2]; p <= p_end; p++)
    if (*p < minval)
      minval = *p;
 
  return (minval);
}


/*******************************************************************************
MIN_DMAT
Return the minimum value of a matrix of doubles.
RG
*******************************************************************************/
double min_dmat(double **m, int nr, int nc)
{
  double *p;
  double *p_end;
  double minval;
 
  /* assign pointer to last element */
  p_end = &m[nr][nc];
 
  minval = m[1][1];
 
  for (p = &m[1][2]; p <= p_end; p++)
    if (*p < minval)
      minval = *p;
 
  return (minval);
}


/*******************************************************************************
MIN_IMAT
Return the minimum value of a matrix of integers.
RG
*******************************************************************************/
int min_imat(int **m, int nr, int nc)
{
  int *p;
  int *p_end;
  int minval;
 
  /* assign pointer to last element */
  p_end = &m[nr][nc];
 
  minval = m[1][1];
 
  for (p = &m[1][2]; p <= p_end; p++)
    if (*p < minval)
      minval = *p;
 
  return (minval);
}


/*******************************************************************************
MIN_CMAT
Return the minimum value of a matrix of unsigned chars.
RG
*******************************************************************************/
int min_cmat(unsigned char **m, int nr, int nc)
{
  unsigned char *p;
  unsigned char *p_end;
  unsigned char minval;
 
  /* assign pointer to last element */
  p_end = &m[nr][nc];
 
  minval = m[1][1];
 
  for (p = &m[1][2]; p <= p_end; p++)
    if (*p < minval)
      minval = *p;
 
  return (minval);
}


/*******************************************************************************
ARG_MAX_VEC
Return the index of the maximum value in a vector.
RG
*******************************************************************************/
int arg_max_vec(float *v, int n)
{
  int     i;
  float  *p;
  float   maxval;
  int     arg;

  maxval = v[1];
  arg = 1;

  for (i = 2, p = &v[2]; i <= n; i++, p++)
    if (*p > maxval) {
      maxval = *p;
      arg = i;
    }

  return (arg);
}


/*******************************************************************************
ARG_MAX_DVEC
Return the index of the maximum value in a vector of doubles.
RG
*******************************************************************************/
int arg_max_dvec(double *v, int n)
{
  int     i;
  double *p;
  double  maxval;
  int     arg;

  maxval = v[1];
  arg = 1;

  for (i = 2, p = &v[2]; i <= n; i++, p++)
    if (*p > maxval) {
      maxval = *p;
      arg = i;
    }

  return (arg);
}


/*******************************************************************************
ARG_MAX_IVEC
Return the index of the maximum value in a vector of integers.
RG
*******************************************************************************/
int arg_max_ivec(int *v, int n)
{
  int     i;
  int    *p;
  int     maxval;
  int     arg;

  maxval = v[1];
  arg = 1;

  for (i = 2, p = &v[2]; i <= n; i++, p++)
    if (*p > maxval) {
      maxval = *p;
      arg = i;
    }

  return (arg);
}


/*******************************************************************************
ARG_MAX_CVEC
Return the index of the maximum value in a vector of unsigned chars.
RG
*******************************************************************************/
int arg_max_cvec(unsigned char *v, int n)
{
  int               i;
  unsigned char    *p;
  unsigned char     maxval;
  int               arg;

  maxval = v[1];
  arg = 1;

  for (i = 2, p = &v[2]; i <= n; i++, p++)
    if (*p > maxval) {
      maxval = *p;
      arg = i;
    }

  return (arg);
}


/*******************************************************************************
ARG_MIN_VEC
Return the index of the minimum value in a vector.
RG
*******************************************************************************/
int arg_min_vec(float *v, int n)
{
  int     i;
  float  *p;
  float   minval;
  int     arg;

  minval = v[1];
  arg = 1;

  for (i = 2, p = &v[2]; i <= n; i++, p++)
    if (*p < minval) {
      minval = *p;
      arg = i;
    }

  return (arg);
}


/*******************************************************************************
ARG_MIN_DVEC
Return the index of the minimum value in a vector of doubles.
RG
*******************************************************************************/
int arg_min_dvec(double *v, int n)
{
  int     i;
  double *p;
  double  minval;
  int     arg;

  minval = v[1];
  arg = 1;

  for (i = 2, p = &v[2]; i <= n; i++, p++)
    if (*p < minval) {
      minval = *p;
      arg = i;
    }

  return (arg);
}


/*******************************************************************************
ARG_MIN_IVEC
Return the index of the minimum value in a vector of integers.
RG
*******************************************************************************/
int arg_min_ivec(int *v, int n)
{
  int     i;
  int    *p;
  int     minval;
  int     arg;

  minval = v[1];
  arg = 1;

  for (i = 2, p = &v[2]; i <= n; i++, p++)
    if (*p < minval) {
      minval = *p;
      arg = i;
    }

  return (arg);
}


/*******************************************************************************
ARG_MIN_CVEC
Return the index of the minimum value in a vector of unsigned chars.
RG
*******************************************************************************/
int arg_min_cvec(unsigned char *v, int n)
{
  int               i;
  unsigned char    *p;
  unsigned char     minval;
  int               arg;

  minval = v[1];
  arg = 1;

  for (i = 2, p = &v[2]; i <= n; i++, p++)
    if (*p < minval) {
      minval = *p;
      arg = i;
    }

  return (arg);
}


/*******************************************************************************
MINMAX_OF_COLS
For each of k columns in a matrix, find the minimum and maximum values, and
the range (difference between the two).  Pass in a size k vector for each of 
these latter sets of values, and they will be filled in by this function.  
AG
*******************************************************************************/
int minmax_of_cols(float **mat, int nr, int nc, float *minval, float *maxval, 
                   float *range)
{
  int i, j;

  /* for each attribute, find the min and max */
  for (j = 1; j <= nc; j++)
    minval[j] = maxval[j] = mat[1][j];

  for (i = 2; i <= nr; i++)
    for (j = 1; j <= nc; j++)
    {
      if (mat[i][j] < minval[j])
        minval[j] = mat[i][j];
      if (mat[i][j] > maxval[j])
        maxval[j] = mat[i][j];
    }

  /* for each attribute, compute the range */
  for (j = 1; j <= nc; j++)
    range[j] = maxval[j] - minval[j];
  
  return (UT_OK);
}


/*******************************************************************************
RANGE_VEC
Return the range of values (difference between max and min values) in a vector.
This value may be negative.
RG
*******************************************************************************/
float range_vec(float *v, int n)
{
  float  *p;
  float  *p_end;
  float   minval, maxval;

  /* use first element as initial minimum and maximum */
  minval = v[1];
  maxval = v[1];
  
  /* assign pointer to last element */
  p_end = &v[n];

  /* search for minimum and maximum elements */
  for (p = &v[2]; p <= p_end; p++) {
    if (*p < minval)
      minval = *p;
    if (*p > maxval)
      maxval = *p;
  }

  return (maxval - minval);
}


/*******************************************************************************
RANGE_DVEC
Return the range of values (difference between max and min values) in a vector
of doubles.  This value may be negative.
RG
*******************************************************************************/
double range_dvec(double *v, int n)
{
  double  *p;
  double  *p_end;
  double   minval, maxval;

  /* use first element as initial minimum and maximum */
  minval = v[1];
  maxval = v[1];
  
  /* assign pointer to last element */
  p_end = &v[n];

  /* search for minimum and maximum elements */
  for (p = &v[2]; p <= p_end; p++) {
    if (*p < minval)
      minval = *p;
    if (*p > maxval)
      maxval = *p;
  }

  return (maxval - minval);
}


/*******************************************************************************
RANGE_MAT
Return the range of values (difference between max and min values) in a matrix.
This value may be negative.
RG
*******************************************************************************/
float range_mat(float **m, int nr, int nc)
{
  float  *p;
  float  *p_end;
  float   minval, maxval;

  /* use first element as initial minimum and maximum */
  minval = m[1][1];
  maxval = m[1][1];
  
  /* assign pointer to last element */
  p_end = &m[nr][nc];

  /* search for minimum and maximum elements */
  for (p = &m[1][2]; p <= p_end; p++) {
    if (*p < minval)
      minval = *p;
    if (*p > maxval)
      maxval = *p;
  }

  return (maxval - minval);
}


/*******************************************************************************
RANGE_DMAT
Return the range of values (difference between max and min values) in a matrix
of doubles.  This value may be negative.
RG
*******************************************************************************/
double range_dmat(double **m, int nr, int nc)
{
  double  *p;
  double  *p_end;
  double   minval, maxval;

  /* use first element as initial minimum and maximum */
  minval = m[1][1];
  maxval = m[1][1];
  
  /* assign pointer to last element */
  p_end = &m[nr][nc];

  /* search for minimum and maximum elements */
  for (p = &m[1][2]; p <= p_end; p++) {
    if (*p < minval)
      minval = *p;
    if (*p > maxval)
      maxval = *p;
  }

  return (maxval - minval);
}


/*******************************************************************************
SCALE_VEC
Shift and scale the values of a vector so that they lie between 0 and 1.
RG
*******************************************************************************/
int scale_vec(float *v, int n)
{
  float  *p;
  float  *p_end;
  float   minval;
  float   maxval;
  float   scaling;
  
  /* assign pointer to last element */
  p_end = &v[n];

  /* use first element as initial minimum and maximum */
  minval = v[1];
  maxval = v[1];
  
  /* search for minimum and maximum elements */
  for (p = &v[2]; p <= p_end; p++) {
    if (*p < minval)
      minval = *p;
    if (*p > maxval)
      maxval = *p;
  }

  /* calculate scaling factor */
  scaling = 1.0 / (maxval - minval);

  /* now rescale elements onto new range of values */
  for (p = &v[1]; p <= p_end; p++) {
    *p -= minval;
    *p *= scaling;
  }

  return (UT_OK);
}


/*******************************************************************************
SCALE_DVEC
Shift and scale the values of a vector of doubles so that they lie between 0 
and 1.
RG
*******************************************************************************/
int scale_dvec(double *v, int n)
{
  double  *p;
  double  *p_end;
  double   minval;
  double   maxval;
  double   scaling;
  
  /* assign pointer to last element */
  p_end = &v[n];

  /* use first element as initial minimum and maximum */
  minval = v[1];
  maxval = v[1];
  
  /* search for minimum and maximum elements */
  for (p = &v[2]; p <= p_end; p++) {
    if (*p < minval)
      minval = *p;
    if (*p > maxval)
      maxval = *p;
  }

  /* calculate scaling factor */
  scaling = 1.0 / (maxval - minval);

  /* now rescale elements onto new range of values */
  for (p = &v[1]; p <= p_end; p++) {
    *p -= minval;
    *p *= scaling;
  }

  return (UT_OK);
}


/*******************************************************************************
SCALE_MAT
Shift and scale the values of a matrix so that they lie between 0 and 1.
RG
*******************************************************************************/
int scale_mat(float **m, int nr, int nc)
{
  float  *p;
  float  *p_end;
  float   minval;
  float   maxval;
  float   scaling;
  
  /* assign pointer to last element */
  p_end = &m[nr][nc];

  /* use first element as initial minimum and maximum */
  minval = m[1][1];
  maxval = m[1][1];
  
  /* search for minimum and maximum elements */
  for (p = &m[1][2]; p <= p_end; p++) {
    if (*p < minval)
      minval = *p;
    if (*p > maxval)
      maxval = *p;
  }

  /* calculate scaling factor */
  scaling = 1.0 / (maxval - minval);

  /* now rescale elements onto new range of values */
  for (p = &m[1][2]; p <= p_end; p++) {
    *p -= minval;
    *p *= scaling;
  }

  return (UT_OK);
}


/*******************************************************************************
SCALE_DMAT
Shift and scale the values of a matrix of doubles so that they lie between 0 
and 1.
RG
*******************************************************************************/
int scale_dmat(double **m, int nr, int nc)
{
  double  *p;
  double  *p_end;
  double   minval;
  double   maxval;
  double   scaling;
  
  /* assign pointer to last element */
  p_end = &m[nr][nc];

  /* use first element as initial minimum and maximum */
  minval = m[1][1];
  maxval = m[1][1];
  
  /* search for minimum and maximum elements */
  for (p = &m[1][2]; p <= p_end; p++) {
    if (*p < minval)
      minval = *p;
    if (*p > maxval)
      maxval = *p;
  }

  /* calculate scaling factor */
  scaling = 1.0 / (maxval - minval);

  /* now rescale elements onto new range of values */
  for (p = &m[1][2]; p <= p_end; p++) {
    *p -= minval;
    *p *= scaling;
  }

  return (UT_OK);
}


/*******************************************************************************
SCALE_RANGE_VEC
Shift and scale the values of a vector so that they lie in a specified
range of values.

minval is the new minimum value.
maxval is the new maximum value.
RG
*******************************************************************************/
int scale_range_vec(float *v, int n, float minval, float maxval)
{
  float  *p;
  float  *p_end;
  float   oldminval;
  float   oldmaxval;
  float   oldrange;
  float   scaling;
  
  /* assign pointer to last element */
  p_end = &v[n];

  /* use first element as initial minimum and maximum of original vector */
  oldminval = v[1];
  oldmaxval = v[1];
  
  /* search for minimum and maximum elements */
  for (p = &v[2]; p <= p_end; p++) {
    if (*p < oldminval)
      oldminval = *p;
    if (*p > oldmaxval)
      oldmaxval = *p;
  }

  /* calculate scaling factor */
  scaling = (maxval - minval) / (oldmaxval - oldminval);

  /* now rescale elements onto new range of values */
  for (p = &v[1]; p <= p_end; p++) {
    *p -= oldminval;
    *p *= scaling;
    *p += minval;
  }

  return (UT_OK);
}


/*******************************************************************************
SCALE_RANGE_DVEC
Shift and scale the values of a vector of doubles so that they lie in a 
specified range of values.

minval is the new minimum value.
maxval is the new maximum value.
RG
*******************************************************************************/
int scale_range_dvec(double *v, int n, double minval, double maxval)
{
  double  *p;
  double  *p_end;
  double   oldminval;
  double   oldmaxval;
  double   oldrange;
  double   scaling;
  
  /* assign pointer to last element */
  p_end = &v[n];

  /* use first element as initial minimum and maximum of original vector */
  oldminval = v[1];
  oldmaxval = v[1];
  
  /* search for minimum and maximum elements */
  for (p = &v[2]; p <= p_end; p++) {
    if (*p < oldminval)
      oldminval = *p;
    if (*p > oldmaxval)
      oldmaxval = *p;
  }

  /* calculate scaling factor */
  scaling = (maxval - minval) / (oldmaxval - oldminval);

  /* now rescale elements onto new range of values */
  for (p = &v[1]; p <= p_end; p++) {
    *p -= oldminval;
    *p *= scaling;
    *p += minval;
  }

  return (UT_OK);
}


/*******************************************************************************
SCALE_RANGE_MAT
Shift and scale the values of a matrix so that they lie in a specified
range of values.

minval is the new minimum value.
maxval is the new maximum value.
RG
*******************************************************************************/
int scale_range_mat(float **m, int nr, int nc, float minval, float maxval)
{
  float  *p;
  float  *p_end;
  float   oldminval;
  float   oldmaxval;
  float   oldrange;
  float   scaling;
  
  /* assign pointer to last element */
  p_end = &m[nr][nc];

  /* use first element as initial minimum and maximum of original vector */
  oldminval = m[1][1];
  oldmaxval = m[1][1];
  
  /* search for minimum and maximum elements */
  for (p = &m[1][2]; p <= p_end; p++) {
    if (*p < oldminval)
      oldminval = *p;
    if (*p > oldmaxval)
      oldmaxval = *p;
  }

  /* calculate scaling factor */
  scaling = (maxval - minval) / (oldmaxval - oldminval);

  /* now rescale elements onto new range of values */
  for (p = &m[1][2]; p <= p_end; p++) {
    *p -= oldminval;
    *p *= scaling;
    *p += minval;
  }

  return (UT_OK);
}


/*******************************************************************************
SCALE_RANGE_DMAT
Shift and scale the values of a matrix of doubles so that they lie in a 
specified range of values.

minval is the new minimum value.
maxval is the new maximum value.
RG
*******************************************************************************/
int scale_range_dmat(double **m, int nr, int nc, double minval, double maxval)
{
  double  *p;
  double  *p_end;
  double   oldminval;
  double   oldmaxval;
  double   oldrange;
  double   scaling;
  
  /* assign pointer to last element */
  p_end = &m[nr][nc];

  /* use first element as initial minimum and maximum of original vector */
  oldminval = m[1][1];
  oldmaxval = m[1][1];
  
  /* search for minimum and maximum elements */
  for (p = &m[1][2]; p <= p_end; p++) {
    if (*p < oldminval)
      oldminval = *p;
    if (*p > oldmaxval)
      oldmaxval = *p;
  }

  /* calculate scaling factor */
  scaling = (maxval - minval) / (oldmaxval - oldminval);

  /* now rescale elements onto new range of values */
  for (p = &m[1][2]; p <= p_end; p++) {
    *p -= oldminval;
    *p *= scaling;
    *p += minval;
  }

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_MATRIX
Create the transpose of a matrix of floats in a separate matrix.
RG
*******************************************************************************/
int transpose_matrix(float **a, int nr, int nc, float **a_trans)
{
  float  *p, *p_end;
  float  *p_trans, *p_end_trans;
  float  *p_col, *p_end_col;

  /* assign pointer to last element of transpose*/
  p_end_trans = &a_trans[nc][nr];
  
  /* assign pointer to last element of first transpose row */
  p_end_col = &a_trans[1][nr];

  /* start pointer at first element */
  p = &a[1][1];

  /* increment pointer to the original matrix element by element, but
     increment pointer to the transpose along each column */
  for (p_col = &a_trans[1][1]; p_col <= p_end_col; p_col++)
    for (p_trans = p_col; p_trans <= p_end_trans; p_trans += nr, p++)
      *p_trans = *p;

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_DMATRIX
Create the transpose of a matrix of doubles in a separate matrix.
RG
*******************************************************************************/
int transpose_dmatrix(double **a, int nr, int nc, double **a_trans)
{
  double  *p, *p_end;
  double  *p_trans, *p_end_trans;
  double  *p_col, *p_end_col;

  /* assign pointer to last element of transpose*/
  p_end_trans = &a_trans[nc][nr];
  
  /* assign pointer to last element of first transpose row */
  p_end_col = &a_trans[1][nr];

  /* start pointer at first element */
  p = &a[1][1];

  /* increment pointer to the original matrix element by element, but
     increment pointer to the transpose along each column */
  for (p_col = &a_trans[1][1]; p_col <= p_end_col; p_col++)
    for (p_trans = p_col; p_trans <= p_end_trans; p_trans += nr, p++)
      *p_trans = *p;

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IMATRIX
Create the transpose of a matrix of doubles in a separate matrix.
RG
*******************************************************************************/
int transpose_imatrix(int **a, int nr, int nc, int **a_trans)
{
  int     *p, *p_end;
  int     *p_trans, *p_end_trans;
  int     *p_col, *p_end_col;

  /* assign pointer to last element of transpose*/
  p_end_trans = &a_trans[nc][nr];
  
  /* assign pointer to last element of first transpose row */
  p_end_col = &a_trans[1][nr];

  /* start pointer at first element */
  p = &a[1][1];

  /* increment pointer to the original matrix element by element, but
     increment pointer to the transpose along each column */
  for (p_col = &a_trans[1][1]; p_col <= p_end_col; p_col++)
    for (p_trans = p_col; p_trans <= p_end_trans; p_trans += nr, p++)
      *p_trans = *p;

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_CMATRIX
Create the transpose of a matrix of unsigned chars in a separate matrix.
RG
*******************************************************************************/
int transpose_cmatrix(unsigned char **a, int nr, int nc, unsigned char **a_trans)
{
  unsigned char  *p, *p_end;
  unsigned char  *p_trans, *p_end_trans;
  unsigned char  *p_col, *p_end_col;

  /* assign pointer to last element of transpose*/
  p_end_trans = &a_trans[nc][nr];
  
  /* assign pointer to last element of first transpose row */
  p_end_col = &a_trans[1][nr];

  /* start pointer at first element */
  p = &a[1][1];

  /* increment pointer to the original matrix element by element, but
     increment pointer to the transpose along each column */
  for (p_col = &a_trans[1][1]; p_col <= p_end_col; p_col++)
    for (p_trans = p_col; p_trans <= p_end_trans; p_trans += nr, p++)
      *p_trans = *p;

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_ALLOC_MATRIX
Create the transpose of a matrix of floats in the same memory space as the
original matrix.  Takes as one of its arguments a vector for temporary
storage space, which must be of length at least equal to the number of rows
in the input matrix.  Allocation and deallocation may be required to maintain
the appropriate matrix data structure.
RG
*******************************************************************************/
int transpose_in_situ_alloc_matrix(float ***a, int nr, int nc, float *temp_vect,
                                   char *mem_choice)
{
  int     i, j, k;   
  float  *p;          /* pointer into the input matrix */
  float  *p_temp;     /* pointer into temporary values */
  float **m;          /* pointer to new vector of pointers to rows */
  int     skip;
  int     nr_less1;
  int     nc_less1;

  /****
   * Algorithm outline:
   * For each row in the transpose, skip through the matrix, picking out
   * the appropriate element of each column, and copy them into temporary
   * storage.  Then compress the remain parts of the untransposed matrix
   * to fill in the gaps, leaving a space in memory.  In the space created 
   * copy the stored elements, thus creating a new row.
   ****/

  p = &(*a)[1][1];

  nr_less1 = nr-1;
  nc_less1 = nc-1;

  skip = nc;

  /* extract columns and compose into rows */

  for (i = 1; i <= nc_less1; i++) {
    p_temp = &temp_vect[1]; /* p_temp points into the temporary storage */

    /* move p along so the it points to every "skip"th element */
    /* (ie, the values in a column) and copy the values into the */
    /* temporary storage */

    for (j = 1; j <= nr; j++) {
      *p_temp = *p;
      p += skip;
      p_temp++;
    }

    /* move the pointer back into the array */

    p -= skip;

    /* account for effective smaller column size now that an element 
       is removed */

    skip--;

    /* pack the remaining untransposed data into the last part of memory */
    /* this leaves space in memory in front of the packed data */

    for (j = 1; j <= nr_less1; j++)
      for (k = 1; k <= skip; k++) {
        *p = *(p-j);
        p--;
      }

    /* set pointer back to the beginning of the new space */

    p -= nr_less1;
    p_temp = &temp_vect[1];

    /* copy the stored elements into the new space */

    for (j = 1; j <= nr; j++) {
      *p = *p_temp;
      p++;
      p_temp++;
    }
  }

  /* make necessary changes to new pointer scheme */

  if (!strcmp(mem_choice, "realloc") && (nr != nc)) {

    /* allocate more memory and reassign pointers */
 
    m=(float **) malloc((size_t) ((nc+NR_END)*sizeof(float*)));
    if (!m)
      NR_error("allocation failure 1 in NR_matrix()");
    m += NR_END;
    m--;

    m[1] = (*a)[1];
    for(i = 2; i <= nc; i++)
      m[i] = m[i-1]+nr;

    free(*a);

    *a = m;
  }
  else
    if (nr > nc) { 

      /* reassign pointers and free excess memory */

      for (i = 2; i <= nc; i++)
        (*a)[i] = (*a)[i-1]+nr;
      free(&(*a)[i]);
    }
    else if (nc > nr) { 

      /* allocate more memory and reassign pointers */

      m=(float **) malloc((size_t) ((nc+NR_END)*sizeof(float*)));
      if (!m) 
        NR_error("allocation failure 1 in NR_matrix()");
      m += NR_END;
      m--;

      m[1] = (*a)[1];
      for(i = 2; i <= nc; i++)
        m[i] = m[i-1]+nr;

      free(*a);

      *a = m;
    }

  /* nothing needs to be done if nr = nc */

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_ALLOC_DMATRIX
Create the transpose of a matrix of doubles in the same memory space as the
original matrix.  Takes as one of its arguments a vector for temporary
storage space, which must be of length at least equal to the number of rows
in the input matrix.  Allocation and deallocation may be required to maintain
the appropriate matrix data structure.
RG
*******************************************************************************/
int transpose_in_situ_alloc_dmatrix(double ***a, int nr, int nc, 
		                    double *temp_vect, char *mem_choice)
{
  int      i, j, k;   
  double  *p;          /* pointer into the input matrix */
  double  *p_temp;     /* pointer into temporary values */
  double **m;          /* pointer to new vector of pointers to rows */
  int      skip;
d577 8
a584 1280
  /****
   * Algorithm outline:
   * For each row in the transpose, skip through the matrix, picking out
   * the appropriate element of each column, and copy them into temporary
   * storage.  Then compress the remain parts of the untransposed matrix
   * to fill in the gaps, leaving a space in memory.  In the space created 
   * copy the stored elements, thus creating a new row.
   ****/

  p = &(*a)[1][1];

  nr_less1 = nr-1;
  nc_less1 = nc-1;

  skip = nc;

  /* extract columns and compose into rows */

  for (i = 1; i <= nc_less1; i++) {
    p_temp = &temp_vect[1]; /* p_temp points into the temporary storage */

    /* move p along so the it points to every "skip"th element */
    /* (ie, the values in a column) and copy the values into the */
    /* temporary storage */

    for (j = 1; j <= nr; j++) {
      *p_temp = *p;
      p += skip;
      p_temp++;
    }

    /* move the pointer back into the array */

    p -= skip;

    /* account for effective smaller column size now that an element 
       is removed */

    skip--;

    /* pack the remaining untransposed data into the last part of memory */
    /* this leaves space in memory in front of the packed data */

    for (j = 1; j <= nr_less1; j++)
      for (k = 1; k <= skip; k++) {
        *p = *(p-j);
        p--;
      }

    /* set pointer back to the beginning of the new space */

    p -= nr_less1;
    p_temp = &temp_vect[1];

    /* copy the stored elements into the new space */

    for (j = 1; j <= nr; j++) {
      *p = *p_temp;
      p++;
      p_temp++;
    }
  }

  /* make necessary changes to new pointer scheme */

  if (!strcmp(mem_choice, "realloc") && (nr != nc)) {

    /* allocate more memory and reassign pointers */
 
    m=(double **) malloc((size_t) ((nc+NR_END)*sizeof(double*)));
    if (!m)
      NR_error("allocation failure 1 in NR_matrix()");
    m += NR_END;
    m--;

    m[1] = (*a)[1];
    for(i = 2; i <= nc; i++)
      m[i] = m[i-1]+nr;

    free(*a);

    *a = m;
  }
  else
    if (nr > nc) { 

      /* reassign pointers and free excess memory */

      for (i = 2; i <= nc; i++)
        (*a)[i] = (*a)[i-1]+nr;
      free(&(*a)[i]);
    }
    else if (nc > nr) { 

      /* allocate more memory and reassign pointers */

      m=(double **) malloc((size_t) ((nc+NR_END)*sizeof(double*)));
      if (!m) 
        NR_error("allocation failure 1 in NR_matrix()");
      m += NR_END;
      m--;

      m[1] = (*a)[1];
      for(i = 2; i <= nc; i++)
        m[i] = m[i-1]+nr;

      free(*a);

      *a = m;
    }

  /* nothing needs to be done if nr = nc */

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_ALLOC_IMATRIX
Create the transpose of a matrix of integers in the same memory space as the
original matrix.  Takes as one of its arguments a vector for temporary
storage space, which must be of length at least equal to the number of rows
in the input matrix.  Allocation and deallocation may be required to maintain
the appropriate matrix data structure.
RG
*******************************************************************************/
int transpose_in_situ_alloc_imatrix(int ***a, int nr, int nc, int *temp_vect, 
                                    char *mem_choice)
{
  int   i, j, k;   
  int  *p;          /* pointer into the input matrix */
  int  *p_temp;     /* pointer into temporary values */
  int **m;          /* pointer to new vector of pointers to rows */
  int   skip;
  int   nr_less1;
  int   nc_less1;

  /****
   * Algorithm outline:
   * For each row in the transpose, skip through the matrix, picking out
   * the appropriate element of each column, and copy them into temporary
   * storage.  Then compress the remain parts of the untransposed matrix
   * to fill in the gaps, leaving a space in memory.  In the space created 
   * copy the stored elements, thus creating a new row.
   ****/

  p = &(*a)[1][1];

  nr_less1 = nr-1;
  nc_less1 = nc-1;

  skip = nc;

  /* extract columns and compose into rows */

  for (i = 1; i <= nc_less1; i++) {
    p_temp = &temp_vect[1]; /* p_temp points into the temporary storage */

    /* move p along so the it points to every "skip"th element */
    /* (ie, the values in a column) and copy the values into the */
    /* temporary storage */

    for (j = 1; j <= nr; j++) {
      *p_temp = *p;
      p += skip;
      p_temp++;
    }

    /* move the pointer back into the array */

    p -= skip;

    /* account for effective smaller column size now that an element 
       is removed */

    skip--;

    /* pack the remaining untransposed data into the last part of memory */
    /* this leaves space in memory in front of the packed data */

    for (j = 1; j <= nr_less1; j++)
      for (k = 1; k <= skip; k++) {
        *p = *(p-j);
        p--;
      }

    /* set pointer back to the beginning of the new space */

    p -= nr_less1;
    p_temp = &temp_vect[1];

    /* copy the stored elements into the new space */

    for (j = 1; j <= nr; j++) {
      *p = *p_temp;
      p++;
      p_temp++;
    }
  }

  /* make necessary changes to new pointer scheme */

  if (!strcmp(mem_choice, "realloc") && (nr != nc)) {

    /* allocate more memory and reassign pointers */
 
    m=(int **) malloc((size_t) ((nc+NR_END)*sizeof(int*)));
    if (!m)
      NR_error("allocation failure 1 in NR_matrix()");
    m += NR_END;
    m--;

    m[1] = (*a)[1];
    for(i = 2; i <= nc; i++)
      m[i] = m[i-1]+nr;

    free(*a);

    *a = m;
  }
  else
    if (nr > nc) { 

      /* reassign pointers and free excess memory */

      for (i = 2; i <= nc; i++)
        (*a)[i] = (*a)[i-1]+nr;
      free(&(*a)[i]);
    }
    else if (nc > nr) { 

      /* allocate more memory and reassign pointers */

      m=(int **) malloc((size_t) ((nc+NR_END)*sizeof(int*)));
      if (!m) 
        NR_error("allocation failure 1 in NR_matrix()");
      m += NR_END;
      m--;

      m[1] = (*a)[1];
      for(i = 2; i <= nc; i++)
        m[i] = m[i-1]+nr;

      free(*a);

      *a = m;
    }

  /* nothing needs to be done if nr = nc */

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_ALLOC_CMATRIX
Create the transpose of a matrix of unsigned chars in the same memory space as 
the original matrix.  Takes as one of its arguments a vector for temporary
storage space, which must be of length at least equal to the number of rows
in the input matrix.  Allocation and deallocation may be required to maintain
the appropriate matrix data structure.
RG
*******************************************************************************/
int transpose_in_situ_alloc_cmatrix(unsigned char ***a, int nr, int nc, 
		                    unsigned char *temp_vect, char *mem_choice)
{
  int             i, j, k;   
  unsigned char  *p;          /* pointer into the input matrix */
  unsigned char  *p_temp;     /* pointer into temporary values */
  unsigned char **m;          /* pointer to new vector of pointers to rows */
  int             skip;
  int             nr_less1;
  int             nc_less1;

  /****
   * Algorithm outline:
   * For each row in the transpose, skip through the matrix, picking out
   * the appropriate element of each column, and copy them into temporary
   * storage.  Then compress the remain parts of the untransposed matrix
   * to fill in the gaps, leaving a space in memory.  In the space created 
   * copy the stored elements, thus creating a new row.
   ****/

  p = &(*a)[1][1];

  nr_less1 = nr-1;
  nc_less1 = nc-1;

  skip = nc;

  /* extract columns and compose into rows */

  for (i = 1; i <= nc_less1; i++) {
    p_temp = &temp_vect[1]; /* p_temp points into the temporary storage */

    /* move p along so the it points to every "skip"th element */
    /* (ie, the values in a column) and copy the values into the */
    /* temporary storage */

    for (j = 1; j <= nr; j++) {
      *p_temp = *p;
      p += skip;
      p_temp++;
    }

    /* move the pointer back into the array */

    p -= skip;

    /* account for effective smaller column size now that an element 
       is removed */

    skip--;

    /* pack the remaining untransposed data into the last part of memory */
    /* this leaves space in memory in front of the packed data */

    for (j = 1; j <= nr_less1; j++)
      for (k = 1; k <= skip; k++) {
        *p = *(p-j);
        p--;
      }

    /* set pointer back to the beginning of the new space */

    p -= nr_less1;
    p_temp = &temp_vect[1];

    /* copy the stored elements into the new space */

    for (j = 1; j <= nr; j++) {
      *p = *p_temp;
      p++;
      p_temp++;
    }
  }

  /* make necessary changes to new pointer scheme */

  if (!strcmp(mem_choice, "realloc") && (nr != nc)) {

    /* allocate more memory and reassign pointers */
 
    m=(unsigned char **) malloc((size_t) ((nc+NR_END)*sizeof(unsigned char*)));
    if (!m)
      NR_error("allocation failure 1 in NR_matrix()");
    m += NR_END;
    m--;

    m[1] = (*a)[1];
    for(i = 2; i <= nc; i++)
      m[i] = m[i-1]+nr;

    free(*a);

    *a = m;
  }
  else
    if (nr > nc) { 

      /* reassign pointers and free excess memory */

      for (i = 2; i <= nc; i++)
        (*a)[i] = (*a)[i-1]+nr;
      free(&(*a)[i]);
    }
    else if (nc > nr) { 

      /* allocate more memory and reassign pointers */

      m=(unsigned char **) malloc((size_t) ((nc+NR_END)*sizeof(unsigned char*)));
      if (!m) 
        NR_error("allocation failure 1 in NR_matrix()");
      m += NR_END;
      m--;

      m[1] = (*a)[1];
      for(i = 2; i <= nc; i++)
        m[i] = m[i-1]+nr;

      free(*a);

      *a = m;
    }

  /* nothing needs to be done if nr = nc */

  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_SQR_MATRIX
Create the transpose of a matrix of floats in the same memory space as the
original matrix.
RG
*******************************************************************************/
int transpose_in_situ_sqr_matrix(float **a, int n)
{
  int    i, j;
  float  *p_by_row, *p_by_col, *col_start, *row_start;
  float  temp;
 
  row_start = &a[1][1];
  col_start = &a[1][1];
 
  for (i = 1; i <= n; i++) {

    /* assign index pointers to the row and column being transposed */

    p_by_row = row_start;
    p_by_col = col_start;

    /* go through the row and column exchanging elements up to the diagonal */

    for (j = 1; j < i; j++) {

      /* switch the elements */

      temp = *p_by_row;
      *p_by_row = *p_by_col;
      *p_by_col = temp;

      p_by_row++; /* move to next element in the row */
      p_by_col += n; /* move to the next element in the column */
    }

    /* move pointers to the next row and column */

    row_start += n; /* move to the next row */
    col_start++; /* move to the next column */
  }
 
  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_SQR_DMATRIX
Create the transpose of a matrix of doubles in the same memory space as the
original matrix.
RG
*******************************************************************************/
int transpose_in_situ_sqr_dmatrix(double **a, int n)
{
  int      i, j;
  double  *p_by_row, *p_by_col, *col_start, *row_start;
  double   temp;
 
  row_start = &a[1][1];
  col_start = &a[1][1];
 
  for (i = 1; i <= n; i++) {

    /* assign index pointers to the row and column being transposed */

    p_by_row = row_start;
    p_by_col = col_start;

    /* go through the row and column exchanging elements up to the diagonal */

    for (j = 1; j < i; j++) {

      /* switch the elements */

      temp = *p_by_row;
      *p_by_row = *p_by_col;
      *p_by_col = temp;

      p_by_row++; /* move to next element in the row */
      p_by_col += n; /* move to the next element in the column */
    }

    /* move pointers to the next row and column */

    row_start += n; /* move to the next row */
    col_start++; /* move to the next column */
  }
 
  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_SQR_IMATRIX
Create the transpose of a matrix of integers in the same memory space as the
original matrix.
RG
*******************************************************************************/
int transpose_in_situ_sqr_imatrix(int **a, int n)
{
  int   i, j;
  int  *p_by_row, *p_by_col, *col_start, *row_start;
  int   temp;
 
  row_start = &a[1][1];
  col_start = &a[1][1];
 
  for (i = 1; i <= n; i++) {

    /* assign index pointers to the row and column being transposed */

    p_by_row = row_start;
    p_by_col = col_start;

    /* go through the row and column exchanging elements up to the diagonal */

    for (j = 1; j < i; j++) {

      /* switch the elements */

      temp = *p_by_row;
      *p_by_row = *p_by_col;
      *p_by_col = temp;

      p_by_row++; /* move to next element in the row */
      p_by_col += n; /* move to the next element in the column */
    }

    /* move pointers to the next row and column */

    row_start += n; /* move to the next row */
    col_start++; /* move to the next column */
  }
 
  return (UT_OK);
}


/*******************************************************************************
TRANSPOSE_IN_SITU_SQR_CMATRIX
Create the transpose of a matrix of unsigned chars in the same memory space as 
the original matrix.
RG
*******************************************************************************/
int transpose_in_situ_sqr_cmatrix(unsigned char **a, int n)
{
  int             i, j;
  unsigned char  *p_by_row, *p_by_col, *col_start, *row_start;
  unsigned char   temp;
 
  row_start = &a[1][1];
  col_start = &a[1][1];
 
  for (i = 1; i <= n; i++) {

    /* assign index pointers to the row and column being transposed */

    p_by_row = row_start;
    p_by_col = col_start;

    /* go through the row and column exchanging elements up to the diagonal */

    for (j = 1; j < i; j++) {

      /* switch the elements */

      temp = *p_by_row;
      *p_by_row = *p_by_col;
      *p_by_col = temp;

      p_by_row++; /* move to next element in the row */
      p_by_col += n; /* move to the next element in the column */
    }

    /* move pointers to the next row and column */

    row_start += n; /* move to the next row */
    col_start++; /* move to the next column */
  }
 
  return (UT_OK);
}


/*******************************************************************************
FLIP_VECTOR
Change a vector so that it has its elements in reverse order.
RG
*******************************************************************************/
int flip_vector(float *v, int n)
{
  float *p, *p_flip, *p_half_n;
  float  temp;
  int    half_n;

  half_n = (int) (n / 2);
  p_half_n = &v[half_n];

  p = &v[1];
  p_flip = &v[n];

  for (p = &v[1], p_flip = &v[n]; p <= p_half_n; p++, p_flip--) {
    temp = *p;
    *p = *p_flip;
    *p_flip = temp;
  }

  return (UT_OK);
}


/*******************************************************************************
FLIP_DVECTOR
Change a vector of doubles so that it has its elements in reverse order.
RG
*******************************************************************************/
int flip_dvector(double *v, int n)
{
  double *p, *p_flip, *p_half_n;
  double  temp;
  int     half_n;

  half_n = (int) (n / 2);
  p_half_n = &v[half_n];

  p = &v[1];
  p_flip = &v[n];

  for (p = &v[1], p_flip = &v[n]; p <= p_half_n; p++, p_flip--) {
    temp = *p;
    *p = *p_flip;
    *p_flip = temp;
  }

  return (UT_OK);
}


/*******************************************************************************
FLIP_IVECTOR
Change a vector of integers so that it has its elements in reverse order.
RG
*******************************************************************************/
int flip_ivector(int *v, int n)
{
  int *p, *p_flip, *p_half_n;
  int  temp;
  int  half_n;

  half_n = (int) (n / 2);
  p_half_n = &v[half_n];

  p = &v[1];
  p_flip = &v[n];

  for (p = &v[1], p_flip = &v[n]; p <= p_half_n; p++, p_flip--) {
    temp = *p;
    *p = *p_flip;
    *p_flip = temp;
  }

  return (UT_OK);
}


/*******************************************************************************
FLIP_CVECTOR
Change a vector of unsigned chars so that it has its elements in reverse order.
RG
*******************************************************************************/
int flip_cvector(unsigned char *v, int n)
{
  unsigned char *p, *p_flip, *p_half_n;
  unsigned char  temp;
  int            half_n;

  half_n = (int) (n / 2);
  p_half_n = &v[half_n];

  p = &v[1];
  p_flip = &v[n];

  for (p = &v[1], p_flip = &v[n]; p <= p_half_n; p++, p_flip--) {
    temp = *p;
    *p = *p_flip;
    *p_flip = temp;
  }

  return (UT_OK);
}


/*******************************************************************************
FLIP_LEFT_RIGHT_MATRIX
Change a matrix so that its columns are in reverse order.
RG
*******************************************************************************/
int flip_left_right_matrix(float **a, int nr, int nc)
{
  int    i, j;
  float *p_left, *p_right;
  float  temp;
  int    half_nc;
 
  half_nc = (int) (nc / 2);

  p_left = &a[1][1];
 
  for (i = 1; i <= nr; i++) {

    /* start index pointers at the beginning and end of a row */

    p_left = a[i];
    p_right = &a[i][nc];

    /* switch the values and move each pointer towards the center */

    for (j = 1; j <= half_nc; j++) {
      temp = *p_left;
      *p_left = *p_right;
      *p_right = temp;

      p_left++; /* move the pointer to the right */
      p_right--; /* move the pointer to the left */
    }
  }
 
  return (UT_OK);
}
 

/*******************************************************************************
FLIP_LEFT_RIGHT_DMATRIX
Change a matrix of doubles so that its columns are in reverse order.
RG
*******************************************************************************/
int flip_left_right_dmatrix(double **a, int nr, int nc)
{
  int     i, j;
  double *p_left, *p_right;
  double  temp;
  int     half_nc;
 
  half_nc = (int) (nc / 2);

  p_left = &a[1][1];
 
  for (i = 1; i <= nr; i++) {

    /* start index pointers at the beginning and end of a row */

    p_left = a[i];
    p_right = &a[i][nc];

    /* switch the values and move each pointer towards the center */

    for (j = 1; j <= half_nc; j++) {
      temp = *p_left;
      *p_left = *p_right;
      *p_right = temp;

      p_left++; /* move the pointer to the right */
      p_right--; /* move the pointer to the left */
    }
  }
 
  return (UT_OK);
}


/*******************************************************************************
FLIP_LEFT_RIGHT_IMATRIX
Change a matrix of integers so that its columns are in reverse order.
RG
*******************************************************************************/
int flip_left_right_imatrix(int **a, int nr, int nc)
{
  int  i, j;
  int *p_left, *p_right;
  int  temp;
  int  half_nc;
 
  half_nc = (int) (nc / 2);

  p_left = &a[1][1];
 
  for (i = 1; i <= nr; i++) {

    /* start index pointers at the beginning and end of a row */

    p_left = a[i];
    p_right = &a[i][nc];

    /* switch the values and move each pointer towards the center */

    for (j = 1; j <= half_nc; j++) {
      temp = *p_left;
      *p_left = *p_right;
      *p_right = temp;

      p_left++; /* move the pointer to the right */
      p_right--; /* move the pointer to the left */
    }
  }
 
  return (UT_OK);
}


/*******************************************************************************
FLIP_LEFT_RIGHT_CMATRIX
Change a matrix of unsigned chars so that its columns are in reverse order.
RG
*******************************************************************************/
int flip_left_right_cmatrix(unsigned char **a, int nr, int nc)
{
  int            i, j;
  unsigned char *p_left, *p_right;
  unsigned char  temp;
  int            half_nc;
 
  half_nc = (int) (nc / 2);

  p_left = &a[1][1];
 
  for (i = 1; i <= nr; i++) {

    /* start index pointers at the beginning and end of a row */

    p_left = a[i];
    p_right = &a[i][nc];

    /* switch the values and move each pointer towards the center */

    for (j = 1; j <= half_nc; j++) {
      temp = *p_left;
      *p_left = *p_right;
      *p_right = temp;

      p_left++; /* move the pointer to the right */
      p_right--; /* move the pointer to the left */
    }
  }
 
  return (UT_OK);
}


/*******************************************************************************
FLIP_TOP_BOTTOM_MATRIX
Change a matrix so that its rows are in reverse order.
RG
*******************************************************************************/
int flip_top_bottom_matrix(float **a, int nr, int nc)
{
  int    i, j;
  float *p_top, *p_bottom;
  float  temp;
  int    half_nr;
 
  half_nr = (int) (nr / 2);

  p_top = &a[1][1];
 
  for (i = 1; i <= half_nr; i++) {

    /* one pointer naturally starts at the bottommost unflipped top row */
    /* start the second pointer at the topmost unflipped bottom row */

    p_bottom = a[nr - i + 1];

    /* switch the values and move each pointer down the row */

    for (j = 1; j <= nc; j++) {
      temp = *p_top;
      *p_top = *p_bottom;
      *p_bottom = temp;

      p_top++; /* move the pointer right */
      p_bottom++; /* move the pointer right */
    }
  }
 
  return (UT_OK);
}


/*******************************************************************************
FLIP_TOP_BOTTOM_DMATRIX
Change a matrix of doubles so that its rows are in reverse order.
RG
*******************************************************************************/
int flip_top_bottom_dmatrix(double **a, int nr, int nc)
{
  int     i, j;
  double *p_top, *p_bottom;
  double  temp;
  int     half_nr;
 
  half_nr = (int) (nr / 2);

  p_top = &a[1][1];
 
  for (i = 1; i <= half_nr; i++) {

    /* one pointer naturally starts at the bottommost unflipped top row */
    /* start the second pointer at the topmost unflipped bottom row */

    p_bottom = a[nr - i + 1];

    /* switch the values and move each pointer down the row */

    for (j = 1; j <= nc; j++) {
      temp = *p_top;
      *p_top = *p_bottom;
      *p_bottom = temp;

      p_top++; /* move the pointer right */
      p_bottom++; /* move the pointer right */
    }
  }
 
  return (UT_OK);
}


/*******************************************************************************
FLIP_TOP_BOTTOM_IMATRIX
Change a matrix of integers so that its rows are in reverse order.
RG
*******************************************************************************/
int flip_top_bottom_imatrix(int **a, int nr, int nc)
{
  int  i, j;
  int *p_top, *p_bottom;
  int  temp;
  int  half_nr;
 
  half_nr = (int) (nr / 2);

  p_top = &a[1][1];
 
  for (i = 1; i <= half_nr; i++) {

    /* one pointer naturally starts at the bottommost unflipped top row */
    /* start the second pointer at the topmost unflipped bottom row */

    p_bottom = a[nr - i + 1];

    /* switch the values and move each pointer down the row */

    for (j = 1; j <= nc; j++) {
      temp = *p_top;
      *p_top = *p_bottom;
      *p_bottom = temp;

      p_top++; /* move the pointer right */
      p_bottom++; /* move the pointer right */
    }
  }
 
  return (UT_OK);
}


/*******************************************************************************
FLIP_TOP_BOTTOM_CMATRIX
Change a matrix of unsigned chars so that its rows are in reverse order.
RG
*******************************************************************************/
int flip_top_bottom_cmatrix(unsigned char **a, int nr, int nc)
{
  int            i, j;
  unsigned char *p_top, *p_bottom;
  unsigned char  temp;
  int            half_nr;
 
  half_nr = (int) (nr / 2);

  p_top = &a[1][1];
 
  for (i = 1; i <= half_nr; i++) {

    /* one pointer naturally starts at the bottommost unflipped top row */
    /* start the second pointer at the topmost unflipped bottom row */

    p_bottom = a[nr - i + 1];

    /* switch the values and move each pointer down the row */

    for (j = 1; j <= nc; j++) {
      temp = *p_top;
      *p_top = *p_bottom;
      *p_bottom = temp;

      p_top++; /* move the pointer right */
      p_bottom++; /* move the pointer right */
    }
  }
 
  return (UT_OK);
}


/*******************************************************************************
INVERT_ALLOC_MAT
Invert a matrix.  
Destroys the original.  
Allocates some memory for use in the calculation.

Ref: Numerical Recipes 2e, p. 48.
AG
*******************************************************************************/
int invert_alloc_mat(float **mat, int n, float **inv)
{
  int i, j, *index;
  float d, *col;

  /* first check for singleton matrix case */
  if (n == 1) {
    inv[1][1] = 1.0/mat[1][1];
    return (UT_OK);
  }

  /* allocate temporary storage */
  col = NR_vector(1,n);
  if (col == (float*)NULL) {
    err_printf();
    log_printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }
  index = NR_ivector(1,n);
  if (index == (int*)NULL) {
    err_printf();
    log_printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }
  
  /* invert, using LU decomposition followed by backsubstitution */
  NR_ludcmp(mat,n,index,&d);
  for(j=1; j<=n; j++) {
    for (i=1; i<=n; i++)
      col[i] = 0.0;
    col[j] = 1.0;
    NR_lubksb(mat,n,index,col);
    for (i=1; i<=n; i++)
      inv[i][j] = col[i];
  }
  
  /* delete temporary storage */
  NR_free_vector(col, 1, n);
  NR_free_ivector(index, 1, n);
  
  return (UT_OK);
}

/*******************************************************************************
INVERT_COPY_ALLOC_MAT
Invert matrix copy.  
Like invert_mat(), but does not destroy the original; makes a copy first.
Allocates memory to hold a copy of the matrix.
AG
*******************************************************************************/
int invert_copy_alloc_mat(float **mat, int n, float **inv)
{
  float **mat_copy;

  /* make copy of matrix to be inverted */
  mat_copy = NR_matrix(1,n,1,n);
  copy_mat(mat, mat_copy, n, n);

  /* invert */
  invert_mat(mat_copy,n,inv);

  /* free the garbled matrix */
  NR_free_matrix(mat_copy,1,n,1,n);

  return (UT_OK);
}

/*******************************************************************************
DET_ALLOC_MAT
Determinant of a matrix.
Destroys the original.  
Allocates memory for use in the computation.
Ref: Numerical Recipes 2e, p. 49.
AG
*******************************************************************************/
float det_alloc_mat(float **mat, int n)
{
  int   j;
  int  *index;
  float d;

  /* allocate temporary storage */
  index = NR_ivector(1,n);
  if (index == (int*)NULL) {
    err_printf();
    log_printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }
  
  /* use a side-effect of LU decomposition, which returns d as +1 or -1 */
  NR_ludcmp(mat,n,index,&d);

  /* the determinant of an LU decomposed matrix is the product of the diagonal
     elements */
  for (j=1; j<=n; j++)
    d *= mat[j][j];
  
  return (d);
}

/*******************************************************************************
DET_COPY_ALLOC_MAT
Determinant of matrix copy.
Like det(), but does not destroy the original; makes a copy first.
Allocates memory to hold the copy.
AG
*******************************************************************************/
float det_copy_alloc_mat(float **mat, int n)
{
  float **mat_copy, d;
  
  /* make copy of matrix */
  mat_copy = NR_matrix(1,n,1,n);
  copy_mat(mat, mat_copy, n, n);

  /* find determinant */
  d = det(mat_copy,n);

  /* free the garbled matrix */
  NR_free_matrix(mat_copy,1,n,1,n);

  return (d);
}


/*******************************************************************************
GRAB_ROW_MAT
Create the vector obtained from the specified row of a matrix.
RG
*******************************************************************************/
int grab_row_mat(float **mat, int index, int nc, float *vec)
{
  int    mem_size;
  float *p_vec;
  float *p_mat;

  mem_size = nc * sizeof(float);

  p_vec = &vec[1];
  p_mat = mat[index];

  memcpy(p_vec, p_mat, mem_size);

  return (UT_OK);
}


/*******************************************************************************
GRAB_ROW_DMAT
Create the vector obtained from the specified row of a matrix of doubles.
RG
*******************************************************************************/
int grab_row_dmat(double **mat, int index, int nc, double *vec)
{
  int     mem_size;
  double *p_vec;
  double *p_mat;

  mem_size = nc * sizeof(double);

  p_vec = &vec[1];
  p_mat = mat[index];

  memcpy(p_vec, p_mat, mem_size);

  return (UT_OK);
}


/*******************************************************************************
GRAB_ROW_IMAT
Create the vector obtained from the specified row of a matrix of integers.
RG
*******************************************************************************/
int grab_row_imat(int **mat, int index, int nc, int *vec)
{
  int  mem_size;
  int *p_vec;
  int *p_mat;

  mem_size = nc * sizeof(int);

  p_vec = &vec[1];
  p_mat = mat[index];

  memcpy(p_vec, p_mat, mem_size);

  return (UT_OK);
}


/*******************************************************************************
GRAB_ROW_CMAT
Create the vector obtained from the specified row of a matrix of unsigned chars.
RG
*******************************************************************************/
int grab_row_cmat(unsigned char **mat, int index, int nc, unsigned char *vec)
{
  int            mem_size;
  unsigned char *p_vec;
  unsigned char *p_mat;

  mem_size = nc * sizeof(unsigned char);

  p_vec = &vec[1];
  p_mat = mat[index];

  memcpy(p_vec, p_mat, mem_size);

  return (UT_OK);
}


/*******************************************************************************
GRAB_COL_MAT
Create the vector obtained from the specified column of a matrix.
AG
*******************************************************************************/
int grab_col_mat(float **mat, int index, int nr, float *vec)
{
  int   j;

  for (j=1; j <= nr; j++)
    vec[j] = mat[j][index];

  return (UT_OK);
}


/*******************************************************************************
GRAB_COL_DMAT
Create the vector obtained from the specified column of a matrix of doubles.
AG
*******************************************************************************/
int grab_col_dmat(double **mat, int index, int nr, double *vec)
{
  int   j;

  for (j=1; j <= nr; j++)
    vec[j] = mat[j][index];

  return (UT_OK);
}


/*******************************************************************************
GRAB_COL_IMAT
Create the vector obtained from the specified column of a matrix of integers.
AG
*******************************************************************************/
int grab_col_imat(int **mat, int index, int nr, int *vec)
{
  int   j;

  for (j=1; j <= nr; j++)
    vec[j] = mat[j][index];

  return (UT_OK);
}


/*******************************************************************************
GRAB_COL_CMAT
Create the vector obtained from the specified column of a matrix of unsigned
chars.
AG
*******************************************************************************/
int grab_col_cmat(unsigned char **mat, int index, int nr, unsigned char *vec)
{
  int   j;

  for (j=1; j <= nr; j++)
    vec[j] = mat[j][index];

  return (UT_OK);
}
d586 1
d588 2
a589 15
/*******************************************************************************
COPY_MAT_SECTION
Copy a rectangular section of one matrix into a part of another 
matrix by means of direct memory copy.  (a_tlr, a_tlc) is the top
left corner of the section in the source matrix.  (b_tlr, b_tlc) is
the top left corner of the section in the destination matrix.  (nr, nc)
are the dimensions of the matrix section to be copied.
RG
*******************************************************************************/
int copy_mat_section(float **a, float **b, int a_tlr, 
                      int a_tlc, int b_tlr, int b_tlc, int nr, int nc)
{
  int   i;
  int   mem_size;
  float *p_a, *p_b;
d591 1
a591 1
  /* calculate the number of bytes in a row of the section */
d593 1
a593 1
  mem_size = nc * sizeof(float);
d595 2
a596 1
  /* copy a section of A into B */
d598 3
a600 1
  for (i = 1; i <= nr; i++) {
d602 5
a606 1
    /* set pointers to the beginning of each row */
d608 1
a608 2
    p_a = &a[a_tlr + i - 1][a_tlc];
    p_b = &b[b_tlr + i - 1][b_tlc];
d610 1
a610 1
    /* copy a row of A into B */
d612 2
a613 2
    memcpy(p_b, p_a, mem_size);
  }
d615 1
a615 2
  return (UT_OK);
}
d617 2
d620 5
a624 16
/*******************************************************************************
COPY_IMAT_SECTION
Copy a rectangular section of one integer matrix into a part of another 
matrix by means of direct memory copy.  (a_tlr, a_tlc) is the top
left corner of the section in the source matrix.  (b_tlr, b_tlc) is
the top left corner of the section in the destination matrix.
matrix by means of direct memory copy.  (nr, nc) are the dimensions of
the matrix section to be copied.
RG
*******************************************************************************/
int copy_imat_section(int **a, int **b, int a_tlr, int a_tlc, int b_tlr, 
                       int b_tlc, int nr, int nc)
{
  int   i;
  int   mem_size;
  int   *p_a, *p_b;
d626 1
a626 1
  mem_size = nc * sizeof(int);
d628 2
a629 1
  /* copy a section of A into B */
d631 1
a631 3
  for (i = 1; i <= nr; i++) {
    p_a = &a[a_tlr + i - 1][a_tlc];
    p_b = &b[b_tlr + i - 1][b_tlc];
d633 5
a637 1
    memcpy(p_b, p_a, mem_size);
d640 1
a640 2
  return (UT_OK);
}
d642 1
d644 7
a650 15
/*******************************************************************************
COPY_CMAT_SECTION
Copy a rectangular section of one unsigned char matrix into a part of another 
matrix by means of direct memory copy.  (a_tlr, a_tlc) is the top
left corner of the section in the source matrix.  (b_tlr, b_tlc) is
the top left corner of the section in the destination matrix.  (nr, nc) are
the dimensions of the matrix section to be copied.
RG
*******************************************************************************/
int copy_cmat_section(unsigned char **a, unsigned char **b, int a_tlr, 
                       int a_tlc, int b_tlr, int b_tlc, int nr, int nc)
{
  int           i;
  int           mem_size;
  unsigned char *p_a, *p_b;
d652 3
a654 1
  mem_size = nc * sizeof(unsigned char);
d656 1
a656 1
  /* copy a section of A into B */
d658 1
a658 5
  for (i = 1; i <= nr; i++) {
    p_a = &a[a_tlr + i - 1][a_tlc];
    p_b = &b[b_tlr + i - 1][b_tlc];

    memcpy(p_b, p_a, mem_size);
d660 2
d663 1
a663 2
  return (UT_OK);
}
d665 5
d671 1
a671 15
/*******************************************************************************
COPY_DMAT_SECTION
Copy a rectangular section of one double matrix into a part of another 
matrix by means of direct memory copy.  (a_tlr, a_tlc) is the top
left corner of the section in the source matrix.  (b_tlr, b_tlc) is
the top left corner of the section in the destination matrix.  (nr, nc)
are the dimensions of the matrix section to be copied.
RG
*******************************************************************************/
int copy_dmat_section(double **a, double **b, int a_tlr, 
                       int a_tlc, int b_tlr, int b_tlc, int nr, int nc)
{
  int    i;
  int    mem_size;
  double *p_a, *p_b;
d673 5
a677 1
  mem_size = nc * sizeof(double);
d679 3
a681 1
  /* copy a section of A into B */
d683 1
a683 3
  for (i = 1; i <= nr; i++) {
    p_a = &a[a_tlr + i - 1][a_tlc];
    p_b = &b[b_tlr + i - 1][b_tlc];
d685 2
a686 2
    memcpy(p_b, p_a, mem_size);
  }
d688 1
a688 22
  return (UT_OK);
}


/*******************************************************************************
OVERWRITE_ROW_MAT
Overwrite the specified row of the matrix with a given vector of values.
The inverse operation of grab_row().
RG
*******************************************************************************/
int overwrite_row_mat(float **mat, int index, int nc, float *vec)
{
  int   mem_size;
  float *p_vec;
  float *p_mat;

  mem_size = nc * sizeof(float);

  p_vec = &vec[1];
  p_mat = mat[index];

  memcpy(p_mat, p_vec, mem_size);
d695 6
a700 3
OVERWRITE_ROW_DMAT
Overwrite the specified row of a matrix of doubles with a given vector of 
values.  The inverse operation of grab_row().
d703 2
a704 1
int overwrite_row_dmat(double **mat, int index, int nc, double *vec)
d706 7
a712 3
  int     mem_size;
  double *p_vec;
  double *p_mat;
d714 8
a721 1
  mem_size = nc * sizeof(double);
d723 1
a723 2
  p_vec = &vec[1];
  p_mat = mat[index];
d725 2
a726 1
  memcpy(p_mat, p_vec, mem_size);
d728 1
a728 2
  return (UT_OK);
}
d730 1
d732 2
a733 11
/*******************************************************************************
OVERWRITE_ROW_IMAT
Overwrite the specified row of a matrix of integers with a given vector of 
values.  The inverse operation of grab_row().
RG
*******************************************************************************/
int overwrite_row_imat(int **mat, int index, int nc, int *vec)
{
  int  mem_size;
  int *p_vec;
  int *p_mat;
d735 3
a737 1
  mem_size = nc * sizeof(int);
d739 5
a743 2
  p_vec = &vec[1];
  p_mat = mat[index];
d745 1
a745 1
  memcpy(p_mat, p_vec, mem_size);
d747 1
a747 2
  return (UT_OK);
}
d749 2
d752 1
a752 12
/*******************************************************************************
OVERWRITE_ROW_CMAT
Overwrite the specified row of a matrix of unsigned chars with a given vector 
of values.  The inverse operation of grab_row().
RG
*******************************************************************************/
int overwrite_row_cmat(unsigned char **mat, int index, int nc, 
		       unsigned char *vec)
{
  int  mem_size;
  unsigned char *p_vec;
  unsigned char *p_mat;
d754 2
a755 1
  mem_size = nc * sizeof(unsigned char);
d757 5
a761 137
  p_vec = &vec[1];
  p_mat = mat[index];

  memcpy(p_mat, p_vec, mem_size);

  return (UT_OK);
}


/*******************************************************************************
OVERWRITE_COL_MAT
Overwrite the specified column of the matrix with a given vector of values.
The inverse operation of grab_col().
AG
*******************************************************************************/
int overwrite_col_mat(float **mat, int index, int nr, float *vec)
{
  int j;

  for (j=1; j <= nr; j++)
    mat[j][index] = vec[j];

  return (UT_OK);
}


/*******************************************************************************
OVERWRITE_COL_DMAT
Overwrite the specified column of a matrix of doubles with a given vector of 
values.  The inverse operation of grab_col().
AG,RG
*******************************************************************************/
int overwrite_col_dmat(double **mat, int index, int nr, double *vec)
{
  int j;

  for (j=1; j <= nr; j++)
    mat[j][index] = vec[j];

  return (UT_OK);
}


/*******************************************************************************
OVERWRITE_COL_IMAT
Overwrite the specified column of a matrix of integers with a given vector of 
values.  The inverse operation of grab_col().
AG,RG
*******************************************************************************/
int overwrite_col_imat(int **mat, int index, int nr, int *vec)
{
  int j;

  for (j=1; j <= nr; j++)
    mat[j][index] = vec[j];

  return (UT_OK);
}


/*******************************************************************************
OVERWRITE_COL_CMAT
Overwrite the specified column of a matrix of unsigned chars with a given 
vector of values.  The inverse operation of grab_col().
AG,RG
*******************************************************************************/
int overwrite_col_cmat(unsigned char **mat, int index, int nr, 
                       unsigned char *vec)
{
  int j;

  for (j=1; j <= nr; j++)
    mat[j][index] = vec[j];

  return (UT_OK);
}


/*******************************************************************************
SET_MAT
Sets each of the values of a matrix to a specified number.

nr and nc are the dimensions of the matrix (num. rows and num. cols).
m is the input matrix.
constant is the amount to set all the values to.
AG
*******************************************************************************/
int set_mat(float **m, int nr, int nc, float constant)
{
  int     i,j;

  /* change each element of the vector */
  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++)
      m[i][j] = constant;

  return (UT_OK);
}

/*******************************************************************************
SET_IMAT
Sets each of the values of an integer matrix to a specified number.

nr and nc are the dimensions of the matrix (num. rows and num. cols).
m is the input matrix.
constant is the amount to set all the values to.
AG
*******************************************************************************/
int set_imat(int **m, int nr, int nc, int constant)
{
  int     i,j;

  /* change each element of the vector */
  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++)
      m[i][j] = constant;

  return (UT_OK);
}

/*******************************************************************************
SET_VEC
Sets each of the values of a vector to a specified number.

nc is the length of the vector (num. cols).
v is the input vector.
constant is the amount to set all the values to.
AG
*******************************************************************************/
int set_vec(float *v, int n,  float constant)
{
  int     i;

  /* change each element of the vector */
  for (i = 1; i <= n; i++) {
    v[i] = constant;
  }
d763 1
a763 2
  return (UT_OK);
}
d765 2
d768 1
a768 3
/*******************************************************************************
SET_IVEC
Sets each of the values of a vector of integers to a specified number.
d770 5
a774 12
nc is the length of the vector (num. cols).
v is the input vector.
constant is the amount to set all the values to.
AG
*******************************************************************************/
int set_ivec(int *v, int n, int constant)
{
  int     i;

  /* change each element of the vector */
  for (i = 1; i <= n; i++) {
    v[i] = constant;
d777 1
a777 2
  return (UT_OK);
}
d779 1
d781 7
a787 10
/*******************************************************************************
SET_DIAG_MAT
Set the diagonal of a square matrix to a given constant, and set the other
elements to zero.
RG
*******************************************************************************/
int set_diag_mat(float **m, int n, float constant)
{
  float *p, *p_end;
  int    n_plus_1;
d789 3
a791 1
  n_plus_1 = n + 1;
d793 1
a793 1
  fast_zero_mat(m, n, n);
d795 4
a798 1
  p_end = &m[n][n];
d800 1
a800 2
  for (p = &m[1][1]; p <= p_end; p += n_plus_1)
    *p = constant;
d802 5
a806 2
  return (UT_OK);
}
d808 1
d810 5
a814 10
/*******************************************************************************
SET_DIAG_DMAT
Set the diagonal of a square matrix of doubles to a given constant, and set 
the other elements to zero.
RG
*******************************************************************************/
int set_diag_dmat(double **m, int n, double constant)
{
  double *p, *p_end;
  int     n_plus_1;
d816 3
a818 1
  n_plus_1 = n + 1;
d820 1
a820 1
  fast_zero_dmat(m, n, n);
d822 2
a823 1
  p_end = &m[n][n];
d825 1
a825 2
  for (p = &m[1][1]; p <= p_end; p += n_plus_1)
    *p = constant;
d832 6
a837 3
SET_DIAG_IMAT
Set the diagonal of a square matrix of integers to a given constant, and set 
the other elements to zero.
d840 2
a841 1
int set_diag_imat(int **m, int n, int constant)
d843 16
a858 2
  int *p, *p_end;
  int  n_plus_1;
d860 1
a860 1
  n_plus_1 = n + 1;
d862 2
a863 1
  fast_zero_imat(m, n, n);
d865 1
a865 1
  p_end = &m[n][n];
d867 1
a867 2
  for (p = &m[1][1]; p <= p_end; p += n_plus_1)
    *p = constant;
d869 2
a870 2
  return (UT_OK);
}
d872 3
d876 5
a880 10
/*******************************************************************************
SET_DIAG_CMAT
Set the diagonal of a square matrix of unsigned chars to a given constant, and 
set the other elements to zero.
RG
*******************************************************************************/
int set_diag_cmat(unsigned char **m, int n, unsigned char constant)
{
  unsigned char *p, *p_end;
  int            n_plus_1;
d882 1
a882 1
  n_plus_1 = n + 1;
d884 1
a884 1
  fast_zero_cmat(m, n, n);
d886 2
a887 1
  p_end = &m[n][n];
d889 1
a889 2
  for (p = &m[1][1]; p <= p_end; p += n_plus_1)
    *p = constant;
d891 2
a892 2
  return (UT_OK);
}
d894 5
d900 1
a900 11
/*******************************************************************************
SET_BAND_DIAG_MAT
Set the diagonal band of a square matrix to a given constant, and set the other
elements to zero.  The diagonal band is defined as the diagonal plus a number
of strips of elements adjacent to it, on either side of it; this number is 
specified as an argument.
AG
*******************************************************************************/
int set_band_diag_mat(float **m, int n, int width, float constant)
{
  int i, j;
d902 2
a903 1
  fast_zero_mat(m, n, n);
d905 1
a905 4
  for (i = 1; i <= n; i++)
    for (j = 1; j <= n; j++)
      if ((i >= j-width) && (i <= j+width))
        m[i][j] = constant;
d907 6
a912 2
  return (UT_OK);
}
d914 1
d916 1
a916 11
/*******************************************************************************
SET_BAND_DIAG_DMAT
Set the diagonal band of a square matrix of doubles to a given constant, and 
set the other elements to zero.  The diagonal band is defined as the diagonal 
plus a number of strips of elements adjacent to it, on either side of it; this 
number is specified as an argument.
AG, RG
*******************************************************************************/
int set_band_diag_dmat(double **m, int n, int width, double constant)
{
  int i, j;
d918 7
a924 1
  fast_zero_dmat(m, n, n);
d926 3
a928 4
  for (i = 1; i <= n; i++)
    for (j = 1; j <= n; j++)
      if ((i >= j-width) && (i <= j+width))
        m[i][j] = constant;
d930 1
a930 2
  return (UT_OK);
}
d932 4
d937 1
a937 11
/*******************************************************************************
SET_BAND_DIAG_IMAT
Set the diagonal band of a square matrix of integers to a given constant, and 
set the other elements to zero.  The diagonal band is defined as the diagonal 
plus a number of strips of elements adjacent to it, on either side of it; this 
number is specified as an argument.
AG, RG
*******************************************************************************/
int set_band_diag_imat(int **m, int n, int width, int constant)
{
  int i, j;
d939 5
a943 1
  fast_zero_imat(m, n, n);
d945 1
a945 4
  for (i = 1; i <= n; i++)
    for (j = 1; j <= n; j++)
      if ((i >= j-width) && (i <= j+width))
        m[i][j] = constant;
d947 5
a951 2
  return (UT_OK);
}
d953 3
d957 1
a957 12
/*******************************************************************************
SET_BAND_DIAG_CMAT
Set the diagonal band of a square matrix of unsigned chars to a given constant, 
and set the other elements to zero.  The diagonal band is defined as the 
diagonal plus a number of strips of elements adjacent to it, on either side of 
it; this number is specified as an argument.
AG, RG
*******************************************************************************/
int set_band_diag_cmat(unsigned char **m, int n, int width, 
		       unsigned char constant)
{
  int i, j;
d959 2
a960 1
  fast_zero_imat(m, n, n);
d962 1
a962 4
  for (i = 1; i <= n; i++)
    for (j = 1; j <= n; j++)
      if ((i >= j-width) && (i <= j+width))
        m[i][j] = constant;
d969 4
a972 3
COPY_MAT
Copy a matrix "a" into a matrix "b".
RG, AG
d974 1
a974 1
int copy_mat(float **a, float **b, int nr, int nc)
d976 8
a983 2
  int   mem_size;
  float *p_a, *p_b;
d985 1
a985 2
  p_a = &a[1][1];
  p_b = &b[1][1];
d987 2
a988 1
  mem_size = nr * nc * sizeof(float);
d990 1
a990 1
  memcpy(p_b, p_a, mem_size);
d992 1
a992 2
  return (UT_OK);
}
d994 1
a994 9
/*******************************************************************************
COPY_IMAT
Copy a matrix of ints "a" into a matrix "b".
RG,AG
*******************************************************************************/
int copy_imat(int **a, int **b, int nr, int nc)
{
  int   mem_size;
  int   *p_a, *p_b;
d996 3
a998 2
  p_a = &a[1][1];
  p_b = &b[1][1];
d1000 3
a1002 1
  mem_size = nr * nc * sizeof(int);
d1004 1
a1004 1
  memcpy(p_b, p_a, mem_size);
d1006 4
d1013 1
d1015 4
a1018 3
COPY_DMAT
Copy a matrix of doubles "a" into a matrix "b".
RG,AG
d1020 1
a1020 1
int copy_dmat(double **a, double **b, int nr, int nc)
d1022 8
a1029 2
  int     mem_size;
  double  *p_a, *p_b;
d1031 1
a1031 2
  p_a = &a[1][1];
  p_b = &b[1][1];
d1033 2
a1034 1
  mem_size = nr * nc * sizeof(double);
d1036 1
a1036 1
  memcpy(p_b, p_a, mem_size);
d1038 1
a1038 2
  return (UT_OK);
}
d1040 1
a1040 9
/*******************************************************************************
COPY_CMAT
Copy a matrix of unsigned chars "a" into a matrix "b".
RG,AG
*******************************************************************************/
int copy_cmat(unsigned char **a, unsigned char **b, int nr, int nc)
{
  int            mem_size;
  unsigned char  *p_a, *p_b;
d1042 3
a1044 2
  p_a = &a[1][1];
  p_b = &b[1][1];
d1046 3
a1048 1
  mem_size = nr * nc * sizeof(unsigned char);
d1050 1
a1050 1
  memcpy(p_b, p_a, mem_size);
d1052 4
d1059 1
d1061 4
a1064 3
COPY_VEC
Copy a vector "a" into a vector "b".
RG,AG
d1066 1
a1066 1
int copy_vec(float *a, float *b, int nc)
d1068 8
a1075 2
  int    mem_size;
  float  *p_a, *p_b;
d1077 1
a1077 1
  mem_size = nc * sizeof(float);
d1079 2
a1080 2
  p_a = &a[1];
  p_b = &b[1];
d1082 1
a1082 1
  memcpy(p_b, p_a, mem_size);
d1084 1
a1084 2
  return (UT_OK);
}
d1086 1
a1086 9
/*******************************************************************************
COPY_IVEC
Copy a vector of ints "a" into a ints "b".
RG,AG
*******************************************************************************/
int copy_ivec(int *a, int *b, int nc)
{
  int    mem_size;
  int    *p_a, *p_b;
d1088 3
a1090 1
  mem_size = nc * sizeof(int);
d1092 3
a1094 2
  p_a = &a[1];
  p_b = &b[1];
d1096 1
a1096 1
  memcpy(p_b, p_a, mem_size);
d1098 4
d1105 1
d1107 4
a1110 3
COPY_DVEC
Copy a vector of doubles "a" into a vector "b".
RG,AG
d1112 1
a1112 1
int copy_dvec(double *a, double *b, int nc)
d1114 8
a1121 2
  int    mem_size;
  double *p_a, *p_b;
d1123 1
a1123 1
  mem_size = nc * sizeof(double);
d1125 2
a1126 2
  p_a = &a[1];
  p_b = &b[1];
d1128 1
a1128 1
  memcpy(p_b, p_a, mem_size);
d1130 1
a1130 2
  return (UT_OK);
}
d1132 1
a1132 9
/*******************************************************************************
COPY_CVEC
Copy a vector of unsigned chars "a" into a vector "b".
RG,AG
*******************************************************************************/
int copy_cvec(unsigned char *a, unsigned char *b, int nc)
{
  int           mem_size;
  unsigned char *p_a, *p_b;
d1134 3
a1136 1
  mem_size = nc * sizeof(unsigned char);
d1138 3
a1140 2
  p_a = &a[1];
  p_b = &b[1];
d1142 1
a1142 1
  memcpy(p_b, p_a, mem_size);
d1144 4
d1151 1
d1153 7
a1159 4
COPY_SUB_VEC_TO_VEC
Copy a vector into a larger vector, starting at a given position in the larger
vector.
RG
d1161 1
a1161 2
int copy_sub_vec_to_vec(float *sub_vec, float *vec, int sub_vec_size, 
                        int vec_size, int vec_start_pos)
d1163 2
a1164 3
  float *p;
  float *p_sub;
  float *p_end;
d1166 5
a1170 5
  /* assign pointer to last element of vec */
  p_end = &vec[vec_size];

  for (p = &vec[vec_start_pos], p_sub = &sub_vec[1]; p <= p_end; p++, p_sub++)
    *p = *p_sub;
d1172 29
a1203 1

d1205 5
a1209 4
COPY_SUB_DVEC_TO_DVEC
Copy a vector of doubles into a larger vector, starting at a given position in 
the larger vector.
RG
d1211 1
a1211 2
int copy_sub_dvec_to_dvec(double *sub_vec, double *vec, int sub_vec_size, 
                          int vec_size, int vec_start_pos)
d1213 5
a1217 3
  double *p;
  double *p_sub;
  double *p_end;
d1219 2
a1220 2
  /* assign pointer to last element of vec */
  p_end = &vec[vec_size];
d1222 2
a1223 2
  for (p = &vec[vec_start_pos], p_sub = &sub_vec[1]; p <= p_end; p++, p_sub++)
    *p = *p_sub;
a1227 1

d1229 6
a1234 4
COPY_SUB_IVEC_TO_IVEC
Copy a vector of integers into a larger vector, starting at a given position in 
the larger vector.
RG
d1236 1
a1236 2
int copy_sub_ivec_to_ivec(int *sub_vec, int *vec, int sub_vec_size, 
                          int vec_size, int vec_start_pos)
d1238 3
a1240 3
  int *p;
  int *p_sub;
  int *p_end;
d1242 10
a1251 2
  /* assign pointer to last element of vec */
  p_end = &vec[vec_size];
d1253 6
a1258 4
  for (p = &vec[vec_start_pos], p_sub = &sub_vec[1]; p <= p_end; p++, p_sub++)
    *p = *p_sub;

  return (UT_OK);
a1260 1

d1262 5
a1266 4
COPY_SUB_CVEC_TO_CVEC
Copy a vector of unsigned chars into a larger vector, starting at a given 
position in the larger vector.
RG
d1268 1
a1268 2
int copy_sub_cvec_to_cvec(unsigned char *sub_vec, unsigned char *vec, 
                          int sub_vec_size, int vec_size, int vec_start_pos)
d1270 5
a1274 3
  unsigned char *p;
  unsigned char *p_sub;
  unsigned char *p_end;
d1276 2
a1277 2
  /* assign pointer to last element of vec */
  p_end = &vec[vec_size];
d1279 2
a1280 2
  for (p = &vec[vec_start_pos], p_sub = &sub_vec[1]; p <= p_end; p++, p_sub++)
    *p = *p_sub;
d1282 1
a1282 1
  return (UT_OK);
d1406 1
a1406 1
  fast_zero_vec(result, nr);
d1474 1
a1474 1
  fast_zero_vec(result, nc);
d1564 1
a1564 1
  fast_zero_mat(c, nrc, ncc);
d2114 1
d2139 1
d2168 1
d2197 1
d2223 1
d2249 1
d2274 1
d2299 1
d2321 1
d2343 1
d2365 1
d2387 1
d2415 1
d2443 1
d2471 1
a2496 79
}

/*******************************************************************************
 SET_OF_MATRICES
 Allocate a structure which holds many matrices.
*******************************************************************************/
float ***set_of_matrices(int num_mats, int num_rows, int num_cols)
{
  int i;
  float ***mat_set;

  /* accomodate the NR indexing convention */
  mat_set = (float***) malloc_return_if_fail((num_mats+1) * sizeof(float**),
                                              (float***)NULL);

  mat_set[0] = (float**)NULL;
  for (i = 1; i <= num_mats; i++)
    mat_set[i] = NR_matrix(1, num_rows, 1, num_cols);

  return (mat_set);
}

/*******************************************************************************
 FREE_SET_OF_MATRICES
 De-allocate a structure which holds many matrices.
*******************************************************************************/
void free_set_of_matrices(float ***mat_set, int num_mats, int num_rows, 
                          int num_cols)
{
  int i;

  for (i = 1; i <= num_mats; i++)
    NR_free_matrix(mat_set[i], 1, num_rows, 1, num_cols);

  free(mat_set);

  /* no error code returned, since this mirrors the NR NR_free_...() 
     functions */
}


/*******************************************************************************
 SET_OF_SETS_OF_MATRICES
 Allocate a structure which holds many sets of matrices.
*******************************************************************************/
float ****set_of_sets_of_matrices(int num_sets, int num_mats, int num_rows, 
                                  int num_cols)
{
  int i;
  float ****mat_set_set;

  /* accomodate the NR indexing convention */
  mat_set_set = (float****) malloc_return_if_fail((num_sets+1) * 
                                                   sizeof(float***), 
                                                   (float****)NULL);

  mat_set_set[0] = (float***)NULL;
  for (i = 1; i <= num_sets; i++)
    mat_set_set[i] = set_of_matrices(num_mats, num_rows, num_cols);

  return (mat_set_set);
}


/*******************************************************************************
 FREE_SET_OF_SETS_OF_MATRICES
 De-allocate a structure which holds many sets of matrices.
*******************************************************************************/
void free_set_of_sets_of_matrices(float ****mat_set_set, int num_sets, 
                                  int num_mats, int num_rows, int num_cols)
{
  int i;

  for (i = 1; i <= num_sets; i++)
    free_set_of_matrices(mat_set_set[i], num_mats, num_rows, num_cols);

  free(mat_set_set);

  /* no error code returned, since this mirrors the NR NR_free_...() functions */
@


1.38
log
@fixed some bugs
added versions for different data types of some functions
changed some argument orders to agree with new standard
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.37 1997/09/10 14:50:22 granat Exp granat $";
d37 5
d203 1
a203 1
NORM
d205 1
a205 1
AG,RG
d207 1
a207 1
float norm(float *v, int n)
a208 1
  int   i;
d210 1
d213 2
a214 1
  p = &v[1];
d217 2
a218 4
  for (i = 1; i <= n; i++) {
    result += (*p) * (*p);
    p++;
  }
d220 1
a220 1
  return (sqrt((double) result ));
d223 1
d225 1
a225 1
DNORM
d229 1
a229 1
double dnorm(double *v, int n)
a230 1
  int    i;
d232 1
d235 2
a236 1
  p = &v[1];
d239 28
a266 4
  for (i = 1; i <= n; i++) {
    result += (*p) * (*p);
    p++;
  }
d268 19
a286 1
  return (sqrt( result ));
d289 1
d293 1
a293 1
AG,RG
a296 1
  int     i;
d298 13
a310 1
  float   sum;
d312 10
a321 1
  sum = 0.0;
d323 2
a324 1
  p = &v[1];
d326 2
a327 1
  for (i = 1; i <= n; i++) {
d329 44
a372 2
    p++;
  }
d383 1
a383 1
float sum_mat( float **m, int nr, int nc )
a384 2
  int   i;
  int   num_elements;
d386 14
a399 1
  float sum;
a400 1
  num_elements = nr * nc;
d402 10
a411 1
  sum = 0.0;
d413 2
a414 1
  p = &m[1][1];
d419 1
a419 1
  for (i = 1; i <= num_elements; i++) {
a420 2
    p++;
  }
d422 1
a422 1
  return( sum );
d428 1
a428 1
Sum the values in an integer matrix.
d431 1
a431 1
float sum_imat( int **m, int nr, int nc )
a432 2
  int   i;
  int   num_elements;
d434 2
a435 3
  float sum;

  num_elements = nr * nc;
d437 2
a438 3
  sum = 0.0;

  p = &m[1][1];
d443 2
a444 4
  for (i = 1; i <= num_elements; i++) {
    sum += (float)(*p);
    p++;
  }
d446 1
a446 1
  return( sum );
d452 2
a453 1
Sum the values in an unsigned char matrix.
d456 1
a456 1
float sum_cmat( unsigned char **m, int nr, int nc )
d458 3
a460 6
  int           i;
  int           num_elements;
  unsigned char *p;
  float         sum;

  num_elements = nr * nc;
d462 2
a463 3
  sum = 0.0;

  p = &m[1][1];
d468 2
a469 4
  for (i = 1; i <= num_elements; i++) {
    sum += (float)(*p);
    p++;
  }
d471 1
a471 1
  return( sum );
d482 1
a482 1
  int i;
d496 62
a557 1
NORM_SUM_VEC
d560 1
a560 1
RG,AG
d562 1
a562 1
float norm_sum_vec(float *v, int n)
a563 2
  int i;
  float *p;
a564 1
  float inv_sum;
d567 5
a571 1
  inv_sum = 1 / sum;
d573 9
a581 1
  p = &v[1];
d583 2
a584 4
  for (i = 1; i <= n; i++) {
    *p *= inv_sum;
    p++;
  }
d591 1
a591 1
NORM_SUM_MAT
d596 1
a596 1
float norm_sum_mat( float **m, int nr, int nc)
a597 3
  int   i;
  int   num_elements;
  float *p;
a598 1
  float inv_sum;
d600 2
a601 1
  num_elements = nr * nc;
d603 2
a604 2
  sum = sum_mat( m, nr, nc );
  inv_sum = 1 / sum;
a605 1
  p = &m[1][1];
d607 9
a615 2
  /* the memory is one continuous strip, so it can be stepped through */
  /* in a single loop to reduce branching */
d617 2
a618 4
  for (i = 1; i <= num_elements; i++) {
    *p *= inv_sum;
    p++;
  }
d620 1
a620 1
  return( sum );
d635 1
a635 1
  int i;
d649 24
d674 2
a675 2
Given a vector, return the sum of the log() of each member.
RG,AG
a678 1
  int i;
d680 54
a733 1
  float sum;
d735 10
a744 1
  sum = 0.0;
d746 2
a747 1
  p = &v[1];
d749 2
a750 5
  for (i = 1; i <= n; i++)
  {
    sum += log( (double) (*p) );
    p++;
  }
d759 1
a759 1
RG,AG
a762 1
  int     i;
d764 1
d767 1
d770 2
a771 1
  p = &v[1];
d773 2
a774 2
  for (i = 2; i <= n; i++) {
    p++;
a776 1
  }
d783 9
a791 2
MIN_VEC
Return the minimum value in a vector.
d793 19
a811 3
n is the length of the vector.
v is the input vector.
RG,AG
d813 1
a813 1
float min_vec(float *v, int n)
d815 3
a817 3
  int     i;
  float  *p;
  float   minval;
d819 2
a820 1
  minval = v[1];
d822 2
a823 1
  p = &v[1];
d825 4
a828 5
  for (i = 2; i <= n; i++) {
    p++;
    if (*p < minval)
      minval = *p;
  }
d830 1
a830 1
  return (minval);
d835 3
a837 3
ARG_MAX_VEC
Return the index of the maximum value in a vector.
RG,AG
d839 1
a839 1
int arg_max_vec(float *v, int n)
d841 3
a843 4
  int     i;
  float  *p;
  float   maxval;
  int     arg;
d845 1
a846 1
  arg = 1;
d848 2
a849 1
  p = &v[1];
d851 2
a852 1
  for (i = 2; i <= n; i++) {
a853 1
    {
a854 4
      arg = i;
    }
    p++;
  }
d856 1
a856 1
  return (arg);
d861 3
a863 3
ARG_MIN_VEC
Return the index of the minimum value in a vector.
RG,AG
d865 1
a865 1
int arg_min_vec(float *v, int n)
a866 1
  int     i;
d868 1
a869 1
  int     arg;
d871 1
a872 1
  arg = 1;
d874 2
a875 1
  p = &v[1];
d877 2
a878 1
  for (i = 2; i <= n; i++) {
a879 1
    {
a880 4
      arg = i;
    }
    p++;
  }
d882 1
a882 1
  return (arg);
d887 3
a889 5
MINMAX_OF_COLS
For each of k columns in a matrix, find the minimum and maximum values, and
the range (difference between the two).  Pass in a size k vector for each of 
these latter sets of values, and they will be filled in by this function.  
AG
d891 5
a895 2
int minmax_of_cols(float **mat, float *minval, float *maxval, 
                   float *range, int numrows, int numcols)
d897 2
a898 2
{
  int i,j;
d900 2
a901 3
  /* for each attribute, find the min and max */
  for (j=1; j<=numcols; j++)
    minval[j] = maxval[j] = mat[1][j];
d903 4
a906 8
  for (i=2; i<=numrows; i++)
    for (j=1; j<=numcols; j++)
    {
      if (mat[i][j] < minval[j])
        minval[j] = mat[i][j];
      if (mat[i][j] > maxval[j])
        maxval[j] = mat[i][j];
    }
d908 1
a908 5
  /* for each attribute, compute the range */
  for (j=1; j<=numcols; j++)
    range[j] = maxval[j] - minval[j];
  
  return(UT_OK);
d913 3
a915 7
RANGE_VEC
Return the range of values (difference between max and min values) in a vector.
This value may be negative.

n is the length of the vector.
v is the input vector.
AG
d917 1
a917 1
float range_vec(float *v, int n)
d919 3
a921 2
  int     i;
  float   minval, maxval;
d923 1
a924 7
  maxval = v[1];
  for (i = 2; i <= n; i++) {
    if (v[i] < minval)
      minval = v[i];
    if (v[i] > maxval)
      maxval = v[i];
  }
d926 9
a934 1
  return (maxval - minval);
d939 2
a940 2
TRANSPOSE_MATRIX
Create the transpose of a matrix of floats in a separate matrix.
d943 1
a943 1
int transpose_matrix(float **a, int nr, int nc, float **a_trans)
d945 6
a950 2
  int    i, j;
  float  *p, *p_trans, *col_start;
d952 2
a953 2
  p = &a[1][1];
  col_start = &a_trans[1][1];
d955 4
a958 9
  for (i = 1; i <= nr; i++) {
    p_trans = col_start;
    for (j = 1; j <= nc; j++) {
      *p_trans = *p;
      p++;
      p_trans += nr;
    }
    col_start++;
  }
d960 1
a960 1
  return (UT_OK);
d963 1
d965 2
a966 2
TRANSPOSE_IMATRIX
Create the transpose of a matrix of integers in a separate matrix.
d969 1
a969 1
int transpose_imatrix(int **a, int nr, int nc, int **a_trans)
d971 15
a985 2
  int    i, j;
  int    *p, *p_trans, *col_start;
d988 22
a1009 2
  p = &a[1][1];
  col_start = &a_trans[1][1];
a1010 9
  for (i = 1; i <= nr; i++) {
    p_trans = col_start;
    for (j = 1; j <= nc; j++) {
      *p_trans = *p;
      p++;
      p_trans += nr;
    }
    col_start++;
  }
d1012 21
a1032 1
  return (UT_OK);
d1035 1
d1037 2
a1038 6
TRANSPOSE_IN_SITU_ALLOC_MATRIX
Create the transpose of a matrix of floats in the same memory space as the
original matrix.  Takes as one of its arguments a vector for temporary
storage space, which must be of length at least equal to the number of rows
in the input matrix.  Allocation and deallocation may be required to maintain
the appropriate matrix data structure.
d1041 1
a1041 2
int transpose_in_situ_alloc_matrix(float ***a, int nr, int nc, float *temp_vect,
                                   char *mem_choice)
d1043 15
a1057 7
  int     i, j, k;   
  float  *p;          /* pointer into the input matrix */
  float  *p_temp;     /* pointer into temporary values */
  float **m;          /* pointer to new vector of pointers to rows */
  int     skip;
  int     nr_less1;
  int     nc_less1;
a1058 8
  /****
   * Algorithm outline:
   * For each row in the transpose, skip through the matrix, picking out
   * the appropriate element of each column, and copy them into temporary
   * storage.  Then compress the remain parts of the untransposed matrix
   * to fill in the gaps, leaving a space in memory.  In the space created 
   * copy the stored elements, thus creating a new row.
   ****/
d1060 22
a1081 1
  p = &(*a)[1][1];
a1082 2
  nr_less1 = nr-1;
  nc_less1 = nc-1;
d1084 22
a1105 1
  skip = nc;
a1106 1
  /* extract columns and compose into rows */
d1108 22
a1129 2
  for (i = 1; i <= nc_less1; i++) {
    p_temp = &temp_vect[1]; /* p_temp points into the temporary storage */
a1130 3
    /* move p along so the it points to every "skip"th element */
    /* (ie, the values in a column) and copy the values into the */
    /* temporary storage */
d1132 1575
a2706 4
    for (j = 1; j <= nr; j++) {
      *p_temp = *p;
      p += skip;
      p_temp++;
d2709 142
a2850 1
    /* move the pointer back into the array */
d2852 4
a2855 1
    p -= skip;
d2857 8
a2864 2
    /* account for effective smaller column size now that an element 
       is removed */
d2866 13
a2878 1
    skip--;
d2880 3
a2882 2
    /* pack the remaining untransposed data into the last part of memory */
    /* this leaves space in memory in front of the packed data */
d2884 1
a2884 5
    for (j = 1; j <= nr_less1; j++)
      for (k = 1; k <= skip; k++) {
        *p = *(p-j);
        p--;
      }
d2886 2
a2887 1
    /* set pointer back to the beginning of the new space */
d2889 1
a2889 2
    p -= nr_less1;
    p_temp = &temp_vect[1];
d2891 4
a2894 1
    /* copy the stored elements into the new space */
d2896 2
a2897 4
    for (j = 1; j <= nr; j++) {
      *p = *p_temp;
      p++;
      p_temp++;
d2900 3
a2903 1
  /* make necessary changes to new pointer scheme */
d2905 13
a2917 1
  if (!strcmp( mem_choice, "realloc") && (nr != nc)) {
d2919 1
a2919 1
    /* allocate more memory and reassign pointers */
d2921 6
a2926 5
    m=(float **) malloc((size_t)((nc+NR_END)*sizeof(float*)));
    if (!m)
      NR_error("allocation failure 1 in NR_matrix()");
    m += NR_END;
    m--;
d2928 1
a2928 3
    m[1] = (*a)[1];
    for(i = 2; i <= nc; i++)
      m[i] = m[i-1]+nr;
d2930 4
a2933 1
    free(*a);
d2935 3
a2937 1
    *a = m;
d2939 4
a2942 2
  else
    if (nr > nc) { 
d2944 13
a2956 1
      /* reassign pointers and free excess memory */
d2958 3
a2960 5
      for (i = 2; i <= nc; i++)
        (*a)[i] = (*a)[i-1]+nr;
      free(&(*a)[i]);
    }
    else if (nc > nr) { 
d2962 1
a2962 1
      /* allocate more memory and reassign pointers */
d2964 2
a2965 5
      m=(float **) malloc((size_t)((nc+NR_END)*sizeof(float*)));
      if (!m) 
        NR_error("allocation failure 1 in NR_matrix()");
      m += NR_END;
      m--;
d2967 1
a2967 3
      m[1] = (*a)[1];
      for(i = 2; i <= nc; i++)
        m[i] = m[i-1]+nr;
d2969 4
a2972 1
      free(*a);
d2974 2
a2975 1
      *a = m;
d2977 2
a2978 3

  /* nothing needs to be done if nr = nc */

d2982 1
d2984 2
a2985 3
TRANSPOSE_IN_SITU_SQR_MATRIX
Create the transpose of a matrix of floats in the same memory space as the
original matrix.
d2988 1
a2988 1
int transpose_in_situ_sqr_matrix( float **a, int n )
d2991 1
a2991 1
  float  *p_by_row, *p_by_col, *col_start, *row_start;
d2993 1
d2995 3
a2997 2
  row_start = &a[1][1];
  col_start = &a[1][1];
d2999 1
a2999 1
  for (i = 1; i <= n; i++) {
d3001 2
a3002 1
    /* assign index pointers to the row and column being transposed */
d3004 1
a3004 2
    p_by_row = row_start;
    p_by_col = col_start;
d3006 1
a3006 1
    /* go through the row and column exchanging elements up to the diagonal */
d3008 4
a3011 1
    for (j = 1; j < i; j++) {
d3013 2
a3014 8
      /* switch the elements */

      temp = *p_by_row;
      *p_by_row = *p_by_col;
      *p_by_col = temp;

      p_by_row++; /* move to next element in the row */
      p_by_col += n; /* move to the next element in the column */
a3015 5

    /* move pointers to the next row and column */

    row_start += n; /* move to the next row */
    col_start++; /* move to the next column */
d3021 1
d3023 2
a3024 2
FLIP_VECTOR
Change a vector so that it has its elements in reverse order.
d3027 1
a3027 1
int flip_vector( float *v, int n )
d3029 15
a3043 4
  int    i;
  float *p, *p_flip;
  float  temp;
  int    half_n;
d3045 1
a3045 1
  half_n = (int)(n / 2);
d3047 4
a3050 2
  p = &v[1];
  p_flip = &v[n];
d3052 3
a3054 6
  for (i = 1; i <= half_n; i++) {
    temp = *p;
    *p = *p_flip;
    *p_flip = temp;
    p++;
    p_flip--;
d3056 3
a3059 2
  return( UT_OK );
}
d3062 2
a3063 2
FLIP_LEFT_RIGHT_MATRIX
Change a matrix so that its columns are in reverse order.
d3066 1
a3066 1
int flip_left_right_matrix( float **a, int nr, int nc )
d3068 4
a3071 4
  int    i, j;
  float *p_left, *p_right;
  float  temp;
  int    half_nc;
d3073 1
a3073 1
  half_nc = (int)(nc / 2);
d3075 1
a3075 1
  p_left = &a[1][1];
d3077 1
a3077 1
  for (i = 1; i <= nr; i++) {
d3079 2
a3080 1
    /* start index pointers at the beginning and end of a row */
d3082 1
a3082 2
    p_left = a[i];
    p_right = &a[i][nc];
d3084 1
a3084 1
    /* switch the values and move each pointer towards the center */
d3086 4
a3089 4
    for (j = 1; j <= half_nc; j++) {
      temp = *p_left;
      *p_left = *p_right;
      *p_right = temp;
d3091 2
a3092 2
      p_left++; /* move the pointer to the right */
      p_right--; /* move the pointer to the left */
d3098 2
a3099 1
 
d3101 2
a3102 2
FLIP_TOP_BOTTOM_MATRIX
Change a matrix so that its rows are in reverse order.
d3105 1
a3105 1
int flip_top_bottom_matrix( float **a, int nr, int nc )
d3107 4
a3110 4
  int    i, j;
  float *p_top, *p_bottom;
  float  temp;
  int    half_nr;
d3112 1
a3112 1
  half_nr = (int)(nr / 2);
d3138 1
d3140 1
a3140 1
INVERT_MAT
d3143 2
d3148 1
a3148 1
int invert_mat( float **mat, int nc, float **inv )
d3154 1
a3154 1
  if (nc == 1) {
d3160 1
a3160 1
  col = NR_vector(1,nc);
d3166 1
a3166 1
  index = NR_ivector(1,nc);
d3174 3
a3176 3
  NR_ludcmp(mat,nc,index,&d);
  for(j=1; j<=nc; j++) {
    for (i=1; i<=nc; i++)
d3179 2
a3180 2
    NR_lubksb(mat,nc,index,col);
    for (i=1; i<=nc; i++)
d3183 153
a3335 6
  
  /* delete temporary storage */
  NR_free_vector(col, 1, nc);
  NR_free_ivector(index, 1, nc);
  
  return(UT_OK);
d3338 1
d3340 3
a3342 4
INVERT_MAT_COPY
Invert matrix copy.  
Like invert_mat(), but does not destroy the original; makes a copy first.
AG
d3344 1
a3344 1
int invert_mat_copy( float **mat, int nc, float **inv )
d3346 3
a3348 1
  float **mat_copy;
d3350 1
a3350 3
  /* make copy of matrix to be inverted */
  mat_copy = NR_matrix(1,nc,1,nc);
  copy_mat(mat, mat_copy, nc, nc);
d3352 2
a3353 2
  /* invert */
  invert_mat(mat_copy,nc,inv);
d3355 1
a3355 2
  /* free the garbled matrix */
  NR_free_matrix(mat_copy,1,nc,1,nc);
d3360 1
d3362 2
a3363 4
DET
Determinant of a matrix.
Destroys the original.  
Ref: Numerical Recipes 2e, p. 49.
d3366 1
a3366 1
float det(float **mat, int nc)
d3368 1
a3368 2
  int j, *index;
  float d;
d3370 2
a3371 10
  /* allocate temporary storage */
  index = NR_ivector(1,nc);
  if (index == (int*)NULL) {
    err_printf();
    log_printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }
  
  /* use a side-effect of LU decomposition, which returns d as +1 or -1 */
  NR_ludcmp(mat,nc,index,&d);
d3373 1
a3373 6
  /* the determinant of an LU decomposed matrix is the product of the diagonal
     elements */
  for (j=1; j<=nc; j++)
    d *= mat[j][j];
  
  return(d);
d3376 1
d3378 2
a3379 3
DET_COPY
Determinant of matrix copy.
Like det(), but does not destroy the original; makes a copy first.
d3382 1
a3382 1
float det_copy(float **mat, int nc)
d3384 1
a3384 5
  float **mat_copy, d;
  
  /* make copy of matrix */
  mat_copy = NR_matrix(1,nc,1,nc);
  copy_mat(mat, mat_copy, nc, nc);
d3386 2
a3387 2
  /* find determinant */
  d = det(mat_copy,nc);
d3389 2
a3390 2
  /* free the garbled matrix */
  NR_free_matrix(mat_copy,1,nc,1,nc);
a3391 2
  return (d);
}
d3394 3
a3396 3
GRAB_ROW
Create the vector obtained from the specified row of the matrix.
RG,AG
d3398 1
a3398 1
int grab_row(float **mat, int index, int nc, float *vec)
d3400 1
a3400 3
  int   mem_size;
  float *p_vec;
  float *p_mat;
d3402 2
a3403 6
  mem_size = nc * sizeof( float );

  p_vec = &vec[1];
  p_mat = mat[index];

  memcpy( p_vec, p_mat, mem_size );
d3408 1
d3410 3
a3412 2
GRAB_COL
Create the vector obtained from the specified column of the matrix.
d3415 1
a3415 1
int grab_col(float **mat, int index, int nr, float *vec)
d3431 2
a3432 1
the top left corner of the section in the destination matrix.
d3435 2
a3436 2
int copy_mat_section( float **a, float **b, int a_tlr, 
                      int a_tlc, int b_tlr, int b_tlc, int nr, int nc )
d3444 1
a3444 1
  mem_size = nc * sizeof( float );
d3457 1
a3457 1
    memcpy( p_b, p_a, mem_size );
d3460 1
a3460 1
  return( UT_OK );
d3470 2
a3471 1
matrix by means of direct memory copy.
d3474 2
a3475 2
int copy_imat_section( int **a, int **b, int a_tlr, int a_tlc, int b_tlr, 
                       int b_tlc, int nr, int nc )
d3481 1
a3481 1
  mem_size = nc * sizeof( int );
d3489 1
a3489 1
    memcpy( p_b, p_a, mem_size );
d3492 1
a3492 1
  return( UT_OK );
d3501 2
a3502 1
the top left corner of the section in the destination matrix.
d3505 2
a3506 2
int copy_cmat_section( unsigned char **a, unsigned char **b, int a_tlr, 
                       int a_tlc, int b_tlr, int b_tlc, int nr, int nc )
d3512 1
a3512 1
  mem_size = nc * sizeof( unsigned char );
d3520 1
a3520 1
    memcpy( p_b, p_a, mem_size );
d3523 1
a3523 1
  return( UT_OK );
d3532 2
a3533 1
the top left corner of the section in the destination matrix.
d3536 2
a3537 2
int copy_dmat_section( double **a, double **b, int a_tlr, 
                       int a_tlc, int b_tlr, int b_tlc, int nr, int nc )
d3543 1
a3543 1
  mem_size = nc * sizeof( double );
d3551 1
a3551 1
    memcpy( p_b, p_a, mem_size );
d3554 1
a3554 1
  return( UT_OK );
d3559 1
a3559 1
OVERWRITE_ROW
d3562 1
a3562 1
AG
d3564 1
a3564 1
int overwrite_row(float **mat, int index, int nc, float *vec)
d3570 71
a3640 1
  mem_size = nc * sizeof( float );
d3645 1
a3645 1
  memcpy( p_mat, p_vec, mem_size );
d3650 1
d3652 1
a3652 1
OVERWRITE_COL
d3657 53
a3709 1
int overwrite_col(float **mat, int index, int nr, float *vec)
d3743 134
a3876 1
Sets each of the values of an integer matrix to a specified number.
d3878 5
a3882 4
nr and nc are the dimensions of the matrix (num. rows and num. cols).
m is the input matrix.
constant is the amount to set all the values to.
AG
d3884 1
a3884 1
int set_imat(int **m, int nr, int nc, int constant)
d3886 8
a3893 1
  int     i,j;
d3895 2
a3896 4
  /* change each element of the vector */
  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++)
      m[i][j] = constant;
d3901 1
d3903 5
a3907 6
SET_VEC
Sets each of the values of a vector to a specified number.

nc is the length of the vector (num. cols).
v is the input vector.
constant is the amount to set all the values to.
d3910 1
a3910 1
int set_vec(float *v, int nc,  float constant)
d3912 3
a3914 1
  int     i;
d3916 4
a3919 4
  /* change each element of the vector */
  for (i = 1; i <= nc; i++) {
      v[i] = constant;
  }
d3926 6
a3931 7
SET_IVEC
Sets each of the values of a vector of integers to a specified number.

nc is the length of the vector (num. cols).
v is the input vector.
constant is the amount to set all the values to.
AG
d3933 1
a3933 1
int set_ivec(int *ivec, int nc, int constant)
d3935 3
a3937 1
  int     i;
d3939 4
a3942 4
  /* change each element of the vector */
  for (i = 1; i <= nc; i++) {
      ivec[i] = constant;
  }
d3949 6
a3954 4
SET_DIAG_MAT
Set the diagonal of a square matrix to a given constant, and set the other
elements to zero.
AG
d3956 1
a3956 1
int set_diag_mat(float **mat, int dim, float constant)
d3958 3
a3960 1
  int i,j;
d3962 4
a3965 6
  for (i = 1; i <= dim; i++)
    for (j = 1; j <= dim; j++)
      if (i == j)
        mat[i][j] = constant;
      else
        mat[i][j] = 0.0;
d3970 1
d3972 6
a3977 6
SET_BAND_DIAG_MAT
Set the diagonal band of a square matrix to a given constant, and set the other
elements to zero.  The diagonal band is defined as the diagonal plus a number
of strips of elements adjacent to it, on either side of it; this number is 
specified as an argument.
AG
d3979 2
a3980 1
int set_band_diag_mat(float **mat, int dim, int width, float constant)
d3982 3
a3984 1
  int i,j;
d3986 2
a3987 2
  for (i = 1; i <= dim; i++)
    for (j = 1; j <= dim; j++)
d3989 1
a3989 3
        mat[i][j] = constant;
      else
        mat[i][j] = 0.0;
d3998 1
a3998 1
AG
d4008 1
a4008 1
  mem_size = nr * nc * sizeof( float );
d4010 1
a4010 1
  memcpy( p_b, p_a, mem_size );
d4018 1
a4018 1
AG
d4028 1
a4028 1
  mem_size = nr * nc * sizeof( int );
d4030 1
a4030 1
  memcpy( p_b, p_a, mem_size );
d4038 1
a4038 1
AG
d4048 1
a4048 1
  mem_size = nr * nc * sizeof( double );
d4050 1
a4050 1
  memcpy( p_b, p_a, mem_size );
d4058 1
a4058 1
AG
d4068 1
a4068 1
  mem_size = nr * nc * sizeof( unsigned char );
d4070 1
a4070 1
  memcpy( p_b, p_a, mem_size );
d4085 1
a4085 1
  mem_size = nc * sizeof( float );
d4090 1
a4090 1
  memcpy( p_b, p_a, mem_size );
d4092 1
a4092 1
  return( UT_OK );
d4105 1
a4105 1
  mem_size = nc * sizeof( int );
d4110 1
a4110 1
  memcpy( p_b, p_a, mem_size );
d4112 1
a4112 1
  return( UT_OK );
d4125 1
a4125 1
  mem_size = nc * sizeof( double );
d4130 1
a4130 1
  memcpy( p_b, p_a, mem_size );
d4132 1
a4132 1
  return( UT_OK );
d4142 1
a4142 1
  int    mem_size;
d4145 1
a4145 1
  mem_size = nc * sizeof( unsigned char );
d4150 1
a4150 1
  memcpy( p_b, p_a, mem_size );
d4152 1
a4152 1
  return( UT_OK );
d4159 1
a4159 1
RG,AG
a4163 1
  int    i, len;
d4165 35
a4199 1
  float *p_copy;
d4201 35
a4235 2
  /* don't go past the edge of vec */
  len = NR_imin( (vec_size - vec_start_pos + 1), sub_vec_size );
d4237 2
a4238 2
  p = &sub_vec[1];
  p_copy = &vec[vec_start_pos];
d4240 2
a4241 5
  for (i = 1; i <= len; i++) {
    *p_copy = *p;
    p++;
    p_copy++;
  }
d4246 1
d4276 1
a4276 1
EUCLID_DIST
d4278 45
a4322 1
RG,AG
d4324 1
a4324 1
float euclid_dist(float *v1, float *v2, int length)
d4326 25
a4350 4
    int i;
    float *p1;
    float *p2;
    float dist = 0, diff;
a4351 2
    p1 = &v1[1];
    p2 = &v2[1];
d4353 28
a4380 6
    for (i=1;i<=length;i++)
    {
      diff = *p1 - *p2;
      dist += diff * diff;
      p1++;
      p2++;
d4383 1
a4383 1
    return (dist);
d4388 2
a4389 2
MAT_VEC_MULT
Multiply a matrix to the left side of a vector.
d4392 1
a4392 1
int mat_vec_mult(float **M, int nr, int nc, float *v, float *u)
d4394 25
a4418 4
  int     i, j;
  float  *p_M;
  float  *p_v;
  float  *p_u;
a4419 2
  p_u = &u[1];
  p_M = &M[1][1];
d4421 28
a4448 7
  for (i = 1; i <= nr; i++) {
    *p_u = 0.0;
    p_v = &v[1];
    for (j = 1; j <= nc; j++) {
      *p_u += (*p_M) * (*p_v);
      p_M++;
      p_v++;
a4449 2
    p_u++;
  }
d4479 48
a4531 1
      *p_c = 0.0;
a4553 1
  int     i,j;
d4557 57
a4613 1

a4615 1
  p3 = &m3[1][1];
d4617 7
a4623 7
  for (i = 1; i <= nr; i++) {
    for (j = 1; j <= nc; j++) {
      *p3 = *p1 + *p2;
      p1++;
      p2++;
      p3++;
    }
d4631 3
a4633 2
SUBTRACT_MAT
Subtract one matrix element-wise from another.
d4636 1
a4636 1
int subtract_mat(float **m1, float **m2, float **m3, int nr, int nc)
d4638 4
a4641 4
  int     i,j;
  float  *p1;
  float  *p2;
  float  *p3;
a4644 1
  p3 = &m3[1][1];
d4646 7
a4652 7
  for (i = 1; i <= nr; i++) {
    for (j = 1; j <= nc; j++) {
      *p3 = *p1 - *p2;
      p1++;
      p2++;
      p3++;
    }
a4657 1

a4664 1
  int     i;
d4668 1
d4670 2
a4671 3
  p1 = &v1[1];
  p2 = &v2[1];
  p3 = &v3[1];
d4673 1
a4673 1
  for (i = 1; i <= n; i++) {
a4674 4
    p1++;
    p2++;
    p3++;
  }
d4679 20
d4702 2
a4703 1
Subtract one vector element-wise from another.
a4707 1
  int     i;
d4711 1
d4713 5
a4717 10
  p1 = &v1[1];
  p2 = &v2[1];
  p3 = &v3[1];
 
  for (i = 1; i <= n; i++) {
    *p3 = *p1 - *p2;
    p1++;
    p2++;
    p3++;
  }
d4724 2
a4725 1
Subtract one vector of doubles element-wise from another.
a4729 1
  int     i;
d4733 1
d4735 4
a4738 5
  p1 = &v1[1];
  p2 = &v2[1];
  p3 = &v3[1];
 
  for (i = 1; i <= n; i++) {
a4739 4
    p1++;
    p2++;
    p3++;
  }
d4745 1
a4745 1
DOT_PRODUCT
d4747 1
a4747 1
AG
d4749 1
a4749 1
float dot_product(float *x, float *y, int n)
a4750 1
  int    i;
d4753 1
d4756 24
a4779 2
  p_x = &x[1];
  p_y = &y[1];
d4781 2
a4782 1
  for (i = 1; i <= n; i++) {
a4783 3
    p_x++;
    p_y++;
  }
d4785 1
a4785 1
  return(result);
d4789 1
a4789 1
OUTER_PRODUCT
d4793 1
a4793 1
int outer_product(float *x, float *y, int nc, float **prod)
a4794 1
  int    i, j;
d4797 2
d4801 5
a4805 1
  p_x = &x[1];
d4808 3
a4810 3
  for (i = 1; i <= nc; i++) {
    p_y = &y[1];
    for (j = 1; j <= nc; j++) {
a4811 1
      p_y++;
a4813 2
    p_x++;
  }
d4819 30
a4858 1
  int     i;
d4860 1
d4862 2
a4863 1
  p = &v[1];
d4866 1
a4866 1
  for (i = 1; i <= n; i++) {
a4867 2
    p++;
  }
d4879 1
a4879 1
RG,AG
a4882 1
  int     i;
d4884 204
d5089 2
a5090 1
  p = &v[1];
d5092 2
a5093 2
  /* change each element of the vector */
  for (i = 1; i <= n; i++) {
a5094 2
    p++;
  }
d5100 2
a5101 2
SCALAR_DIV_VEC
Scales a vector by a specified dividend.
d5103 4
a5106 4
n is the length of the vector.
v is the input vector.
constant is the dividend to scale the vector by.
RG,AG
d5108 1
a5108 1
int scalar_div_vec(float *v, int n, float constant)
a5109 1
  int     i;
d5111 2
a5112 1
  float   inv_constant;
d5114 2
a5115 1
  p = &v[1];
d5117 2
a5118 1
  inv_constant = 1 / constant;
d5120 2
a5121 2
  /* change each element of the vector */
  for (i = 1; i <= n; i++) {
a5122 2
    p++;
  }
d5128 2
a5129 2
SCALAR_DIV_DVEC
Scales a vector of doubles by a specified dividend.
d5131 4
a5134 4
n is the length of the vector.
v is the input vector.
constant is the dividend to scale the vector by.
RG,AG
d5136 1
a5136 1
int scalar_div_dvec(double *v, int n, double constant)
a5137 1
  int     i;
d5139 1
d5142 2
a5143 1
  p = &v[1];
d5145 2
a5146 1
  inv_constant = 1 / constant;
d5148 2
a5149 2
  /* change each element of the vector */
  for (i = 1; i <= n; i++) {
a5150 2
    p++;
  }
d5156 2
a5157 2
SCALAR_ADD_VEC
Translates a vector by a specified addend.
d5159 4
a5162 4
nc is the length of the vector.
v is the input vector.
constant is the addend to translate the vector by.
RG,AG
d5164 2
a5165 1
int scalar_add_vec(float *v, int n, float constant)
a5166 1
  int     i;
d5168 1
d5170 2
a5171 1
  p = &v[1];
d5173 2
a5174 2
  /* change each element of the vector */
  for (i = 1; i <= n; i++) {
a5175 2
    p++;
  }
d5181 2
a5182 2
SCALAR_SUBTRACT_VEC
Translates a vector by a specified subtrahend.
d5184 4
a5187 4
nc is the length of the vector.
v is the input vector.
constant is the subtrahend to translate the vector by.
RG,AG
d5189 2
a5190 1
int scalar_subtract_vec(float *v, int n, float constant)
d5192 2
a5193 2
  int     i;
  float  *p;
d5195 2
a5196 1
  p = &v[1];
d5198 3
a5200 5
  /* change each element of the vector */
  for (i = 1; i <= n; i++) {
    *p -= constant;
    p++;
  }
d5206 2
a5207 2
SCALAR_MULT_MAT
Scales a matrix by a specified multiplicand.
d5211 2
a5212 2
constant is the multiplicand to scale the matrix by.
AG
d5214 1
a5214 1
int scalar_mult_mat(float **m, int nr, int nc, float constant)
a5215 1
  int     i,j;
d5217 1
d5219 2
a5220 1
  p = &m[1][1];
d5223 2
a5224 5
  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++) {
      *p *= constant;
      p++;
    }
d5230 2
a5231 2
SCALAR_DIV_MAT
Scales a matrix by a specified dividend.
d5235 2
a5236 2
constant is the dividend to scale the matrix by.
RG,AG
d5238 1
a5238 1
int scalar_div_mat(float **m, int nr, int nc, float constant)
d5240 2
a5241 3
  int     i,j;
  float  *p;
  float   inv_constant;
d5243 2
a5244 2
  p = &m[1][1];
  inv_constant = 1 /constant;
d5247 2
a5248 5
  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++) {
      *p *= inv_constant;
      p++;
    }
d5254 19
a5272 2
SCALAR_ADD_MAT
Translates a matrix by a specified addend.
d5274 4
a5277 4
nr and nc are the dimensions of the matrix (num. rows and num. cols).
m is the input matrix.
constant is the addend to translate the matrix by.
RG,AG
d5279 15
a5293 1
int scalar_add_mat(float **m, int nr, int nc, float constant)
d5295 6
d5302 4
a5305 2
  int     i,j;
  float  *p;
d5307 2
a5308 1
  p = &m[1][1];
d5310 2
a5311 6
  /* change each element of the matrix */
  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++) {
      *p += constant;
      p++;
    }
d5317 3
a5319 7
SCALAR_SUBTRACT_MAT
Translates a matrix by a specified subtrahend.

nr and nc are the dimensions of the matrix (num. rows and num. cols).
m is the input matrix.
constant is the subtrahend to translate the matrix by.
RG,AG
d5321 1
a5321 1
int scalar_subtract_mat(float **m, int nr, int nc, float constant)
d5323 4
a5326 2
  int     i,j;
  float  *p;
d5328 2
a5329 1
  p = &m[1][1];
d5331 2
a5332 6
  /* change each element of the matrix */
  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++) {
      *p -= constant;
      p++;
    }
d5338 3
a5340 3
MULT_VEC_ELT
Multiply one vector element-wise by another.
RG,AG
d5342 1
a5342 1
int mult_vec_elt(float *v1, float *v2, float *v3, int n)
a5343 1
  int     i;
d5347 28
d5376 5
a5380 3
  p1 = &v1[1];
  p2 = &v2[1];
  p3 = &v3[1];
d5382 1
a5382 1
  for (i = 1; i <= n; i++) {
a5385 1
    p3++;
d5392 3
a5394 3
DIV_VEC_ELT
Divide one vector element-wise by another.
RG,AG
d5396 1
a5396 1
int div_vec_elt(float *v1, float *v2, float *v3, int n)
a5397 1
  int     i;
d5401 1
d5403 5
a5407 3
  p1 = &v1[1];
  p2 = &v2[1];
  p3 = &v3[1];
d5409 1
a5409 1
  for (i = 1; i <= n; i++) {
a5412 1
    p3++;
d5418 26
d5455 2
a5456 2
  mat_set = (float***) malloc_return_if_fail( (num_mats+1) * sizeof(float**),
                                              (float***)NULL );
d5495 1
a5495 1
  mat_set_set = (float****) malloc_return_if_fail( (num_sets+1) * 
d5497 1
a5497 1
                                                   (float****)NULL );
d5554 1
a5554 1
  maxiter = NR_imax( 30, (int)(nr * nc / 10000) );
a5564 13


/*******************************************************************************
READ_ROW
AG
*******************************************************************************/
/* similar to read_matrix(); */

/*******************************************************************************
READ_COL
AG
*******************************************************************************/
/* similar to read_matrix(); */
@


1.37
log
@changed many functions to their faster versions, added more comments
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.36 1997/09/04 20:21:59 granat Exp granat $";
d37 3
d220 22
d1458 1
a1458 1
Copy a matrix.
d1463 52
a1514 1
  int   i, j;
d1516 16
a1531 5
  for (i = 1; i <= nr; i++) {
    for (j = 1; j <= nc; j++) {
      b[i][j] = a[i][j];
    }
  }
d1538 1
a1538 1
Copy a vector.
d1543 64
a1606 3
  int    i;
  float *p;
  float *p_copy;
d1608 2
a1609 2
  p = &a[1];
  p_copy = &b[1];
d1611 1
a1611 5
  for (i = 1; i <= nc; i++) {
    *p_copy = *p;
    p++;
    p_copy++;
  }
d1613 1
a1613 1
  return (UT_OK);
d1886 26
d1967 1
a1967 1
nc is the length of the vector.
d1972 1
a1972 1
int scalar_mult_vec(float *v, int nc,  float constant)
d1980 26
a2005 1
  for (i = 1; i <= nc; i++) {
d2017 1
a2017 1
nc is the length of the vector.
d2022 1
a2022 1
int scalar_div_vec(float *v, int nc, float constant)
d2033 29
a2061 1
  for (i = 1; i <= nc; i++) {
d2078 1
a2078 1
int scalar_add_vec(float *v, int nc, float constant)
d2086 1
a2086 1
  for (i = 1; i <= nc; i++) {
d2103 1
a2103 1
int scalar_subtract_vec(float *v, int nc, float constant)
d2111 1
a2111 1
  for (i = 1; i <= nc; i++) {
d2263 4
@


1.36
log
@added variants of sum_mat
added fast_copy_mat_section and variants
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.35 1997/08/11 18:31:19 granat Exp granat $";
d37 4
d201 2
a202 2
  int     i;
  float  *p;
d247 2
a248 1
  int i, j;
d252 2
d258 7
a264 5
  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++) {
      sum += *p;
      p++;
    }
d277 3
a279 2
  int i, j;
  int *p;
d282 2
d288 7
a294 5
  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++) {
      sum += (float)(*p);
      p++;
    }
d307 2
a308 1
  int i, j;
d310 3
a312 1
  float sum;
d318 7
a324 5
  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++) {
      sum += (float)(*p);
      p++;
    }
d385 2
a386 1
  int i, j;
d391 2
d398 7
a404 5
  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++) {
      *p *= inv_sum;
      p++;
    }
d725 1
a725 1
    p_temp = &temp_vect[1];
d727 3
a729 1
    /* copy the appropriate column elements into temporary storage */
d747 1
d831 1
a831 1
  float  *p, *p_trans, *col_start, *row_start;
d841 2
a842 2
    p = row_start;
    p_trans = col_start;
d847 9
a855 5
      temp = *p;
      *p = *p_trans;
      *p_trans = temp;
      p++;
      p_trans += n;
d860 2
a861 2
    row_start += n;
    col_start++;
d903 1
a903 1
  float *p, *p_flip;
d909 1
a909 1
  p = &a[1][1];
d915 2
a916 2
    p = &a[i][1];
    p_flip = &a[i][nc];
d921 6
a926 5
      temp = *p;
      *p = *p_flip;
      *p_flip = temp;
      p++;
      p_flip--;
d941 1
a941 1
  float *p, *p_flip;
d947 1
a947 1
  p = &a[1][1];
d954 1
a954 1
    p_flip = &a[nr - i + 1][1];
d959 6
a964 5
      temp = *p;
      *p = *p_flip;
      *p_flip = temp;
      p++;
      p_flip++;
d1105 1
a1105 1
  int j;
d1109 2
d1112 1
a1112 1
  p_mat = &mat[index][1];
d1114 1
a1114 5
  for (j=1; j <= nc; j++) {
    *p_vec = *p_mat; 
    p_vec++;
    p_mat++;
  }
d1126 1
a1126 1
  int j;
d1134 1
d1137 4
a1140 1
Copy a rectangular section of one matrix into a part of another matrix.
d1143 2
a1144 2
int copy_mat_section( float **a, float **b, int a_tlr, int a_tlc, int b_tlr,
                      int b_tlc, int nr, int nc )
d1146 2
a1147 1
  int    i, j;
d1150 1
a1150 1
  /* copy a section of A into B */
d1152 1
a1152 22
  for (i = 1; i <= nr; i++) {
    p_a = &a[a_tlr + i - 1][a_tlc];
    p_b = &b[b_tlr + i - 1][b_tlc];
    for (j = 1; j <= nc; j++) {
      *p_b = *p_a;
      p_a++;
      p_b++;
    }
  }
}


/*******************************************************************************
COPY_IMAT_SECTION
Copy a rectangular section of one integer matrix into a part of another matrix.
RG
*******************************************************************************/
int copy_imat_section( int **a, int **b, int a_tlr, int a_tlc, int b_tlr,
                       int b_tlc, int nr, int nc )
{
  int    i, j;
  int    *p_a, *p_b;
a1156 9
    p_a = &a[a_tlr + i - 1][a_tlc];
    p_b = &b[b_tlr + i - 1][b_tlc];
    for (j = 1; j <= nc; j++) {
      *p_b = *p_a;
      p_a++;
      p_b++;
    }
  }
}
d1158 1
a1159 15
/*******************************************************************************
COPY_CMAT_SECTION
Copy a rectangular section of one unsigned char matrix into a part of another 
matrix.
RG
*******************************************************************************/
int copy_cmat_section( unsigned char **a, unsigned char **b, int a_tlr, 
                       int a_tlc, int b_tlr, int b_tlc, int nr, int nc )
{
  int           i, j;
  unsigned char *p_a, *p_b;

  /* copy a section of A into B */

  for (i = 1; i <= nr; i++) {
a1161 21
    for (j = 1; j <= nc; j++) {
      *p_b = *p_a;
      p_a++;
      p_b++;
    }
  }

  return( UT_OK );
}


/*******************************************************************************
COPY_DMAT_SECTION
Copy a rectangular section of one double matrix into a part of another matrix.
RG
*******************************************************************************/
int copy_dmat_section( double **a, double **b, int a_tlr, int a_tlc, int b_tlr,
                       int b_tlc, int nr, int nc )
{
  int       i, j;
  double    *p_a, *p_b;
d1163 1
a1163 34
  /* copy a section of A into B */

  for (i = 1; i <= nr; i++) {
    p_a = &a[a_tlr + i - 1][a_tlc];
    p_b = &b[b_tlr + i - 1][b_tlc];
    for (j = 1; j <= nc; j++) {
      *p_b = *p_a;
      p_a++;
      p_b++;
    }
  }
}


/*******************************************************************************
FAST_COPY_MAT_SECTION
Copy a rectangular section of one matrix into a part of another 
matrix by means of direct memory copy.
RG
*******************************************************************************/
int fast_copy_mat_section( float **a, float **b, int a_tlr, 
                           int a_tlc, int b_tlr, int b_tlc, int nr, int nc )
{
  int   i;
  int   mem_size;
  float *p_a, *p_b;

  mem_size = nc * sizeof( float );

  /* copy a section of A into B */

  for (i = 1; i <= nr; i++) {
    p_a = &a[a_tlr + i - 1][a_tlc];
    p_b = &b[b_tlr + i - 1][b_tlc];
d1173 1
a1173 1
FAST_COPY_IMAT_SECTION
d1175 3
d1181 2
a1182 2
int fast_copy_imat_section( int **a, int **b, int a_tlr, int a_tlc, int b_tlr, 
                            int b_tlc, int nr, int nc )
d1204 1
a1204 1
FAST_COPY_CMAT_SECTION
d1206 3
a1208 1
matrix by means of direct memory copy.
d1211 2
a1212 2
int fast_copy_cmat_section( unsigned char **a, unsigned char **b, int a_tlr, 
                            int a_tlc, int b_tlr, int b_tlc, int nr, int nc )
d1234 1
a1234 1
FAST_COPY_DMAT_SECTION
d1236 3
a1238 1
matrix by means of direct memory copy.
d1241 2
a1242 2
int fast_copy_dmat_section( double **a, double **b, int a_tlr, 
                            int a_tlc, int b_tlr, int b_tlc, int nr, int nc )
d1271 8
a1278 1
  int j;
d1280 1
a1280 2
  for (j=1; j <= nc; j++)
    mat[index][j] = vec[j];
@


1.35
log
@added set_imat
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.34 1997/06/20 22:09:41 granat Exp granat $";
d37 3
d262 50
d1129 190
d2213 1
a2213 1
  da_svdcmp(A, nr, nc, w, V, maxiter);
@


1.34
log
@fixed transpose memory handling, some penny optimization, some cosmetic changes
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.33 1997/06/05 18:53:57 granat Exp granat $";
d37 3
d1118 21
@


1.33
log
@added flip_vector, changed prototypes to match with conventions, some cosmetic changes
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.32 1997/06/02 15:37:02 granat Exp granat $";
d37 3
d167 1
d286 1
d289 1
d294 1
a294 1
    *p /= sum;
d313 1
d316 1
d322 1
a322 1
      *p /= sum;
d615 2
a616 1
int transpose_in_situ_alloc_matrix(float ***a, int nr, int nc, float *temp_vect)
d688 1
a688 9
  if (nr > nc) { 

    /* reassign pointers and free excess memory */

    for (i = 2; i <= nc; i++)
      (*a)[i] = (*a)[i-1]+nr;
    free(&(*a)[i]);
  }
  else if (nc > nr) { 
d691 1
a691 1

d693 1
a693 1
    if (!m) 
d706 27
d1613 1
d1617 2
d1621 1
a1621 1
    *p /= constant;
d1717 1
d1720 1
d1725 1
a1725 1
      *p /= constant;
d1868 2
a1869 1
  /* no error code returned, since this mirrors the NR NR_free_...() functions */
d1906 1
a1906 1
    NR_free_set_of_matrices(mat_set_set[i], num_mats, num_rows, num_cols);
@


1.32
log
@changed to use new NR naming convention
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.31 1997/05/06 22:23:05 agray Exp granat $";
d37 3
a256 1

a277 1

a331 1

a351 1

d527 1
a527 2
float range_vec(int n, float *v)

d550 1
a550 5
int transpose_matrix(a, nr, nc, a_trans)

  float **a;        /* input matrix, to be transposed */
  float **a_trans;  /* matrix that will hold the resulting transpose */
  int    nr, nc;    /* number of rows, columns of the input matrix */
d576 1
a576 5
int transpose_imatrix(a, nr, nc, a_trans)

  int   **a;        /* input matrix, to be transposed */
  int   **a_trans;  /* matrix that will hold the resulting transpose */
  int    nr, nc;    /* number of rows, columns of the input matrix */
d607 1
a607 5
int transpose_in_situ_alloc_matrix(a, nr, nc, temp_vect)

  float ***a;         /* pointer to the input matrix to be transposed */
  int      nr, nc;    /* number of rows, columns in the input matrix */
  float   *temp_vect; /* storage space for temporary values */
d717 1
a717 3
int transpose_in_situ_sqr_matrix( a, n )
  float **a;        /* input matrix, to be transposed */
  int    n;    /* number of rows, columns of the input matrix */
d752 27
d782 1
a782 1
Create a matrix which has the columns in reverse order from the given matrix.
d785 1
a785 4
int flip_left_right_matrix(a, nr, nc)
 
  float **a;       /* input matrix to be flipped */
  int     nr, nc;  /* number of rows, columns of the input matrix */
d819 1
a819 1
Create a matrix which has the rows in reverse order from the given matrix.
d822 1
a822 4
int flip_top_bottom_matrix(a, nr, nc)
 
  float **a;       /* input matrix to be flipped */
  int     nr, nc;  /* number of rows, columns of the input matrix */
d861 1
a861 5
int invert_mat(mat, nc, inv)

  float **mat;  /* input matrix to be inverted */
  int nc;       /* number of rows (or columns) of square input matrix */
  float **inv;  /* matrix that will hold the results */
d910 1
a910 5
int invert_mat_copy(mat, nc, inv)

  float **mat;  /* input matrix to be inverted */
  int nc;       /* number of rows (or columns) of square input matrix */
  float **inv;  /* matrix that will hold the results */
d934 1
a934 4
float det(mat, nc)

  float **mat;  /* input matrix */
  int nc;       /* number of rows (or columns) of square input matrix */
d964 1
a964 4
float det_copy(mat, nc)

  float **mat;  /* input matrix */
  int nc;       /* number of rows (or columns) of square input matrix */
a1050 1

a1066 1

d1086 1
a1086 2
int set_mat(int nr, int nc, float **m, float constant)

d1107 1
a1107 2
int set_vec(int nc, float *v, float constant)

d1129 1
a1129 2
int set_ivec(int nc, int *ivec, int constant)

a1148 1

a1170 1

d1190 1
a1190 5
int copy_mat(a, b, nr, nc)

  float **a;     /* input matrix, to be copied */
  float **b;     /* matrix that will hold the results */
  int   nr, nc;  /* number of rows, columns of input matrix */
d1208 1
a1208 5
int copy_vec(a, b, nc)

  float *a;     /* input vector, to be copied */
  float *b;     /* vector that will hold the results */
  int   nc;     /* number of columns of input vector */
a1233 1

a1265 1

d1287 1
a1287 3
float euclid_dist(v1,v2,length)
    float *v1, *v2;
    int length;
d1314 1
a1314 5
int mat_vec_mult(nr, nc, M, v, u)

  int    nr, nc;       /* number of rows, columns in matrix */
  float  **M, *v;      /* input matrix, input vector */
  float  *u;           /* vector that will hold the results */
d1344 2
a1345 6
int mat_mult(a, nra, nca, b, nrb, ncb, c)

  float **a, **b;    /* first input matrix, second input matrix */
  float **c;         /* matrix that will hold the result */
  int    nra, nca;   /* number of rows, columns of first matrix */
  int    nrb, ncb;   /* number of rows, columns of second matrix */
d1389 1
a1389 5
int add_mat(nr, nc, m1, m2, m3)

  int    nr, nc;         /* dimensions of the matrices */
  float  **m1, **m2;     /* first input matrix, second input matrix */
  float  **m3;           /* matrix that will hold the results */
d1418 1
a1418 5
int subtract_mat(nr, nc, m1, m2, m3)

  int    nr, nc;         /* dimensions of the matrices */
  float  **m1, **m2;     /* first input matrix, second input matrix */
  float  **m3;           /* matrix that will hold the results */
d1447 1
a1447 5
int add_vec(n, v1, v2, v3)

  int    n;              /* length of the vectors */
  float  *v1, *v2;       /* first input vector, second input vector */
  float  *v3;            /* vector that will hold the results */
d1470 3
a1472 2
 SUBTRACT_VEC
 Subtract one vector element-wise from another.
d1474 1
a1474 5
int subtract_vec(n, v1, v2, v3)

  int    n;              /* length of the vectors */
  float  *v1, *v2;       /* first input vector, second input vector */
  float  *v3;            /* vector that will hold the results */
d1500 1
a1500 4
float dot_product(x, n, y)

  int    n;              /* length of the vectors */
  float  *x, *y;         /* first input vector, second input vector */
d1524 1
a1524 5
int outer_product(nc, x, y, prod)

  int    nc;        /* length of the vectors */
  float  *x, *y;    /* first input vector, second input vector */
  float **prod;     /* matrix that will hold the result */
d1556 1
a1556 2
int scalar_mult_vec(int nc, float *v, float constant)

d1581 1
a1581 2
int scalar_div_vec(int nc, float *v, float constant)

d1606 1
a1606 2
int scalar_add_vec(int nc, float *v, float constant)

d1631 1
a1631 2
int scalar_subtract_vec(int nc, float *v, float constant)

d1656 1
a1656 2
int scalar_mult_mat(int nr, int nc, float **m, float constant)

d1682 1
a1682 2
int scalar_div_mat(int nr, int nc, float **m, float constant)

d1708 1
a1708 1
int scalar_add_mat(int nr, int nc, float **m, float constant)
d1735 1
a1735 2
int scalar_subtract_mat(int nr, int nc, float **m, float constant)

d1757 1
a1757 5
int mult_vec_elt(n, v1, v2, v3)

  int    n;              /* length of the vectors */
  float  *v1, *v2;       /* first input vector, second input vector */
  float  *v3;            /* vector that will hold the results */
d1783 1
a1783 5
int div_vec_elt(n, v1, v2, v3)

  int    n;              /* length of the vectors */
  float  *v1, *v2;       /* first input vector, second input vector */
  float  *v3;            /* vector that will hold the results */
a1805 1

d1825 1
a1825 1
void NR_free_set_of_matrices(float ***mat_set, int num_mats, int num_rows, 
a1826 1

a1844 1

d1866 1
a1866 1
void NR_free_set_of_sets_of_matrices(float ****mat_set_set, int num_sets, 
a1867 1

d1895 1
a1895 5
int pca(A, nr, nc, w, VT)

  float  **A, *w, **VT; /* see function comment; A is the data, w and VT will
                           get filled in by this function */
  int    nr, nc;        /* number of rows, columns of data */
@


1.31
log
@added some things from dp cooltool.
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.30 1997/05/06 19:04:15 granat Exp agray $";
d37 3
d132 1
a132 1
 * free_matrix() in pca().
a170 1
#include "nrutil.h"
d707 1
a707 1
      nrerror("allocation failure 1 in matrix()");
d872 1
a872 1
  col = vector(1,nc);
d878 1
a878 1
  index = ivector(1,nc);
d886 1
a886 1
  ludcmp(mat,nc,index,&d);
d891 1
a891 1
    lubksb(mat,nc,index,col);
d897 2
a898 2
  free_vector(col, 1, nc);
  free_ivector(index, 1, nc);
d918 1
a918 1
  mat_copy = matrix(1,nc,1,nc);
d925 1
a925 1
  free_matrix(mat_copy,1,nc,1,nc);
d946 1
a946 1
  index = ivector(1,nc);
d954 1
a954 1
  ludcmp(mat,nc,index,&d);
d978 1
a978 1
  mat_copy = matrix(1,nc,1,nc);
d985 1
a985 1
  free_matrix(mat_copy,1,nc,1,nc);
d1265 1
a1265 1
  len = imin( (vec_size - vec_start_pos + 1), sub_vec_size );
d1890 1
a1890 1
    mat_set[i] = matrix(1, num_rows, 1, num_cols);
d1899 1
a1899 1
void free_set_of_matrices(float ***mat_set, int num_mats, int num_rows, 
d1906 1
a1906 1
    free_matrix(mat_set[i], 1, num_rows, 1, num_cols);
d1910 1
a1910 1
  /* no error code returned, since this mirrors the NR free_...() functions */
d1942 1
a1942 1
void free_set_of_sets_of_matrices(float ****mat_set_set, int num_sets, 
d1949 1
a1949 1
    free_set_of_matrices(mat_set_set[i], num_mats, num_rows, num_cols);
d1953 1
a1953 1
  /* no error code returned, since this mirrors the NR free_...() functions */
d1982 1
a1982 1
  V = matrix(1, nr, 1, nc);
d1990 1
a1990 1
  maxiter = imax( 30, (int)(nr * nc / 10000) );
d1993 1
a1993 1
  da_svdcmp2(A, nr, nc, w, V, maxiter);
d1998 1
a1998 1
  free_matrix(V, 1, nc, 1, nc);
@


1.30
log
@added function copy_mat_section
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.29 1997/04/05 19:09:34 granat Exp granat $";
d37 3
d482 63
d1048 35
@


1.29
log
@added sum_mat() and norm_sum_mat()
adjusted functions so that they all follow input parameter conventions
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.28 1997/04/04 23:09:12 granat Exp granat $";
d37 4
a359 1
    /* sum += utLog( *p ); */
d927 1
a927 6
int grab_row(mat, index, nc, vec)

  float **mat;   /* input matrix, to have a row grabbed from it */
  int index;     /* index of the row to be grabbed, beginning with 1 */
  int nc;        /* length of the row to be grabbed */
  float *vec;    /* vector that will hold the results */
d950 1
a950 6
int grab_col(mat, index, nr, vec)

  float **mat;   /* input matrix, to have a column grabbed from it */
  int index;     /* index of the column to be grabbed, beginning with 1 */
  int nr;        /* length of the column to be grabbed */
  float *vec;    /* vector that will hold the results */
d959 25
@


1.28
log
@changed many functions so that they use pointer arithmatic
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.27 1997/04/04 19:00:30 granat Exp granat $";
d37 3
d173 1
a173 4
float norm(nc, v)

  int    nc;  /* length of the vector */
  float  *v;  /* input vector */
d182 1
a182 1
  for (i = 1; i <= nc; i++) {
d195 1
a195 4
float sum_vec(n, v)

  int    n;              /* length of the vector */
  float  *v;             /* input vector */
d215 25
d244 1
a244 1
int sum_mat_rows(float **mat, float *vec, int nr, int nc)
d252 2
a253 2
    curr_row = mat[i];
    vec[i] = sum_vec(nc, curr_row);
d266 1
a266 1
float norm_sum_vec(float *vec, int dim)
d273 1
a273 1
  sum = sum_vec(dim, vec);
d275 1
a275 1
  p = &vec[1];
d277 1
a277 1
  for (i = 1; i <= dim; i++) {
d287 26
d321 1
a321 1
int norm_sum_mat_rows(float **mat, int nr, int nc)
d329 1
a329 1
    curr_row = mat[i];
d342 1
a342 1
float sum_log_vec(float *vec, int dim)
d351 1
a351 1
  p = &vec[1];
d353 1
a353 1
  for (i = 1; i <= dim; i++)
d369 1
a369 4
float max_vec(n, v)

  int    n;              /* length of the vector */
  float  *v;             /* input vector */
d380 1
a382 1
    p++;
d397 1
a397 2
float min_vec(int n, float *v)

d408 1
a410 1
    p++;
d422 1
a422 4
int arg_max_vec(n, v)

  int    n;              /* length of the vector */
  float  *v;             /* input vector */
d452 1
a452 4
int arg_min_vec(n, v)

  int    n;              /* length of the vector */
  float  *v;             /* input vector */
@


1.27
log
@added comments to transpose_in_situ_ functions and flip_ functions
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.26 1997/03/27 18:09:48 granat Exp granat $";
d37 3
d168 1
a168 1
AG
d176 1
d179 2
d183 2
a184 1
      result += v[i] * v[i];
d193 1
a193 1
AG
d201 6
a206 1
  float   sum = 0.0;
d209 2
a210 1
    sum += v[i];
d242 1
a242 1
AG
d248 1
d251 3
a253 3
  sum = 0.0;
  for (i = 1; i <= dim; i++)
    sum += vec[i];
d255 4
a258 2
  for (i = 1; i <= dim; i++)
    vec[i] /= sum;
d292 1
a292 1
AG
d298 1
d302 3
d307 3
a309 2
    sum += log( (double) vec[i] );
    /* sum += utLog( vec[i] ); */
d319 1
a319 1
AG
d327 1
d331 3
d335 3
a337 2
    if (v[i] > maxval)
      maxval = v[i];
d350 1
a350 1
AG
d356 1
d360 3
d364 3
a366 2
    if (v[i] < minval)
      minval = v[i];
d376 1
a376 1
AG
d384 1
d390 3
d394 1
a394 1
    if (v[i] > maxval)
d396 1
a396 1
      maxval = v[i];
d399 1
d409 1
a409 1
AG
d417 1
d423 3
d427 1
a427 1
    if (v[i] < minval)
d429 1
a429 1
      minval = v[i];
d432 1
d884 1
a884 1
AG
d894 5
d900 5
a904 2
  for (j=1; j <= nc; j++)
    vec[j] = mat[index][j];
d1067 1
a1067 1
AG
d1076 5
d1083 3
a1085 1
    b[i] = a[i];
d1095 1
a1095 1
AG
d1102 2
d1108 8
a1115 2
  for (i = 1; i <= len; i++)
    vec[i + vec_start_pos - 1] = sub_vec[i];
d1152 1
a1152 1
AG
d1159 2
d1163 3
d1168 1
a1168 1
      diff = v1[i] - v2[i];
d1170 2
d1181 1
a1181 1
AG
d1190 6
d1198 2
a1199 1
    u[i] = 0.0;
d1201 3
a1203 1
      u[i] += M[i][j] * v[j];
d1205 1
d1226 3
d1240 2
d1245 3
a1247 1
      c[i][j] = 0.0;
d1249 3
a1251 1
        c[i][j] += a[i][k] * b[k][j];
d1253 1
d1264 1
a1264 1
AG
d1273 7
d1283 4
a1286 1
      m3[i][j] = m1[i][j] + m2[i][j];
d1297 1
a1297 1
AG
d1306 7
d1316 4
a1319 1
      m3[i][j] = m1[i][j] - m2[i][j];
d1330 1
a1330 1
AG
d1339 7
d1348 4
a1351 1
    v3[i] = v1[i] + v2[i];
d1369 8
a1376 1

d1378 4
a1381 1
    v3[i] = v1[i] - v2[i];
d1398 2
d1402 3
d1406 3
a1408 1
    result += x[i] * y[i];
d1417 1
a1417 1
AG
d1426 6
d1434 1
d1436 3
a1438 1
        prod[i][j] = x[i] * y[j];
d1440 1
d1453 1
a1453 1
AG
d1459 3
d1465 2
a1466 1
      v[i] *= constant;
d1479 1
a1479 1
AG
d1485 3
d1491 2
a1492 1
      v[i] /= constant;
d1505 1
a1505 1
AG
d1511 3
d1517 2
a1518 1
      v[i] += constant;
d1531 1
a1531 1
AG
d1537 3
d1543 2
a1544 1
      v[i] -= constant;
d1563 3
d1569 4
a1572 2
    for (j = 1; j <= nc; j++)
      m[i][j] *= constant;
d1584 1
a1584 1
AG
d1590 3
d1596 4
a1599 2
    for (j = 1; j <= nc; j++)
      m[i][j] /= constant;
d1611 1
a1611 1
AG
d1617 3
d1623 4
a1626 2
    for (j = 1; j <= nc; j++)
      m[i][j] += constant;
d1638 1
a1638 1
AG
d1644 3
d1650 4
a1653 2
    for (j = 1; j <= nc; j++)
      m[i][j] -= constant;
d1661 1
a1661 1
AG
d1670 7
d1679 4
a1682 1
    v3[i] = v1[i] * v2[i];
d1691 1
a1691 1
AG
d1700 3
d1705 4
a1708 1
    v3[i] = v1[i] / v2[i];
@


1.26
log
@added transpose_in_situ_alloc_matrix(), transpose_in_situ_sqr_matrix(),
flip_left_right_matrix(), flip_top_bottom_matrix()
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.25 1997/03/15 17:50:49 granat Exp granat $";
d37 4
d481 9
d502 2
d510 2
d513 4
d519 2
d527 2
d532 2
d541 5
a545 1
  /* allocate and assign a new pointer scheme */
a546 1
  if (nr > nc) {
d551 4
a554 1
  else if (nc > nr) {
d570 2
d593 3
d598 3
d608 3
d639 3
d644 3
d675 1
d679 4
d684 3
@


1.25
log
@Added flip_left_right_matrix() and flip_top_bottom_matrix()
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.24 1997/03/14 19:26:06 agray Exp granat $";
d37 3
d395 1
a395 1
Create the transpose of a matrix of floats.
d405 1
a405 1
  float  *p, *p_trans, *row_start;
d408 1
a408 1
  row_start = &a_trans[1][1];
d411 1
a411 1
    p_trans = row_start;
d417 1
a417 1
    row_start++;
d425 1
a425 1
Create the transpose of a matrix of integers.
d435 1
a435 1
  int    *p, *p_trans, *row_start;
d439 1
a439 1
  row_start = &a_trans[1][1];
d442 1
a442 1
    p_trans = row_start;
d448 1
a448 1
    row_start++;
d455 121
d588 1
d590 2
d595 1
d597 1
a597 1
    for (j = 1; j <= nc; j++) {
d622 1
d624 1
d627 1
a627 1
  for (i = 1; i <= nr; i++) {
@


1.24
log
@fixed minor bug in set_of_sets_of_matrices().
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.23 1997/02/18 22:25:15 granat Exp agray $";
d37 3
d448 60
@


1.23
log
@fixed subtle error in transpose
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.22 1997/02/14 15:00:37 granat Exp granat $";
d37 3
d1278 1
d1320 1
@


1.22
log
@fixed mistake in transpose_matrix
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.21 1997/02/14 00:25:15 granat Exp granat $";
d37 3
d406 1
a406 1
      p_trans += nc;
d437 1
a437 1
      p_trans += nc;
@


1.21
log
@fixed transpose function in pca
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.20 1997/02/14 00:06:59 granat Exp granat $";
d37 3
d392 2
a393 5
  int    i;
  int    num_elements;
  float  *p, *p_trans;

  num_elements = nr * nc;
d396 1
a396 1
  p_trans = &a_trans[1][1];
d398 8
a405 4
  for (i = 1; i <= num_elements; i++) {
    *p_trans = *p;
    p++;
    p_trans++;
d422 2
a423 3
  int    i;
  int    num_elements;
  int    *p, *p_trans;
a424 1
  num_elements = nr * nc;
d427 1
a427 1
  p_trans = &a_trans[1][1];
d429 8
a436 4
  for (i = 1; i <= num_elements; i++) {
    *p_trans = *p;
    p++;
    p_trans++;
@


1.20
log
@fixed typo
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.19 1997/02/14 00:01:25 granat Exp granat $";
d37 3
d1372 1
a1372 1
  transpose(V, nc, nc, VT);
@


1.19
log
@Changed transpose funtion to transpose_matrix
speeded up transpose algorithm
added transpose_imatrix to transpose matrices of integers
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.18 1997/01/29 21:45:45 agray Exp granat $";
d37 5
d409 1
a409 1
int transpose_matrix(a, nr, nc, a_trans)
@


1.18
log
@new formatting, cleaning up debugging output using ut_output,
cleaning up memory allocation with ut_memory.
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.17 1996/10/31 02:16:35 agray Exp agray $";
d37 4
d371 3
a373 3
TRANSPOSE
Create the transpose of a matrix.
AG
d375 1
a375 1
int transpose(a, nr, nc, a_trans)
d381 17
a397 1
  int    i, j;
d399 24
a422 4
  for (i = 1; i <= nr; i++) {
    for (j = 1; j <= nc; j++) {
      a_trans[j][i] = a[i][j];
    }
@


1.17
log
@changed .h and .c formats throughout library;
some reorganizing between modules;
added some functions from HMM project.
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.16 1996/09/24 17:54:42 agray Exp agray $";
d37 5
d107 1
d116 1
a116 1
#include "ut_types.h"
d118 2
d121 1
d130 1
d413 2
a414 1
    printf("Error in memory allocation.\n");
d419 2
a420 1
    printf("Error in memory allocation.\n");
d487 2
a488 1
    printf("Error in memory allocation.\n");
d725 21
d837 2
a838 1
    printf("Matrix dimensions are incompatible\n");
d1215 2
a1216 1
  mat_set = (float***) utMalloc((num_mats+1) * sizeof(float**));
d1237 1
a1237 1
  utFree(mat_set);
d1255 3
a1257 1
  mat_set_set = (float****) utMalloc((num_sets+1) * sizeof(float***));
d1279 1
a1279 1
  utFree(mat_set_set);
d1312 2
a1313 1
    printf("Error in memory allocation.\n");
d1318 1
a1318 1
  maxiter = utMax( 30, (int)(nr * nc / 10000) );
@


1.16
log
@changed svdcmp2() to da_svdcmp2().
@
text
@d2 2
d5 2
a6 10
  Title:     da_linalg
  Author:    Alexander Gray
  Function:  Data analysis routines, Numerical Recipes style.
             This file contains general linear algebraic concepts, like matrix-
             vector multiplication, & general i/o of linear algebra objects, 
             like reading in matrices.  Useful for 'filling in the gaps' left
             by the raw Numerical Recipes library.
  Reference: Numerical Recipes, 2e.
  How used:  First use - in ~/CoolTools/Merf/merf.c.
  Notes:     - 
d8 21
d31 1
a31 1
static char rcsid[] = "$Id: da_linalg.c,v 1.15 1996/07/30 23:17:30 agray Exp agray $";
d33 2
d37 3
d104 1
d109 1
d114 1
d118 1
d122 24
a145 2
 MAT_VEC_MULT
 Multiply a matrix to the left side of a vector.
d147 1
a147 1
int mat_vec_mult(nr, nc, M, v, u)
d149 2
a150 3
  int    nr, nc;       /* number of rows, columns in matrix */
  float  **M, *v;      /* input matrix, input vector */
  float  *u;           /* vector that will hold the results */
d152 2
a153 1
  int     i, j;
d155 2
a156 5
  for (i = 1; i <= nr; i++) {
    u[i] = 0.0;
    for (j = 1; j <= nc; j++) {
      u[i] += M[i][j] * v[j];
    }
d159 1
a159 1
  return (UT_OK);
d164 3
a166 2
 ADD_MAT
 Add one matrix element-wise to another.
d168 1
a168 1
int add_mat(nr, nc, m1, m2, m3)
a169 3
  int    nr, nc;         /* dimensions of the matrices */
  float  **m1, **m2;     /* first input matrix, second input matrix */
  float  **m3;           /* matrix that will hold the results */
d171 2
a172 1
  int     i,j;
d174 4
a177 4
  for (i = 1; i <= nr; i++) {
    for (j = 1; j <= nc; j++) {
      m3[i][j] = m1[i][j] + m2[i][j];
    }
d185 4
a188 2
 SUBTRACT_MAT
 Subtract one matrix element-wise from another.
d190 1
a190 1
int subtract_mat(nr, nc, m1, m2, m3)
a191 3
  int    nr, nc;         /* dimensions of the matrices */
  float  **m1, **m2;     /* first input matrix, second input matrix */
  float  **m3;           /* matrix that will hold the results */
d193 6
a198 1
  int     i,j;
d200 2
a201 5
  for (i = 1; i <= nr; i++) {
    for (j = 1; j <= nc; j++) {
      m3[i][j] = m1[i][j] - m2[i][j];
    }
  }
d203 1
a203 1
  return (UT_OK);
d208 7
a214 2
 ADD_VEC
 Add one vector element-wise to another.
d216 1
a216 1
int add_vec(n, v1, v2, v3)
a217 3
  int    n;              /* length of the vectors */
  float  *v1, *v2;       /* first input vector, second input vector */
  float  *v3;            /* vector that will hold the results */
d219 2
a220 1
  int     i;
d222 4
a225 2
  for (i = 1; i <= n; i++) {
    v3[i] = v1[i] + v2[i];
d233 3
a235 2
 SUBTRACT_VEC
 Subtract one vector element-wise from another.
d237 1
a237 1
int subtract_vec(n, v1, v2, v3)
a238 3
  int    n;              /* length of the vectors */
  float  *v1, *v2;       /* first input vector, second input vector */
  float  *v3;            /* vector that will hold the results */
d240 2
a241 1
  int     i;
d243 5
a247 2
  for (i = 1; i <= n; i++) {
    v3[i] = v1[i] - v2[i];
d250 1
a250 1
  return (UT_OK);
d253 1
d255 3
a257 2
 DOT_PRODUCT
 Compute the dot product of two vectors.
d259 1
a259 1
float dot_product(x, n, y)
d261 2
a262 2
  int    n;              /* length of the vectors */
  float  *x, *y;         /* first input vector, second input vector */
d264 2
a265 2
  int    i;
  float  result = 0.0;
d267 4
a270 2
  for (i = 1; i <= n; i++) {
    result += x[i] * y[i];
d273 1
a273 1
  return(result);
d276 1
d278 6
a283 2
 OUTER_PRODUCT
 Compute the outer product of two vectors.
d285 1
a285 1
int outer_product(nc, x, y, prod)
a286 3
  int    nc;        /* length of the vectors */
  float  *x, *y;    /* first input vector, second input vector */
  float **prod;     /* matrix that will hold the result */
d288 2
a289 1
  int    i, j;
d291 4
a294 4
  for (i = 1; i <= nc; i++) {
    for (j = 1; j <= nc; j++) {
        prod[i][j] = x[i] * y[j];
    }
d297 3
a299 2
  return (UT_OK);
}  
d302 3
a304 2
 TRANSPOSE
 Create the transpose of a matrix.
d306 1
a306 1
int transpose(a, nr, nc, a_trans)
d308 2
a309 3
  float **a;        /* input matrix, to be transposed */
  float **a_trans;  /* matrix that will hold the resulting transpose */
  int    nr, nc;    /* number of rows, columns of the input matrix */
d311 3
a313 1
  int    i, j;
d315 7
a321 3
  for (i = 1; i <= nr; i++) {
    for (j = 1; j <= nc; j++) {
      a_trans[j][i] = a[i][j];
d325 1
a325 1
  return (UT_OK);
d330 3
a332 2
 MAT_MULT
 Multiply two matrices.
d334 1
a334 1
int mat_mult(a, nra, nca, b, nrb, ncb, c)
d336 2
a337 4
  float **a, **b;    /* first input matrix, second input matrix */
  float **c;         /* matrix that will hold the result */
  int    nra, nca;   /* number of rows, columns of first matrix */
  int    nrb, ncb;   /* number of rows, columns of second matrix */
d339 3
a341 2
  int    i, j, k;
  int    nrc, ncc;
d343 7
a349 16
  /* check for compatible dimensions */
  if (nca != nrb) {
    printf("Matrix dimensions are incompatible\n");
    return (UT_ERROR);
  }

  nrc = nra;
  ncc = ncb;
 
  /* accumulate results */
  for (i = 1; i <= nrc; i++) {
    for (j = 1; j <= ncc; j++) {
      c[i][j] = 0.0;
      for (k = 1; k <= nca; k++) {
        c[i][j] += a[i][k] * b[k][j];
      }
d353 1
a353 1
  return (UT_OK);
a355 1

d357 3
a359 2
 COPY_MAT
 Copy a matrix.
d361 1
a361 1
int copy_mat(a, b, nr, nc)
d363 3
a365 3
  float **a;     /* input matrix, to be copied */
  float **b;     /* matrix that will hold the results */
  int   nr, nc;  /* number of rows, columns of input matrix */
d367 1
a367 1
  int   i, j;
d371 1
a371 1
      b[i][j] = a[i][j];
a377 1

d379 5
a383 4
 INVERT_MAT
 Invert a matrix.  
 Destroys the original.  
 Ref: Numerical Recipes 2e, p. 48.
d431 4
a434 3
 INVERT_MAT_COPY
 Invert matrix copy.  
 Like invert_mat(), but does not destroy the original; makes a copy first.
d458 5
a462 4
 DET
 Determinant of a matrix.
 Destroys the original.  
 Ref: Numerical Recipes 2e, p. 49.
d491 4
a494 3
 DET_COPY
 Determinant of matrix copy.
 Like det(), but does not destroy the original; makes a copy first.
d517 3
a519 2
 GRAB_ROW
 Create the vector obtained from the specified row of the matrix.
d537 3
a539 2
 GRAB_COL
 Create the vector obtained from the specified column of the matrix.
d557 7
a563 2
 NORM
 Returns the norm of a vector.
d565 1
a565 1
float norm(nc, v)
a566 2
  int    nc;  /* length of the vector */
  float  *v;  /* input vector */
d568 1
a568 2
  int     i;
  float result = 0.0;
d570 4
a573 4
  /* accumulate square of the vector */
  for (i = 1; i <= nc; i++) {
      result += v[i] * v[i];
  }
d575 1
a575 1
  return (sqrt((double) result ));
d579 7
a585 10
 PCA
 Perform principal components analysis (PCA) on a matrix.  The output is three 
 matrices, one containing the principal components for the data, one containing
 the associated eigenvalues, and one containing the other orthogonal matrix in 
 the decomposition.  These correspond to U, W, and V^T respectively in the 
 decomposition of the input matrix A = U * W * V^T.
 Done using singular value decomposition (SVD).
 Notes: A is overwritten by U.  nr and nc are the dimensions of A (and thus U).
 Use the vector w instead of the matrix W to hold the eigenvalues, of size nc.
 VT has dimensions nc x nc.
d587 1
a587 1
int pca(A, nr, nc, w, VT)
a588 3
  float  **A, *w, **VT; /* see function comment; A is the data, w and VT will
                           get filled in by this function */
  int    nr, nc;        /* number of rows, columns of data */
d590 1
a590 2
  float **V;
  int maxiter;
d592 3
a594 5
  /* allocate the transpose of VT, V */
  V = matrix(1, nr, 1, nc);
  if (V == (float**)NULL) {
    printf("Error in memory allocation.\n");
    return (UT_ERROR);
a596 10
  /* heuristic to set the number of svd iterations */
  maxiter = utMax( 30, (int)(nr * nc / 10000) );

  /* compute the svd; A will be overwritten by U */
  da_svdcmp2(A, nr, nc, w, V, maxiter);

  /* this returns V rather than the transpose V^T */
  transpose(V, nc, nc, VT);

  free_matrix(V, 1, nc, 1, nc);
d602 7
a608 8
 RESTRICT_ILLCOND_MATRIX
 A hack procedure to restrict an ill-conditioned matrix such that it stays 
 out of the realm of ill-conditioned matrices (hopefully), by ensuring that
 the diagonal elements are above some small specified value.

 mat is the input matrix.
 dim is the size of the square matrix.
 min_diag is the minimum value for a diagonal element of the matrix.
d610 1
a610 1
int restrict_illcond_matrix(float **mat, int dim, float min_diag)
d615 114
a728 2
  /* NOTE: this should ideally compute the condition number of the matrix,
     and only do this if the condition number is less than some value */
d739 171
d911 5
a915 2
 SCALAR_MULT_VEC
 Scales a vector by a specified multiplicand.
d917 43
a959 3
 nc is the length of the vector.
 v is the input vector.
 constant is the multiplicand to scale the vector by.
d975 2
a976 2
 SCALAR_DIV_VEC
 Scales a vector by a specified dividend.
d978 4
a981 3
 nc is the length of the vector.
 v is the input vector.
 constant is the dividend to scale the vector by.
d997 2
a998 2
 SCALAR_ADD_VEC
 Translates a vector by a specified addend.
d1000 4
a1003 3
 nc is the length of the vector.
 v is the input vector.
 constant is the addend to translate the vector by.
d1019 2
a1020 2
 SCALAR_SUBTRACT_VEC
 Translates a vector by a specified subtrahend.
d1022 4
a1025 3
 nc is the length of the vector.
 v is the input vector.
 constant is the subtrahend to translate the vector by.
d1041 2
a1042 2
 SCALAR_MULT_MAT
 Scales a matrix by a specified multiplicand.
d1044 4
a1047 3
 nr and nc are the dimensions of the matrix (num. rows and num. cols).
 m is the input matrix.
 constant is the multiplicand to scale the matrix by.
d1063 2
a1064 2
 SCALAR_DIV_MAT
 Scales a matrix by a specified dividend.
d1066 4
a1069 3
 nr and nc are the dimensions of the matrix (num. rows and num. cols).
 m is the input matrix.
 constant is the dividend to scale the matrix by.
d1085 2
a1086 2
 SCALAR_ADD_MAT
 Translates a matrix by a specified addend.
d1088 4
a1091 3
 nr and nc are the dimensions of the matrix (num. rows and num. cols).
 m is the input matrix.
 constant is the addend to translate the matrix by.
d1107 2
a1108 2
 SCALAR_SUBTRACT_MAT
 Translates a matrix by a specified subtrahend.
d1110 4
a1113 3
 nr and nc are the dimensions of the matrix (num. rows and num. cols).
 m is the input matrix.
 constant is the subtrahend to translate the matrix by.
d1129 3
a1131 45
 SET_MAT
 Sets each of the values of a matrix to a specified number.

 nr and nc are the dimensions of the matrix (num. rows and num. cols).
 m is the input matrix.
 constant is the amount to set all the values to.
*******************************************************************************/
int set_mat(int nr, int nc, float **m, float constant)

{
  int     i,j;

  /* change each element of the vector */
  for (i = 1; i <= nr; i++)
    for (j = 1; j <= nc; j++)
      m[i][j] = constant;

  return (UT_OK);
}

/*******************************************************************************
 SET_VEC
 Sets each of the values of a vector to a specified number.

 nc is the length of the vector (num. cols).
 v is the input vector.
 constant is the amount to set all the values to.
*******************************************************************************/
int set_vec(int nc, float *v, float constant)

{
  int     i;

  /* change each element of the vector */
  for (i = 1; i <= nc; i++) {
      v[i] = constant;
  }

  return (UT_OK);
}


/*******************************************************************************
 MULT_VEC_ELT
 Multiply one vector element-wise by another.
d1149 3
a1151 2
 DIV_VEC_ELT
 Divide one vector element-wise by another.
d1170 2
a1171 2
 SUM_VEC
 Sum the values in a vector.
d1173 1
a1173 1
float sum_vec(n, v)
a1174 2
  int    n;              /* length of the vector */
  float  *v;             /* input vector */
d1176 5
a1180 2
  int     i;
  float   sum = 0.0;
d1182 2
a1183 3
  for (i = 1; i <= n; i++) {
    sum += v[i];
  }
d1185 1
a1185 1
  return (sum);
a1187 1

d1189 2
a1190 2
 MAX_VEC
 Return the maximum value in a vector.
d1192 2
a1193 1
float max_vec(n, v)
a1194 2
  int    n;              /* length of the vector */
  float  *v;             /* input vector */
d1196 4
a1199 2
  int     i;
  float   maxval;
d1201 1
a1201 5
  maxval = v[1];
  for (i = 2; i <= n; i++) {
    if (v[i] > maxval)
      maxval = v[i];
  }
d1203 1
a1203 1
  return (maxval);
d1208 2
a1209 5
 MIN_VEC
 Return the minimum value in a vector.

 n is the length of the vector.
 v is the input vector.
d1211 2
a1212 1
float min_vec(int n, float *v)
d1215 5
a1219 2
  int     i;
  float   minval;
d1221 2
a1222 5
  minval = v[1];
  for (i = 2; i <= n; i++) {
    if (v[i] < minval)
      minval = v[i];
  }
d1224 1
a1224 1
  return (minval);
d1229 2
a1230 2
 ARG_MAX_VEC
 Return the index of the maximum value in a vector.
d1232 2
a1233 1
int arg_max_vec(n, v)
a1234 2
  int    n;              /* length of the vector */
  float  *v;             /* input vector */
d1236 4
a1239 3
  int     i;
  float   maxval;
  int     arg;
d1241 1
a1241 9
  maxval = v[1];
  arg = 1;
  for (i = 2; i <= n; i++) {
    if (v[i] > maxval)
    {
      maxval = v[i];
      arg = i;
    }
  }
d1243 1
a1243 1
  return (arg);
d1248 13
a1260 2
 ARG_MIN_VEC
 Return the index of the minimum value in a vector.
d1262 1
a1262 1
int arg_min_vec(n, v)
d1264 3
a1266 2
  int    n;              /* length of the vector */
  float  *v;             /* input vector */
d1268 2
a1269 3
  int     i;
  float   minval;
  int     arg;
d1271 5
a1275 8
  minval = v[1];
  arg = 1;
  for (i = 2; i <= n; i++) {
    if (v[i] < minval)
    {
      minval = v[i];
      arg = i;
    }
d1278 2
a1279 2
  return (arg);
}
d1281 2
a1282 5
/*******************************************************************************
 COPY_VEC
 Copy a vector.
*******************************************************************************/
int copy_vec(a, b, nc)
d1284 2
a1285 9
  float *a;     /* input vector, to be copied */
  float *b;     /* vector that will hold the results */
  int   nc;     /* number of columns of input vector */
{
  int    i;

  for (i = 1; i <= nc; i++) {
    b[i] = a[i];
  }
d1287 1
d1293 2
a1294 1
 READ_ROW
d1299 2
a1300 1
 READ_COL
@


1.15
log
@changed heuristic for number of iterations in pca().
@
text
@d16 1
a16 1
static char rcsid[] = "$Id: da_linalg.c,v 1.14 1996/07/17 20:43:37 agray Exp agray $";
d20 3
d548 1
a548 1
  svdcmp2(A, nr, nc, w, V, maxiter);
@


1.14
log
@cosmetic.
@
text
@d16 1
a16 1
static char rcsid[] = "$Id: da_linalg.c,v 1.13 1996/07/13 01:07:59 agray Exp agray $";
d20 3
d86 1
d542 1
a542 1
  maxiter = (int) (nr * nc / 10000);
@


1.13
log
@moved out print/write_row/col/irow/icol() to da_data module
@
text
@a11 3

  Compile:   make
  Example:   -
d16 1
a16 1
static char rcsid[] = "$Id: da_linalg.c,v 1.12 1996/07/11 18:03:45 agray Exp agray $";
d20 3
@


1.12
log
@moved out read_gauss_parms(), write_gauss_parms() to da_prob module;
added add_mat(), subtract_mat(), invert_mat_copy(), det_copy(),
restrict_illcond_matrix(), scalar_mult/div/add/subtract_mat/vec(), set_mat(),
set_vec(), mult/div_vec_elt(), sum_vec(), max/min_vec(), arg_max/min_vec(),
copy_vec().
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: da_linalg.c,v 1.11 1996/04/09 02:49:36 agray Exp agray $";
d23 7
a507 194

/*******************************************************************************
 PRINT_ROW
 Print the contents of a vector, in row form.
*******************************************************************************/
int print_row(stream, nc, v)

  FILE*  stream; /* stream to print to, e.g. stdout, file pointer */
  int    nc;     /* length of the row vector to be printed */
  float  *v;     /* vector to be printed */
{
  int     i;

  for (i = 1; i <= nc; i++) {
      fprintf(stream, "%g ", v[i]);
  }
  fprintf(stream, "\n");

  return (UT_OK);
}


/*******************************************************************************
 PRINT_COL
 Print the contents of a vector, in column form.
*******************************************************************************/
int print_col(stream, nc, v)

  FILE*  stream; /* stream to print to, e.g. stdout, file pointer */
  int    nc;     /* length of the column vector to be printed */
  float  *v;     /* vector to be printed */
{
  int     i;

  for (i = 1; i <= nc; i++) {
      fprintf(stream, "%g\n", v[i]);
  }

  return (UT_OK);
}


/*******************************************************************************
 WRITE_ROW
 Write a vector to a file, in row form.
*******************************************************************************/
int write_row(outfile, dim, vec, mode)

  char   *outfile;  /* name of file to write to */
  int    dim;       /* length of the row */
  float  *vec;      /* row vector to be written */
  char   *mode;     /* file i/o mode to use: e.g. "w", "r", or "a" */
{
  FILE    *fp;

  /* open file in the specified mode */
  fp = fopen(outfile, mode);
  if (fp == (FILE*) NULL) {
    printf("Error in trying to open a file.\n");
    return (UT_ERROR);
  }

  /* print matrix contents to file */
  print_row(fp, dim, vec);

  fclose(fp);
  return (UT_OK);
}


/*******************************************************************************
 WRITE_COL
 Write a vector to a file, in column form.
*******************************************************************************/
int write_col(outfile, dim, vec, mode)

  char   *outfile;  /* name of file to write to */
  int    dim;       /* length of the column */
  float  *vec;      /* column vector to be written */
  char   *mode;     /* file i/o mode to use: e.g. "w", "r", or "a" */
{
  FILE    *fp;

  /* open file in the specified mode */
  fp = fopen(outfile, mode);
  if (fp == (FILE*) NULL) {
    printf("Error in trying to open a file.\n");
    return (UT_ERROR);
  }

  /* print matrix contents to file */
  print_col(fp, dim, vec);

  fclose(fp);
  return (UT_OK);
}


/*******************************************************************************
 PRINT_IROW
 Print the contents of an integer vector, in row form.
*******************************************************************************/
int print_irow(stream, nc, v)

  FILE*  stream; /* stream to print to, e.g. stdout, file pointer */
  int    nc;     /* length of the row vector to be printed */
  int    *v;     /* vector to be printed */
{
  int     i;

  for (i = 1; i <= nc; i++) {
      fprintf(stream, "%d ", v[i]);
  }
  fprintf(stream, "\n");

  return (UT_OK);
}


/*******************************************************************************
 PRINT_ICOL
 Print the contents of an integer vector, in column form.
*******************************************************************************/
int print_icol(stream, nc, v)

  FILE*  stream; /* stream to print to, e.g. stdout, file pointer */
  int    nc;     /* length of the column vector to be printed */
  int    *v;     /* vector to be printed */
{
  int     i;

  for (i = 1; i <= nc; i++) {
      fprintf(stream, "%d\n", v[i]);
  }

  return (UT_OK);
}


/*******************************************************************************
 WRITE_IROW
 Write an integer vector to a file, in row form.
*******************************************************************************/
int write_irow(outfile, dim, vec, mode)

  char   *outfile;  /* name of file to write to */
  int    dim;       /* length of the row */
  int    *vec;      /* row vector to be written */
  char   *mode;     /* file i/o mode to use: e.g. "w", "r", or "a" */
{
  FILE    *fp;

  /* open file in the specified mode */
  fp = fopen(outfile, mode);
  if (fp == (FILE*) NULL) {
    printf("Error in trying to open a file.\n");
    return (UT_ERROR);
  }

  /* print matrix contents to file */
  print_irow(fp, dim, vec);

  fclose(fp);
  return (UT_OK);
}


/*******************************************************************************
 WRITE_ICOL
 Write an integer vector to a file, in column form.
*******************************************************************************/
int write_icol(outfile, dim, vec, mode)

  char   *outfile;  /* name of file to write to */
  int    dim;       /* length of the column */
  int    *vec;      /* column vector to be written */
  char   *mode;     /* file i/o mode to use: e.g. "w", "r", or "a" */
{
  FILE    *fp;

  /* open file in the specified mode */
  fp = fopen(outfile, mode);
  if (fp == (FILE*) NULL) {
    printf("Error in trying to open a file.\n");
    return (UT_ERROR);
  }

  /* print matrix contents to file */
  print_icol(fp, dim, vec);

  fclose(fp);
  return (UT_OK);
}

@


1.11
log
@added print_irow(), print_icol(), write_irow(), write_icol().
ag
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: da_linalg.c,v 1.10 1996/03/01 00:22:16 agray Exp agray $";
d21 6
a26 1
/* $Log: da_linalg.c,v $
d74 1
d77 1
d80 1
d84 8
a91 10
 READ_GAUSS_PARMS
 Read in a standard file containing mean vector and covariance matrix.
 Allocates the structures that will hold the mean vector and covariance matrix.
*******************************************************************************/
int read_gauss_parms(parmsfile, nc, mean, cov)

  char   *parmsfile;      /* name of file to read */
  int    nc;              /* number of dimensions of Gaussian */
  float  **mean, ***cov;  /* ptrs to mean vector and covariance matrix to be 
                             filled in */
d93 1
a93 2
  FILE    *fp;
  int     j, k;
d95 4
a98 30
  /* open file for reading */
  fp = fopen(parmsfile, "r");
  if (fp == (FILE*) NULL) {
    printf("Error in trying to open a file.\n");
    return (UT_ERROR);
  }

  /* allocate mean vector */
  *mean = vector(1, nc);
  if (*mean == (float*)NULL) {
    printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }

  /* allocate covariance matrix */
  *cov = matrix(1, nc, 1, nc);
  if (*cov == (float**)NULL) {
    printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }

  /* read mean vector from file */
  for (j = 1; j <= nc; j++) {
    fscanf(fp, "%g ", &(*mean)[j]);
  }

  /* read covariance matrix from file */
  for (j = 1; j <= nc; j++) {
    for (k = 1; k <= nc; k++) {
      fscanf(fp, "%g ", &(*cov)[j][k]);
a101 1
  fclose(fp);
d105 1
d107 2
a108 2
 WRITE_GAUSS_PARMS
 Write out a standard file containing mean vector and covariance matrix.
d110 1
a110 1
int write_gauss_parms(parmsfile, nc, mean, cov)
d112 3
a114 3
  char   *parmsfile;    /* name of file to read */
  int    nc;            /* number of dimensions in Gaussian */
  float  *mean, **cov;  /* mean vector and covariance matrix to write */
d116 1
a116 2
  /* print mean vector to file, in writing mode */
  write_row(parmsfile, nc, mean, "w");
d118 5
a122 2
  /* print covariance matrix to file, in appending mode */
  write_matrix(parmsfile, nc, nc, cov, "a");
d127 1
d129 2
a130 2
 MAT_VEC_MULT
 Multiply a matrix to the left side of a vector.
d132 1
a132 1
int mat_vec_mult(nr, nc, M, v, u)
d134 3
a136 3
  int    nr, nc;       /* number of rows, columns in matrix */
  float  **M, *v;      /* input matrix, input vector */
  float  *u;           /* vector that will hold the results */
d138 1
a138 1
  int     i, j;
a140 1
    u[i] = 0.0;
d142 1
a142 1
      u[i] += M[i][j] * v[j];
d296 1
a296 1
  int    nr, nc; /* number of rows, columns of input matrix */
d298 1
a298 1
  int    i, j;
d325 6
d362 26
d420 25
d709 1
d734 415
@


1.10
log
@moved read_data() and write_data() to da_data module.
changed %f to %g in all format strings.
ag
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: da_linalg.c,v 1.9 1996/02/29 02:33:32 agray Exp agray $";
d22 5
d555 97
@


1.9
log
@moved write_bin_matrix() and read_bin_matrix() to da_data module
ag
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: da_linalg.c,v 1.8 1996/02/29 00:54:12 agray Exp agray $";
d22 4
a70 71
 READ_MATRIX
 Read in file containing a matrix.
 Allocates the matrix that will hold the data.
 Similar to read_data(), except that the number of data is not at the top of 
 the file.
*******************************************************************************/
int read_matrix(infile, nr, nc, vals)

  char   *infile;   /* name of file to read */
  int    nr;        /* number of rows in matrix */
  int    nc;        /* number of columns in matrix */
  float  ***vals;   /* pointer to matrix to be filled in */
{
  FILE   *fp;
  int    i, j;

  /* open file for reading */
  fp = fopen(infile, "r");
  if (fp == (FILE*) NULL) {
    printf("Error in trying to open a file.\n");
    return (UT_ERROR);
  }

  /* allocate data matrix */
  *vals = matrix(1, nr, 1, nc);
  if (*vals == (float**)NULL) {
    printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }

  /* read from file into the matrix */
  for (i = 1; i <= nr; i++) {
    for (j = 1; j <= nc; j++) {
      fscanf(fp, "%f ", &(*vals)[i][j]);
    }
  }

  fclose(fp);
  return (UT_OK);
}


/*******************************************************************************
 WRITE_MATRIX
 Write a matrix to a file.
*******************************************************************************/
int write_matrix(outfile, nr, nc, mat, mode)

  char   *outfile;   /* name of file to write to */
  int    nr, nc;     /* number of rows, columns in matrix */
  float  **mat;      /* matrix to write */
  char   *mode;      /* file i/o mode to use: e.g. "w", "r", or "a" */
{
  FILE    *fp;

  /* open file in the specified mode */
  fp = fopen(outfile, mode);
  if (fp == (FILE*) NULL) {
    printf("Error in trying to open a file.\n");
    return (UT_ERROR);
  }

  /* print matrix contents to file */
  print_matrix(fp, nr, nc, mat);

  fclose(fp);
  return (UT_OK);
}


/*******************************************************************************
d108 1
a108 1
    fscanf(fp, "%f ", &(*mean)[j]);
d114 1
a114 1
      fscanf(fp, "%f ", &(*cov)[j][k]);
a141 44
 READ_DATA
 Read in file containing the rows of data.
 Assumes that the file is in the standard dataset format, with line count at 
 top, separated by spaces.
 Allocates the matrix that will hold the data.
*******************************************************************************/
int read_data(infile, nr, nc, vals)
  char   *infile;   /* name of file to read */
  int    *nr;       /* ptr to number of rows in data, to be filled in */
  int    nc;        /* number of columns in data */
  float  ***vals;   /* ptr to matrix to be filled in with data */
{
  FILE    *fp;
  int     i, j;

  /* open file for reading */
  fp = fopen(infile, "r");
  if (fp == (FILE*) NULL) {
    printf("Error in trying to open a file.\n");
    return (UT_ERROR);
  }

  /* fills in numrows */
  fscanf(fp, "%d", nr);

  /* allocate data matrix */
  *vals = matrix(1, *nr, 1, nc);
  if (*vals == (float**)NULL) {
    printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }

  /* read from file into the matrix */
  for (i = 1; i <= *nr; i++) {
    for (j = 1; j <= nc; j++) {
      fscanf(fp, "%f ", &(*vals)[i][j]);
    }
  }

  fclose(fp);
  return (UT_OK);
}

/*******************************************************************************
d472 1
a472 1
      fprintf(stream, "%f ", v[i]);
d493 1
a493 1
      fprintf(stream, "%f\n", v[i]);
a500 22
 PRINT_MATRIX
 Print the contents of a matrix.
*******************************************************************************/
int print_matrix(stream, nr, nc, mat)

  FILE*  stream;  /* stream to print to, e.g. stdout, file pointer */
  int    nr, nc;  /* number of rows, columns of input matrix */
  float  **mat;   /* matrix to be printed */
{
  int i,j;

  for (i=1; i<=nr; i++) {
    for (j=1;j<=nc;j++) {
      fprintf(stream, "%f ", mat[i][j]);
    }
    fprintf(stream, "\n");
  }

  return (UT_OK);
}

/*******************************************************************************
a554 38

/*******************************************************************************
 WRITE_DATA
 Write a matrix to a file in the standard data file format, with number of lines
 at top of file.
*******************************************************************************/
int write_data(outfile, nr, nc, mat)

  char   *outfile;  /* name of file to write to */
  int    nr, nc;    /* number of rows, columns of data */
  float  **mat;     /* matrix of data to be written */
{
  FILE    *fp;

  /* open file for writing */
  fp = fopen(outfile, "w");
  if (fp == (FILE*) NULL) {
    printf("Error in trying to open a file.\n");
    return (UT_ERROR);
  }

  /* print number of lines at top */
  fprintf(fp, "%d\n", nr);
  fclose(fp);

  /* open file for appending */
  fp = fopen(outfile, "a");
  if (fp == (FILE*) NULL) {
    printf("Error in trying to open a file.\n");
    return (UT_ERROR);
  }

  /* print matrix contents to file */
  print_matrix(fp, nr, nc, mat);
  fclose(fp);

  return (UT_OK);
}
@


1.8
log
@changed pca() to call svdcmp2() instead of svdcmp(); added svdcmp2()
to NR lib. to make the number of svd iterations a controllable
parameter.
ag
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: da_linalg.c,v 1.7 1996/02/28 03:57:52 agray Exp agray $";
d22 6
d61 1
a130 74

  fclose(fp);
  return (UT_OK);
}


/*******************************************************************************
 READ_BIN_MATRIX
 Read in file containing a matrix, which is in binary form.
 Allocates the matrix that will hold the data.
 Similar to read_matrix().
*******************************************************************************/
int read_bin_matrix(infile, nr, nc, vals)

  char   *infile;   /* name of file to read */
  int    nr;        /* number of rows in matrix */
  int    nc;        /* number of columns in matrix */
  float  ***vals;   /* pointer to matrix to be filled in */
{
  FILE   *fp;
  int    i;

  /* open file for reading */
  fp = fopen(infile, "r");
  if (fp == (FILE*) NULL) {
    printf("Error in trying to open a file.\n");
    return (UT_ERROR);
  }

  /* allocate data matrix */
  *vals = matrix(1, nr, 1, nc);
  if (*vals == (float**)NULL) {
    printf("Error in memory allocation.\n");
    return (UT_ERROR);
  }

  /* read from file into the matrix, in binary format */
  for (i=1; i<=nr; i++) {
    fread( (float*) &((*vals)[i][1]), sizeof(float), nc, fp );
  }

  fclose(fp);
  return (UT_OK);
}


/*******************************************************************************
 WRITE_BIN_MATRIX
 Write a matrix to a file, in binary form.
 Note that the NR convention of accessing matrices starting at 1 is implemented
 by the matrix() allocation function by simply allocating the 0th element also,
 which is never accessed.
*******************************************************************************/
int write_bin_matrix(outfile, nr, nc, mat, mode)

  char   *outfile;   /* name of file to write to */
  int    nr, nc;     /* number of rows, columns in matrix */
  float  **mat;      /* matrix to write */
  char   *mode;      /* file i/o mode to use: e.g. "w", "r", or "a" */
{
  FILE    *fp;
  int     i;

  /* open file in the specified mode */
  fp = fopen(outfile, mode);
  if (fp == (FILE*) NULL) {
    printf("Error in trying to open a file.\n");
    return (UT_ERROR);
  }

  /* print matrix contents to file, in binary */
  for (i=1; i<=nr; i++) {
    fwrite( (float*) &mat[i][1], sizeof(float), nc, fp );
  }
@


1.7
log
@put in checks for all memory allocations
AG
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: da_linalg.c,v 1.6 1996/02/21 05:16:23 agray Exp agray $";
d22 4
d812 1
d814 1
d821 3
d825 1
a825 1
  svdcmp(A, nr, nc, w, V);
@


1.6
log
@free_matrix() in pca().
ag
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: da_linalg.c,v 1.5 1996/02/21 04:08:46 agray Exp agray $";
d22 4
d810 4
@


1.5
log
@added nr.h inclusion
ag
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: da_linalg.c,v 1.4 1996/02/21 04:02:21 agray Exp agray $";
d22 4
d813 1
@


1.4
log
@moved some general notes on coding conventions into the file conventions.txt
in the /doc directory.
ag
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: da_linalg.c,v 1.3 1996/02/21 03:51:36 agray Exp agray $";
d22 5
d44 1
@


1.3
log
@added pca().
ag
@
text
@d15 1
a15 5
  Notes:     Functions that read input files to create internal structures 
             allocate the memory for those structures automatically; just pass
             them a pointer to the appropriate structure.  Otherwise, allocation
             of structures must be done by the user before calling the function.
             This approach is taken to make memory use more explicit.
a16 4
  Revisions: 1/18/96 AG created
             2/5/96  AG made memory allocation consistent.
                        added copy_mat().

d19 1
a19 1
static char rcsid[] = "$Id: da_linalg.c,v 1.2 1996/02/21 00:37:20 agray Exp agray $";
d22 4
@


1.2
log
@added write_bin_matrix() and read_bin_matrix()
ag
@
text
@d27 1
a27 1
static char rcsid[] = "$Id: da_linalg.c,v 1.1 1996/02/06 03:27:47 agray Exp agray $";
d30 4
d779 31
@


1.1
log
@Initial revision
@
text
@d27 1
a27 1
static char rcsid[] = "$Id$";
d29 4
a32 1
/* $Log$ */
d106 74
@
